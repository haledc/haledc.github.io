<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hale&#39;s Notes</title>
  
  <subtitle>记事本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haledeng.com/"/>
  <updated>2020-05-07T11:41:04.250Z</updated>
  <id>https://haledeng.com/</id>
  
  <author>
    <name>Hale</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuex3源码学习笔记之Vuex的Map语法糖</title>
    <link href="https://haledeng.com/blog/20191025-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84Map%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>https://haledeng.com/blog/20191025-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84Map%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2019-10-25T12:00:00.000Z</published>
    <updated>2020-05-07T11:41:04.250Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vuex 安装在 Vue 的过程中，会把用户定义的<code>store</code>实例赋值给 Vue 实例对象的<code>$store</code>中，所以我们在 Vue 组件中的任意地方使用<code>this.$store</code>调用<code>store</code>的值。但是这样使用可读性并不是很好，这样不好查找在组件的哪些地方，调用了哪些<code>store</code>上的属性和方法。</p><p>一般我们都会使用<code>MapXxx</code>语法糖来引入<code>store</code>的属性，这样很好的查找在哪里使用了<code>store</code>的哪些数据，可读性也会更强，也更方便管理。</p><a id="more"></a><h2 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a><code>mapState</code></h2><p>先看下<code>mapState</code>函数的代码，在<code>helpers.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = normalizeNamespace(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在分析<code>mapState</code>代码时，需要先搞清除<code>normalizeNamespace</code>和<code>normalizeMap</code>这个两个函数的作用，不然会一脸懵逼。</p><h3 id="normalizeNamespace规范化参数"><a href="#normalizeNamespace规范化参数" class="headerlink" title="normalizeNamespace规范化参数"></a><code>normalizeNamespace</code>规范化参数</h3><p>先看<code>normalizeNamespace</code>函数的代码，这个函数的作用是规范用户传入的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ! 命名空间不为字符串。</span></span><br><span class="line">    <span class="comment">// ! 比如，传入 root 的值时，没有模块名，是直接传 &#123; a: mutationName &#125; 或者 [ mutationName ]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      map = namespace <span class="comment">// ! 把命名空间设置为 map</span></span><br><span class="line">      namespace = <span class="string">''</span> <span class="comment">// ! 命名空间为空</span></span><br><span class="line">      <span class="comment">// ! 命名空间没有以 / 结尾时，拼接 / =&gt; moduleName = moduleName/</span></span><br><span class="line">      <span class="comment">// ! 模块名和 type 之间需要使用 / 隔开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">      namespace += <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的也是一个函数，而且这个函数和我们传入的<code>fn</code>参数具有相同的参数<code>namespace</code>和<code>map</code>，这样就可以很好的约束<code>fn</code>的参数。</p><p>首先判断第一个参数<code>namespace</code>是不是字符串，如果不是字符串，那么传入的值就是一个对象或者数组。这时参数<code>namespace</code>就不再是命名空间了，而是把它当成第二个参数<code>map</code>，而第一个参数<code>namespace</code>的值就是空字符串。</p><p>如果第一个参数<code>namespace</code>的值是字符串类型，那么它就是命名空间的模块名，这时候判断模块名是不是以<code>/</code>符号结尾，如果不是的话，需要在模块名后面添加<code>/</code>符号，这样做主要是为了在后面更好的拼接<code>type</code>值。</p><p>最后再次调用<code>fn</code>函数，调用时把处理好的两个参数<code>namespace</code>和<code>map</code>传入进去。</p><p>使用<code>normalizeNamespace</code>函数可以很好的规范<code>namespace</code>和<code>map</code>的值。</p><h3 id="normalizeMap规范化map"><a href="#normalizeMap规范化map" class="headerlink" title="normalizeMap规范化map"></a><code>normalizeMap</code>规范化<code>map</code></h3><p>接下来看下<code>normalizeMap</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normalize the map</span></span><br><span class="line"><span class="comment"> * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array|Object&#125;</span> <span class="variable">map</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> * ! 规范化 Map 👆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;)) <span class="comment">// ! 不修改 key 的名字</span></span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;)) <span class="comment">// ! 映射，修改 key的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是规范传入<code>map</code>参数的，官方注释已经解释的非常清除了。它会把数组类型或者对象类型的<code>map</code>转统一换成一个<code>{key, value}</code>结构的对象组成的数组。</p><p>比如我们使用<code>mapState</code>时，一般是这样使用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">'value1'</span>, <span class="string">'value2'</span>]),</span><br><span class="line">  ...mapState(&#123;<span class="attr">val3</span>: <span class="string">'value3'</span>, <span class="attr">val4</span>: <span class="string">'val4'</span>&#125;),</span><br><span class="line">  ...mapState(<span class="string">'moduleA'</span>, [<span class="string">'value1'</span>, <span class="string">'value2'</span>]),</span><br><span class="line">  ...mapState(<span class="string">'moduleB'</span>, &#123;<span class="attr">val3</span>: <span class="string">'value3'</span>, <span class="attr">val4</span>: <span class="string">'value4'</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规范<code>map</code>后就变成下面这样子了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&#123; <span class="attr">key</span>:<span class="string">'value1'</span>，val:<span class="string">'value1'</span>&#125;, &#123; <span class="attr">key</span>:<span class="string">'value2'</span>，val:<span class="string">'value2'</span> &#125;]),</span><br><span class="line">  ...mapState([&#123; <span class="attr">key</span>: val3: val: <span class="string">'value3'</span> &#125;, &#123; <span class="attr">key</span>: val4: val: <span class="string">'val4'</span> &#125;]),</span><br><span class="line">  ...mapState(<span class="string">'moduleA/'</span>, [&#123; <span class="attr">key</span>:<span class="string">'value1'</span>，val:<span class="string">'value1'</span>&#125;, &#123; <span class="attr">key</span>:<span class="string">'value2'</span>，val:<span class="string">'value2'</span> &#125;]),</span><br><span class="line">  ...mapState(<span class="string">'moduleB/'</span>, [&#123; <span class="attr">key</span>: val3: val: <span class="string">'value3'</span> &#125;, &#123; <span class="attr">key</span>: val4: val: <span class="string">'val4'</span> &#125;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以再看<code>mapState</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = normalizeNamespace(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// ! states： [1, 2, 3] =&gt; [&#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125;]</span></span><br><span class="line">  <span class="comment">// ! states： &#123;a:1, b:2, c:3&#125; =&gt; [&#123; key: a, val: 1 &#125;, &#123; key: b, val: 2 &#125;, &#123; key: c, val: 3 &#125;]</span></span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ! 获取 root 上的值</span></span><br><span class="line">      <span class="keyword">let</span> state = <span class="keyword">this</span>.$store.state</span><br><span class="line">      <span class="keyword">let</span> getters = <span class="keyword">this</span>.$store.getters</span><br><span class="line">      <span class="comment">// ! 如果设置了命名空间，即 mapXXX(namespace, ['name1', 'name2'])</span></span><br><span class="line">      <span class="comment">// ! 获取命名空间模块的值，即 store.state.namespace.name1</span></span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapState'</span>, namespace) <span class="comment">// ! 通过命名空间获取对应模块</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="built_in">module</span>.context.state <span class="comment">// ! 在模块中获取值</span></span><br><span class="line">        getters = <span class="built_in">module</span>.context.getters</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span> <span class="comment">// ! 判断是否是函数</span></span><br><span class="line">        ? val.call(<span class="keyword">this</span>, state, getters) <span class="comment">// ! val(state, getters)</span></span><br><span class="line">        : state[val] <span class="comment">// ! 返回 state 中对应的值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先声明了变量<code>res</code>，它的初始值是空对象，最后会返回这个值。</p><p>然后遍历<code>states</code>，就是上面规范后的<code>map</code>的值。然后在<code>res</code>对象中生成一对对<code>{key: mappedState}</code>键值对结构的数据。</p><p>下面主要看下<code>mappedState</code>函数的代码。</p><p>首先声明变量<code>state</code>存储 root 上的 <code>state</code>，声明变量<code>getters</code>存储 root 上的 <code>gettters</code>，如果有命名空间的模块后，会获通过命名空间的模块名获取到这个模块，然后变量<code>state</code>和<code>getters</code>会变成模块上下文中的<code>state</code>和<code>getters</code>。</p><p>再判断<code>val</code> 的值是否是函数，有时候会通过调用函数生成数据。如果是函数的话，会使用<code>call</code>方法来调用，<code>this</code>指向组件自身，然后把<code>state</code>和<code>getters</code>作为参数传入，如果不是函数，一般就是字符串，会返回<code>state</code>中对应<code>val</code>的值。</p><p>我们一般使用时传入字符串类型的值多一点，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapState(<span class="string">'moduleA'</span>, [<span class="string">'value'</span>])</span><br></pre></td></tr></table></figure><p>这时会返回<code>state[val]</code>，然后重新查看在模块上下文中是怎么修改<code>state</code>的值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path) // ! 通过路径获取嵌套的 state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说会使用<code>getNestedState</code>方法，通过路径<code>path</code>获取对应的<code>state</code>的值。而这里有命名空间模块，那么<code>path</code>的值就是<code>[&#39;moduleA&#39;，&#39;value&#39;]</code>，这样就可以获取到模块中<code>value</code>的值。</p><h2 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a><code>mapMutations</code></h2><p>下面看下<code>mapMutations</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = normalizeNamespace(<span class="function">(<span class="params">namespace, mutations</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(mutations).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedMutation</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Get the commit method from store</span></span><br><span class="line">      <span class="keyword">let</span> commit = <span class="keyword">this</span>.$store.commit <span class="comment">// ! 根的 commit</span></span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="comment">// ! 获取模块</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(</span><br><span class="line">          <span class="keyword">this</span>.$store,</span><br><span class="line">          <span class="string">'mapMutations'</span>,</span><br><span class="line">          namespace</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        commit = <span class="built_in">module</span>.context.commit <span class="comment">// ! 模块的 commit</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">        ? <span class="comment">// ! 调用这个函数 val(commit, args)，函数传入 commit，在函数体中可以使用 commit 来提交其它 mutation</span></span><br><span class="line">          val.apply(<span class="keyword">this</span>, [commit].concat(args))</span><br><span class="line">        : commit.apply(<span class="keyword">this</span>.$store, [val].concat(args)) <span class="comment">// ! string 形式 --&gt; this.$store.commit(val, ...args)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>逻辑和<code>mapState</code>大同小异，有命名空间模块的时候，获取到的是模块上下文中的<code>commit</code>方法。</p><p>然后判断<code>val</code>是否为函数，如何是的话，会调用这个函数，并且传入<code>commit</code>和参数<code>args</code>。这里为什么要传入<code>commit</code>，因为在函数体中可以使用<code>commit</code>来提交其它的<code>mutation</code>函数。如果<code>val</code>不是函数，那应该是字符串，这时会调用<code>commit</code>函数，<code>this</code>指向的<code>this.$store</code>，然后传入<code>val</code>和参数<code>args</code>，这就相当于是下面这样调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(val, ...args)</span><br></pre></td></tr></table></figure><p>我们发现<code>mapMutations</code>并不是简单的映射<code>mutation</code>的函数名，而是映射一个包装函数，这个函数里面使用<code>commit</code>来提交<code>mutaion</code>函数，用户在组件中使用这个函数就相当于提交<code>mutation</code>函数，而不需要在组件中再次显示使用<code>commit</code>来提交，这样设计是非常人性化的。</p><h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a><code>mapGetters</code></h2><p>下面看下<code>mapGetters</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = normalizeNamespace(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(getters).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// The namespace has been mutated by normalizeNamespace</span></span><br><span class="line">    val = namespace + val <span class="comment">// ! moduleName/getterName</span></span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        namespace &amp;&amp;</span><br><span class="line">        !getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapGetters'</span>, namespace)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        !(val <span class="keyword">in</span> <span class="keyword">this</span>.$store.getters)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown getter: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[val] <span class="comment">// ! 根据拼接后的 val 从实例属性 getters 获取对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mapGetters</code>的实现和<code>mapState</code>有一些不同，主要是<code>Store</code>中<code>getters</code>属性和<code>state</code>属性的结构不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">0</span> <span class="comment">// root state</span></span><br><span class="line">  moduleA: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  moduleB: &#123;</span><br><span class="line">    count: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line">getters: &#123;</span><br><span class="line">  getterFn()&#123;&#125;, <span class="comment">// root getters</span></span><br><span class="line">  <span class="string">'modulesA/getterFn'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesA/getterFn2'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesB/getterFn'</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getters</code>采用字符串拼接的方式，使得<code>val</code>的值为<code>moduleName/getterName</code>，然后在<code>store.getters</code>中直接通过 key 获取值。</p><h2 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a><code>mapActions</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = normalizeNamespace(<span class="function">(<span class="params">namespace, actions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(actions).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedAction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// get dispatch function from store</span></span><br><span class="line">      <span class="keyword">let</span> dispatch = <span class="keyword">this</span>.$store.dispatch</span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(</span><br><span class="line">          <span class="keyword">this</span>.$store,</span><br><span class="line">          <span class="string">'mapActions'</span>,</span><br><span class="line">          namespace</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch = <span class="built_in">module</span>.context.dispatch</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">        ? val.apply(<span class="keyword">this</span>, [dispatch].concat(args))</span><br><span class="line">        : dispatch.apply(<span class="keyword">this</span>.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mapActions</code>的逻辑和<code>mapMutations</code>完全一样，这样就不多赘述了。</p><h2 id="createNamespacedHelpers"><a href="#createNamespacedHelpers" class="headerlink" title="createNamespacedHelpers"></a><code>createNamespacedHelpers</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">namespace</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createNamespacedHelpers = <span class="function"><span class="params">namespace</span> =&gt;</span> (&#123;</span><br><span class="line">  mapState: mapState.bind(<span class="literal">null</span>, namespace),</span><br><span class="line">  mapGetters: mapGetters.bind(<span class="literal">null</span>, namespace),</span><br><span class="line">  mapMutations: mapMutations.bind(<span class="literal">null</span>, namespace),</span><br><span class="line">  mapActions: mapActions.bind(<span class="literal">null</span>, namespace)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vuex 还暴露出一个<code>createNamespacedHelpers</code>函数，用来绑定命名空间模块<code>namespace</code>的值，这样后面使用时所有的<code>map</code>都是这个模块下面的值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 文档</a></p></li><li><p><a href="https://github.com/haledc/vuex/tree/learn-vuex" target="_blank" rel="noopener">Vuex 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Vuex 安装在 Vue 的过程中，会把用户定义的&lt;code&gt;store&lt;/code&gt;实例赋值给 Vue 实例对象的&lt;code&gt;$store&lt;/code&gt;中，所以我们在 Vue 组件中的任意地方使用&lt;code&gt;this.$store&lt;/code&gt;调用&lt;code&gt;store&lt;/code&gt;的值。但是这样使用可读性并不是很好，这样不好查找在组件的哪些地方，调用了哪些&lt;code&gt;store&lt;/code&gt;上的属性和方法。&lt;/p&gt;
&lt;p&gt;一般我们都会使用&lt;code&gt;MapXxx&lt;/code&gt;语法糖来引入&lt;code&gt;store&lt;/code&gt;的属性，这样很好的查找在哪里使用了&lt;code&gt;store&lt;/code&gt;的哪些数据，可读性也会更强，也更方便管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vuex" scheme="https://haledeng.com/categories/Vuex/"/>
    
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Vuex" scheme="https://haledeng.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex3源码学习笔记之Vuex的数据操作</title>
    <link href="https://haledeng.com/blog/20191018-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>https://haledeng.com/blog/20191018-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</id>
    <published>2019-10-18T12:00:00.000Z</published>
    <updated>2020-05-07T08:46:22.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据存储和读取"><a href="#数据存储和读取" class="headerlink" title="数据存储和读取"></a>数据存储和读取</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code>是在模块安装<code>installModule</code>函数中设置的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set state</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>)) <span class="comment">// ! 获取父级的 state</span></span><br><span class="line">  <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>] <span class="comment">// ! 获取模块名</span></span><br><span class="line">  store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.set(parentState, moduleName, <span class="built_in">module</span>.state) <span class="comment">// ! 设置子模块，建立父子关系，并且为响应性数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>getNestedState</code>方法获取父级模块，然后把所有模块下面的<code>state</code>数据都拷贝到 root 的<code>state</code>中。</p><a id="more"></a><p>这样用户可以直接通过<code>store.state</code>获取<code>store</code>的所有数据，但是不能直接去修改数这些据。如果修改的话，在开发环境中会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取 state，访问的是 Vue 的 data 里面的属性，触发响应式 @API</span></span><br><span class="line"><span class="keyword">get</span> state() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 设置 state，开发环境会报错，不能直接设置，必须使用 replaceState 替换</span></span><br><span class="line"><span class="keyword">set</span> state(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assert(<span class="literal">false</span>, <span class="string">`use store.replaceState() to explicit replace store state.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为把<code>state</code>的数据放入到 Vue 的<code>data</code>属性下面的<code>$$state</code>中，<code>state</code>数据变成响应式的数据。</p><p>另外，其实可以通过 API<code>replaceState</code>来修改数据，即使用<code>store.replaceState(state)</code>方法替换<code>state</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 替换 state 的数据，这里也需要显示提交 commit 进行数据修改</span></span><br><span class="line">replaceState(state) &#123;</span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._vm._data.$$state = state</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p><code>store.getters</code>属性是在初始化<code>_vm</code>的函数<code>resetStoreVM</code>中才开始设置的，并且通过<code>computed</code>对象，把它的值变成了 Vue 实例的计算属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">store.getters = &#123;&#125; <span class="comment">// ! 创建 getters 属性</span></span><br><span class="line"><span class="keyword">const</span> wrappedGetters = store._wrappedGetters <span class="comment">// ! 获取 wrappedGetters 对象</span></span><br><span class="line"><span class="keyword">const</span> computed = &#123;&#125; <span class="comment">// ! 设置计算属性对象</span></span><br><span class="line"><span class="comment">// ! 遍历 wrappedGetters</span></span><br><span class="line">forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">  <span class="comment">// using partial to return function with only arguments preserved in closure enviroment</span></span><br><span class="line">  <span class="comment">// ! 把 wrappedGetter 函数的返回值赋值到 VM 的 computed 中</span></span><br><span class="line">  computed[key] = partial(fn, store) <span class="comment">// ! fn(store) -&gt; wrappedGetter(store)</span></span><br><span class="line">  <span class="comment">// ! 定义 store.getters 的属性</span></span><br><span class="line">  <span class="comment">// ! store.getters.xxx -&gt; store._vm[xxx] -&gt; store._vm.computed[xxx]</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">    enumerable: true // for local getters</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state <span class="comment">// !  store.state -&gt; store._vm.data.$$state</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed <span class="comment">// ! store._vm.computed[xxx] -&gt; store._vm[xxx]</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>store.getters</code>设置为 Vue 实例中的计算属性，但是它比计算属性更加严格。因为<code>getters</code> 只能读取，而不能操作，而 Vue 的计算属性是可以设置<code>setter</code>的。</p><p><code>getters</code>变成了计算属性，也继承了计算属性的特性，它依赖于<code>state</code>数据，只有在<code>state</code>数据变化时，它的值才会改变。</p><h2 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h2><p>在 Vuex 中修改<code>state</code>时，必须以显示的提交<code>commit</code>的形式来操作，不能直接去修改，如果直接去修改，设置了<code>strict = true</code>后在开发环境中会报错。</p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>下面看下<code>Store</code>中<code>commit</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! commit 方法 @API</span></span><br><span class="line">commit(_type, _payload, _options) &#123;</span><br><span class="line">  <span class="comment">// check object-style commit</span></span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload, options &#125; = unifyObjectStyle(</span><br><span class="line">    _type,</span><br><span class="line">    _payload,</span><br><span class="line">    _options</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type] <span class="comment">// ! 获取 type 的 mutation 函数数组</span></span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 使用 commit 执行 mutation 时在严格模式下不会报错</span></span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      handler(payload) <span class="comment">// ! 执行 commit 的所有函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="keyword">this</span>.state)) <span class="comment">// ! 执行 mutation 后，执行所有订阅函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; options &amp;&amp; options.silent) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(</span><br><span class="line">      <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class="line">      <span class="string">'Use the filter functionality in the vue-devtools'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会使用<code>unifyObjectStyle</code>函数规范化参数，然后获取规范化的<code>type</code>和<code>payload</code>组成一个<code>mutation</code>对象，再通过<code>type</code>获取对应的函数组，然后通过<code>_withCommit</code>执行函数组的所有函数，注意执行时需要把<code>payload</code>传入。</p><p>执行完<code>type</code>的函数后，再执行所有的<code>mutation</code>订阅函数。</p><p>先看下<code>unifyObjectStyle</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 规范化 commit 和 dispatch 函数的参数</span></span><br><span class="line"><span class="comment">// ! e.g. commit(type: string, payload?: any, options?: Object)</span></span><br><span class="line"><span class="comment">// !      commit(&#123; type: string, payload?: any &#125;, options? Object)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unifyObjectStyle</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = type</span><br><span class="line">    type = type.type</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assert(</span><br><span class="line">      <span class="keyword">typeof</span> type === <span class="string">'string'</span>, <span class="comment">// ! type 必须是 string 类型</span></span><br><span class="line">      <span class="string">`expects string as the type, but found <span class="subst">$&#123;<span class="keyword">typeof</span> type&#125;</span>.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; type, payload, options &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>commit</code>的时候有两种提交方法，一种是直接提交一个由<code>type</code>和<code>payload</code>的键值对组成的<code>mutaion</code>对象，另外一种是把它们分开来传入，<code>unifyObjectStyle</code>函数可以确保能获取到<code>type</code>和<code>payload</code>的准确值。</p><p>再看<code>_withCommit</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 包装 mutation 函数，设置 _committing 状态</span></span><br><span class="line"><span class="comment">// ! 正常通过 commit 修改数据前 _committing 为 true，防止用户随意更改 vuex 的数据</span></span><br><span class="line">_withCommit(fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing <span class="comment">// ! 缓存原来的状态</span></span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span> <span class="comment">// ! 执行前设置为 true，此时通过 commit 修改值在严格模式下不会报错</span></span><br><span class="line">  fn() <span class="comment">// ! 执行函数</span></span><br><span class="line">  <span class="keyword">this</span>._committing = committing <span class="comment">// ! 恢复原来的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把<code>mutation</code>函数进行了一层包装，在执行函数前会把<code>_committing</code>设置为<code>true</code>，这样后面通过<code>store._vm</code>实例中的侦听器<code>$watch</code>检测<code>state</code>变化时，会验证它的值。当它的值为<code>true</code>时，说明修改<code>state</code>的值是通过提交<code>commit</code>修改的，这时设置<code>strict=true</code>后就不会报错了。</p><h3 id="diaptch"><a href="#diaptch" class="headerlink" title="diaptch"></a>diaptch</h3><p>下面看下<code>Store</code>中<code>diaptch</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! dispatch 方法 @API</span></span><br><span class="line">  dispatch(_type, _payload) &#123;</span><br><span class="line">    <span class="comment">// check object-style dispatch</span></span><br><span class="line">    <span class="keyword">const</span> &#123; type, payload &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> action = &#123; type, payload &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown action type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! action 执行前，先执行 action 的所有订阅器的 before 函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._actionSubscribers</span><br><span class="line">        .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before)</span><br><span class="line">        .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before(action, <span class="keyword">this</span>.state))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in before action subscribers: `</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result =</span><br><span class="line">      entry.length &gt; <span class="number">1</span></span><br><span class="line">        ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload))) <span class="comment">// ! 并行执行 action 的所有异步操作</span></span><br><span class="line">        : entry[<span class="number">0</span>](payload) <span class="comment">// ! 只有一个 action 则同步执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! action 执行后，执行 action 的所有订阅器的 after 函数</span></span><br><span class="line">    <span class="keyword">return</span> result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="keyword">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>它的逻辑和<code>commit</code>相似，都是先规范化参数，然后再执行函数，也会执行订阅器。</p><p>但是这里有<strong>两点不同</strong>，其中一点是执行<code>action</code>函数的方式。我们知道通过调用<code>commit</code>方法执行<code>mutation</code>函数时，是同步执行的。但是通过<code>dispatch</code>执行<code>action</code>函数时，如果有多个函数，会进行异步执行，只有一个函数时才会使用同步执行。</p><p>另一点是<code>actions</code>的订阅器也和<code>mutaion</code>的订阅器不一样，它可以设置两个执行函数，一个是<code>before</code>，在<code>action</code>函数执行前执行的；另外一个<code>after</code>，在<code>action</code>函数执行后执行的。</p><p>另外，<code>action</code>函数是不能直接修改数据的，它还是需要通过显示的提交<code>commit</code>来执行<code>mutation</code>函数，通过<code>mutation</code>函数来修改数据。</p><h3 id="动态注册模块"><a href="#动态注册模块" class="headerlink" title="动态注册模块"></a>动态注册模块</h3><p><code>Vuex</code>中模块的注册是在初始化<code>Store</code>实例的时候完成的，如果我们需要在实例创建之后再创建一个模块，就可以使用<code>registerModule</code>方法，动态注册一个模块。</p><p>看下动态注册模块函数<code>registerModule</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 动态注册模块，在模块初始化后手动注册模块 @API</span></span><br><span class="line">registerModule(path, rawModule, options = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span>) path = [path] <span class="comment">// ! 字符串包装成数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assert(<span class="built_in">Array</span>.isArray(path), <span class="string">`module path must be a string or an Array.`</span>)</span><br><span class="line">    assert(</span><br><span class="line">      path.length &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">'cannot register the root module by using registerModule.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._modules.register(path, rawModule) <span class="comment">// ! 注册模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 安装模块</span></span><br><span class="line">  installModule(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    <span class="keyword">this</span>.state,</span><br><span class="line">    path,</span><br><span class="line">    <span class="keyword">this</span>._modules.get(path),</span><br><span class="line">    options.preserveState</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// reset store to update getters...</span></span><br><span class="line">  <span class="comment">// ! 初始化 store._vm</span></span><br><span class="line">  resetStoreVM(<span class="keyword">this</span>, <span class="keyword">this</span>.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先处理下<code>path</code>参数，一般情况下都是输入字符串类型的模块名，这里需要把它转换成数组类型的<code>path</code>。</p><p>动态注册模块和初始化时注册模块逻辑<strong>唯一不同</strong>的是，它不需要重新去创建根模块。</p><p>在初始化<code>Store</code>实例的时候，是需要先收集所有的模块，创建一个<code>ModuleCollection</code>实例对象的，把这个对象赋值给<code>Store</code>类的 <code>_modules</code>属性，实际上就是创建了一个<code>{root: Module instance}</code>结构的根模块对象。</p><p>因为根模块是所有模块的父模块，动态注册一个子模块时，就不需要再创建重新根模块。而是只注册这个字模块，把子模块添加到根模块下面。然后需要安装这个子模块，把模块的原始数据都添加到<code>store</code>的实例属性中，最后初始化<code>store._vm</code>，更新<code>getters</code>属性。上面的按照模块和初始化<code>store._vm</code>的方法已经初始化<code>Store</code>实例对象中讲解过了，这里就不再赘述了。</p><p><code>store</code>实例中既然有动态注册模块的方法，那么也会有动态卸载模块的方法。</p><h3 id="动态卸载模块"><a href="#动态卸载模块" class="headerlink" title="动态卸载模块"></a>动态卸载模块</h3><p>查看<code>unregisterModule</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 动态卸载模块 @API</span></span><br><span class="line">unregisterModule(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span>) path = [path]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assert(<span class="built_in">Array</span>.isArray(path), <span class="string">`module path must be a string or an Array.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._modules.unregister(path) <span class="comment">// ! 注销模块</span></span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(<span class="keyword">this</span>.state, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">    Vue.delete(parentState, path[path.length - <span class="number">1</span>]) <span class="comment">// ! 删除 state 在该路径下的引用</span></span><br><span class="line">  &#125;)</span><br><span class="line">  resetStore(<span class="keyword">this</span>) <span class="comment">// ! 重置 store</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还是处理下<code>path</code>参数，然后使用<code>ModuleCollection</code>类的 <code>unregister</code>方法，把该模块从根模块中删除掉，然后把它的<code>state</code>数据也从根的<code>state</code>中删除，这里删除<code>state</code>使用了<code>_withCommit</code>的方法，在<code>strict=true</code>时不会报错，最后重置下<code>store</code>。</p><p>先看下删除模块的方法<code>unregister</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 模块注销的方法</span></span><br><span class="line">unregister(path) &#123;</span><br><span class="line">  <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">  <span class="keyword">const</span> key = path[path.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> (!parent.getChild(key).runtime) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  parent.removeChild(key) <span class="comment">// ! 移除子模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到需要卸载的模块名，然后使用了<code>Module</code>的<code>removeChild</code>方法，移除这个模块。</p><p>再看下<code>resetStore</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 重置 store：先清空，再重新安装模块和初始化 VM</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStore</span>(<span class="params">store, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 重新设置值为空对象</span></span><br><span class="line">  store._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  store._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  store._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  store._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> state = store.state</span><br><span class="line">  <span class="comment">// init all modules</span></span><br><span class="line">  installModule(store, state, [], store._modules.root, <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// reset vm</span></span><br><span class="line">  resetStoreVM(store, state, hot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先重置了一些在模块安装时设置的属性，把它们的值清空成一个空对象，然后重新获取 root 的 <code>state</code>的值，再重新安装其他未删除的模块和初始化<code>store._vm</code>属性。</p><p>这样，Vuex 的数据操作就基本讲解完成了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 文档</a></p></li><li><p><a href="https://github.com/haledc/vuex/tree/learn-vuex" target="_blank" rel="noopener">Vuex 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据存储和读取&quot;&gt;&lt;a href=&quot;#数据存储和读取&quot; class=&quot;headerlink&quot; title=&quot;数据存储和读取&quot;&gt;&lt;/a&gt;数据存储和读取&lt;/h2&gt;&lt;h3 id=&quot;state&quot;&gt;&lt;a href=&quot;#state&quot; class=&quot;headerlink&quot; title=&quot;state&quot;&gt;&lt;/a&gt;state&lt;/h3&gt;&lt;p&gt;&lt;code&gt;state&lt;/code&gt;是在模块安装&lt;code&gt;installModule&lt;/code&gt;函数中设置的。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// set state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isRoot &amp;amp;&amp;amp; !hot) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; parentState = getNestedState(rootState, path.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// ! 获取父级的 state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; moduleName = path[path.length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;// ! 获取模块名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  store._withCommit(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Vue.set(parentState, moduleName, &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.state) &lt;span class=&quot;comment&quot;&gt;// ! 设置子模块，建立父子关系，并且为响应性数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通过&lt;code&gt;getNestedState&lt;/code&gt;方法获取父级模块，然后把所有模块下面的&lt;code&gt;state&lt;/code&gt;数据都拷贝到 root 的&lt;code&gt;state&lt;/code&gt;中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vuex" scheme="https://haledeng.com/categories/Vuex/"/>
    
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Vuex" scheme="https://haledeng.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex3源码学习笔记之Vuex的初始化</title>
    <link href="https://haledeng.com/blog/20191011-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://haledeng.com/blog/20191011-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2019-10-11T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:43.431Z</updated>
    
    <content type="html"><![CDATA[<p><code>Store.js</code>文件中的代码中，会导出一个<code>Store</code>类，我们在使用 Vuex 的时候都是从先创建一个<code>Store</code>实例对象开始的。</p><p>下面看下<code>Store</code>实例对象的初始化过程。</p><h2 id="Store-的初始化"><a href="#Store-的初始化" class="headerlink" title="Store 的初始化"></a>Store 的初始化</h2><p>先看下<code>Store</code>类的初始化函数<code>constructor</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">  <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">  <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">  <span class="comment">// ! 使用 Vuex 为引入外链时，会自动安装插件</span></span><br><span class="line">  <span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">    install(<span class="built_in">window</span>.Vue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们使用外链来引入 Vuex 时，会自动安装 Vuex，不需要再手动调用<code>use</code>方法来安装。</p><a id="more"></a><p>在我们使用<code>script</code>标签使用 Vuex 的时候，此时 Vue 库的代码必须先引入，然后再引入 Vuex 库的代码，这样才能使用 Vuex。在用外链引入 Vue 和 Vue 的代码时， Vue 的构造函数会被赋值给<code>window.Vue</code>且浏览器对象<code>window</code>也是有定义的，<code>store.js</code>文件中的全局变量<code>Vue</code>也还没有赋值，此时才会安装 Vuex。</p><p>示例代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.1/vuex.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span></span><br><span class="line">      state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        addOne(state) &#123;</span><br><span class="line">          state.count += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: `<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"$store.commit('addOne')"</span>&gt;</span>count: </span><span class="template-variable">&#123;&#123;$store.state.count&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">      store</span><br><span class="line"><span class="actionscript">    &#125;).$mount(<span class="string">'#app'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码，是在开发环境中，执行三个断言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  assert(</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>,</span><br><span class="line">    <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">  )</span><br><span class="line">  assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`store must be called with the new operator.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下断言函数<code>assert</code>的代码，在<code>util.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 断言：当条件没达成的时候，抛出错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`[vuex] <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，没有满足断言条件的话，就会抛出错误。</p><p>下面分析下三个断言</p><ul><li>Vue 必须有值（存在），因为 Vuex 只有依赖 Vue 才能使用。</li><li>必须是支持 Promise 的环境，因为 Vuex 中的 actions 使用了 Promise 语法来处理异步。</li><li>传入到 Vue 的选项中的<code>store</code>实例对象必须是通过操作符 new 出来的<code>Store</code>实例。</li></ul><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取选项中的插件（默认是空数组）和严格模式定义（默认是 false）</span></span><br><span class="line"><span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line"><span class="comment">// store internal state</span></span><br><span class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span> <span class="comment">// ! 判断是否使用 commit 修改数据</span></span><br><span class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 actions</span></span><br><span class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">// ! 存储 action 的所有订阅函数</span></span><br><span class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 mutations</span></span><br><span class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 wrapper getters</span></span><br><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// ! ① 模块收集 =&gt; &#123; root: rootModule &#125;</span></span><br><span class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 模块命名映射表 &#123; 'moduleName/': module&#125;</span></span><br><span class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">// ! 存储 mutation 的所有订阅函数</span></span><br><span class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">// ! 创建一个 Vue 实例，用来使用实例属性 $watch 实现 watch API</span></span><br><span class="line"><span class="keyword">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 模块的 getters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>从<code>options</code>获取插件和<code>strict</code>模式。</p><p>然后定义了一堆的属性，属性解析请看上面的注释。</p><p>这里主要看下<code>this._modules</code>属性，它是<code>ModuleCollection</code>类的实例对象，通过创建这个实例对象，进行模块的收集。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// ! ① 模块收集 =&gt; &#123; root: rootModule &#125;</span></span><br></pre></td></tr></table></figure><p>这里是<code>Store</code>实例初始化的第一个重点阶段：模块收集。</p><h2 id="模块收集"><a href="#模块收集" class="headerlink" title="模块收集"></a>模块收集</h2><h3 id="ModuleCollection模块收集类"><a href="#ModuleCollection模块收集类" class="headerlink" title="ModuleCollection模块收集类"></a><code>ModuleCollection</code>模块收集类</h3><p>查看<code>ModuleCollection</code>类的代码，在<code>module/module-collection.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 模块收集类，设置 root 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawRootModule) &#123;</span><br><span class="line">    <span class="comment">// register root module (Vuex.Store options)</span></span><br><span class="line">    <span class="keyword">this</span>.register([], rawRootModule, <span class="literal">false</span>) <span class="comment">// ! 初始化时注册模块</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的主要作用是收集模块，它会创建一个<code>{ root: Module instance}</code>实例对象。</p><p>看类的构造函数，在初始化时只调用<code>register</code>方法来注册模块。</p><p>查看<code>register</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">register(path, rawModule, runtime = <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// ! 开发模式下断言原始数据，判断输入的数据类型和格式是否有错</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assertRawModule(path, rawModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime) <span class="comment">// ! 创建一个模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! path 为空时</span></span><br><span class="line">  <span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = newModule <span class="comment">// ! 创建的模块为根模块，注意：this.root 是这里类唯一的属性值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>)) <span class="comment">// ! 根据路径获取到父模块（在数组里面它前面的元素）</span></span><br><span class="line">    parent.addChild(path[path.length - <span class="number">1</span>], newModule) <span class="comment">// ! 添加子模块，建立父子关系</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register nested modules</span></span><br><span class="line">  <span class="comment">// ! 用户自定义模块，注册嵌套模块</span></span><br><span class="line">  <span class="keyword">if</span> (rawModule.modules) &#123;</span><br><span class="line">    forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! 把 key 放入到 path 中，key === moduleName</span></span><br><span class="line">      <span class="keyword">this</span>.register(path.concat(key), rawChildModule, runtime)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在开发环境中会使用断言函数校验用户输入的原始选项数据的类型或者格式是否有错。</p><p>然后声明常量<code>newModule</code>，存储通过操作符 new 创建一个<code>Module</code>实例对象的。先不管生成的实例对象是怎么样子的，继续看下面的代码。</p><p>如果<code>path</code>数组的长度为 0 时，生成的模块被赋值给<code>this.root</code>，即生成根模块。注意：<code>root</code>属性是类<code>ModuleCollection</code> 实例对象的唯一一个的属性值。我们在初始化模块时，<code>path</code>是一个空数组，所有先不看 else 代码块的代码，后面再解析。</p><p>继续看下面的代码，如果我们的原始数据中设置了模块，会遍历这些模块，然后还是通过<code>register</code>方法注册这些模块。这里注册时，<code>path</code>就不是一个空数组了，而是合并了<code>key</code>，也就是模块名。这时，会进入上面的 else 代码块的逻辑，首先需要通过<code>get</code>方法根据传入<code>path</code>数组中的<code>key</code>之前的元素获取父级模块，然后使用<code>addChild</code>方法添加模块，添加的模块名就是之前传入到<code>path</code>数组的<code>key</code>，这样就建立好了父子关系。</p><p>这里可能有点难以理解，请看下面的示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line">modules: &#123;</span><br><span class="line">  moduleA: &#123;<span class="comment">/* */</span>&#125;,</span><br><span class="line">  moduleB: &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初步收集模块后的 _modules 属性</span></span><br><span class="line">_modules: &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    _children: &#123;</span><br><span class="line">      moduleA: &#123;<span class="comment">/* Module instance */</span>&#125;,</span><br><span class="line">      moduleB: &#123;<span class="comment">/* Module instance */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下它是怎么获取父级模块的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(path) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">  &#125;, <span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，模块对应的<code>path</code>数组中只有模块名一个元素，取它之前的元素构成一个新的<code>path</code>，此时<code>path</code>其实是一个空数组<code>[]</code>，这时获取到的父级模块就是根模块。所以会把<code>moduleA</code>和<code>moduleB</code>这两个模块添加到根模块的<code>_children</code>属性中。</p><h3 id="Module模块类"><a href="#Module模块类" class="headerlink" title="Module模块类"></a><code>Module</code>模块类</h3><p>模块的实例对象是通过<code>Module</code>生成的，它里面定义了一些操作模块的属性和方法。</p><p>查看<code>Module</code>类的代码，在<code>module/module.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawModule, runtime) &#123;</span><br><span class="line">    <span class="keyword">this</span>.runtime = runtime <span class="comment">// ! 存储 runtime 的值</span></span><br><span class="line">    <span class="comment">// Store some children item</span></span><br><span class="line">    <span class="keyword">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储子模块</span></span><br><span class="line">    <span class="comment">// Store the origin module object which passed by programmer</span></span><br><span class="line">    <span class="keyword">this</span>._rawModule = rawModule <span class="comment">// ! 存储原始模块数据</span></span><br><span class="line">    <span class="keyword">const</span> rawState = rawModule.state <span class="comment">// ! 获取根的 state 原始数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the origin module's state</span></span><br><span class="line">    <span class="keyword">this</span>.state = (<span class="keyword">typeof</span> rawState === <span class="string">'function'</span> ? rawState() : rawState) || &#123;&#125; <span class="comment">// ! 存储 state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的构造函数中，定义了一些属性，查看上面代码的注释。比如我们刚才用到的<code>_children</code>属性就是用来存储子模块的。</p><p>另外还定义了一些方法。比如我们刚才用到的添加子模块的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 增加子模块</span></span><br><span class="line">addChild(key, <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._children[key] = <span class="built_in">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把子模块添加到<code>_children</code>属性中，以键值对的形式存储。</p><p>到这里，模块的收集工作就完成了，其实就是通过用户输入的原始模块数据，创建一个根模块。这个根模块对应的<code>key</code>，就是<code>root</code>，即对象<code>{ root: root Module}</code>，然后把这个对象添加到<code>store</code>实例的<code>_modules</code>属性中。</p><p>下面继续看<code>Store</code>类的构造函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 绑定 this，指向 store 实例本身</span></span><br><span class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里绑定<code>commit</code>和<code>dispatch</code>方法的<code>this</code>指向，它们的<code>this</code>都指向<code>store</code>实例本身。</p><p>为什么要这么绑定呢？因为我们把<code>store</code>实例对象赋值给 Vue 的<code>$store</code>属性中，所以我们在实例组件中就可以像下面这样调用<code>commit</code>和<code>dispatch</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commti(<span class="string">'xxx'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>此时，如果不绑定<code>this</code>，<code>commit</code>和<code>diaptch</code>方法中的<code>this</code>指向的就是调用的它们的 Vue 实例组件，而不是<code>Store</code>实例对象。但是 Vue 实例组件中并没有这两个方法的，这样就会出错。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="comment">// ! 在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。</span></span><br><span class="line"><span class="keyword">this</span>.strict = strict</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state <span class="comment">// ! 获取根的 state</span></span><br></pre></td></tr></table></figure><p>设置严格模式和获取根的 state 数据。严格模式一般只在开发环境中启用，而不能再生成环境中启用，理由在后面会讲。</p><p>继续往下看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init root module.</span></span><br><span class="line"><span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line"><span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root) <span class="comment">// ! ② 安装 root 模块 ，模块初始化</span></span><br></pre></td></tr></table></figure><p>调用<code>installModule</code>函数安装模块。这里是<code>Store</code>实例初始化的第二个重点阶段：模块安装。</p><h2 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h2><p>安装模块，说白了就是初始化<code>store</code>实例的一些属性，在前面模块收集时只是初步处理了原始数据，这里会更进一步处理原始数据，把处理后的数据放到一开始定义的属性中，比如<code>_actions</code> 、<code>_mutations</code>等属性中。</p><p>查看<code>installModule</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length <span class="comment">// ! 判断是否是根模块</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path) <span class="comment">// ! 获取命名空间模块的名称 'moduleName/'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看函数体前面的代码，首先判断是否是根模块，当<code>path</code>是一个空数组时，传入的模块<code>module</code>就是根模块。</p><p>然后获取有命名空间模块的名称，是通过<code>ModuleCollection</code>实例对象的<code>getNamespace</code>方法获取的，看下这个方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取命名空间模块的名称</span></span><br><span class="line">getNamespace(path) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">this</span>.root <span class="comment">// ! 获取根模块</span></span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key) <span class="comment">// ! 获取子模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 子模块 key 设置了命名空间，获取 key，并且拼接 '/'</span></span><br><span class="line">    <span class="comment">// ! 第一轮循环：path = [ moduleName ]，namespace = ''，key = moduleName =&gt;  'moduleName/'</span></span><br><span class="line">    <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">  &#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>path</code>获取有命名空间的模块的名称。因为<code>Module</code>的实例对象中是通过<code>_children</code>属性存储子模块的，它的存储方式是键值对结构，其中的键名就是模块名，然后模块名在模块收集时，已经通过调用注册方法<code>register</code>把它放入到<code>path</code>数组中，所以可以通过不断的遍历，使用<code>getChild</code>方法获取子模块，然后在最后返回它的模块名。另外还需要在模块名后面拼接<code>/</code>符号，是为了在后面更好的拼接模块内的类型名。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register in namespace map</span></span><br><span class="line"><span class="comment">// ! 如果设置了命名空间，即 namespaced = true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    store._modulesNamespaceMap[namespace] &amp;&amp;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;namespace&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="string">'/'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  store._modulesNamespaceMap[namespace] = <span class="built_in">module</span> <span class="comment">// ! 赋值到命名映射表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>有了模块名和模块，就把它们赋值到<code>_modulesNamespaceMap</code>属性中，方面后面使用。在注册之前还需要判断<code>_modulesNamespaceMap</code>映射表中是否已经存储这个模块，如果存在，在开发环境中会报错，提示你模块重复，这时候需要检测下是否编写了相同的模块。</p><p>成功赋值后，<code>_modulesNamespaceMap</code>映射表属性的示例代码就会像下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  moduleA/: &#123;<span class="comment">/* Module instance */</span>&#125;,</span><br><span class="line">  moduleB/: &#123;<span class="comment">/* Module instance */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set state</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>)) <span class="comment">// ! 获取父级的 state</span></span><br><span class="line">  <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>] <span class="comment">// ! 获取模块名</span></span><br><span class="line">  store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.set(parentState, moduleName, <span class="built_in">module</span>.state) <span class="comment">// ! 设置子模块，建立父子关系，并且为响应性数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是设置<code>state</code>数据，把所有模块下面的<code>state</code>数据统一放入到 root 的<code>state</code>属性中。</p><p>这里通过<code>getNestedState</code>函数来获取模块下面的<code>state</code>，通过<code>path</code>数组来查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span>(<span class="params">state, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.length ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state) : state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如根的<code>state</code>数据和模块的<code>state</code>的结构之前是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把所有模块的<code>state</code>数据放到 root 的<code>state</code>中就变成下面这样子。后面还会把<code>state</code>数据放入到 Vue 组件的<code>data</code>属性下面，变成响应式数据，这里先买个关子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root state</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">  moduleA: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  moduleB: &#123;</span><br><span class="line">    count: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 构造了一个本地上下文环境（模块内部）</span></span><br><span class="line"><span class="comment">// ! local 中的 commit dispatch state getter 的效果会不一样</span></span><br><span class="line"><span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br></pre></td></tr></table></figure><p>这里使用<code>makeLocalContext</code>函数创建一个模块上下文环境（<code>module.context</code>属性），重写<code>local</code>下面的一些属性。</p><h3 id="makeLocalContext创建模块上下文"><a href="#makeLocalContext创建模块上下文" class="headerlink" title="makeLocalContext创建模块上下文"></a><code>makeLocalContext</code>创建模块上下文</h3><p>查看<code>makeLocalContext</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span>(<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 创建 local 属性</span></span><br><span class="line">  <span class="comment">// ! 重写有命名空间的模块里面的 dispatch commit 方法和 getters state 属性</span></span><br><span class="line">  <span class="keyword">const</span> local = &#123;</span><br><span class="line">    dispatch: noNamespace</span><br><span class="line">      ? store.dispatch <span class="comment">// ! 没有命名空间，直接使用根的 dispatch --&gt; dispatch(actionName, payload)</span></span><br><span class="line">      : <span class="comment">// ... 省略重写的方法</span></span><br><span class="line"></span><br><span class="line">    commit: noNamespace</span><br><span class="line">      ? store.commit</span><br><span class="line">      : <span class="comment">// ... 省略重写的方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and state object must be gotten lazily</span></span><br><span class="line">  <span class="comment">// because they will be changed by vm update</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="keyword">get</span>: noNamespace</span><br><span class="line">        ? () =&gt; store.getters</span><br><span class="line">        : () =&gt; makeLocalGetters(store, namespace) // ! 使用一个对象来代理模块里面的 getters</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path) // ! 通过路径获取嵌套的 state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明常量<code>noNamespace</code>表示是否存在命名空间的模块，它的值是<code>true</code>时表示没有，即<code>namespace</code>为空字符串。</p><p>然后定义了一个<code>local</code>常量，里面重写了在有命名空间中的模块里面的<code>dispatch</code>、<code>commit</code>、<code>getters</code>、<code>state</code>的逻辑，最后返回<code>local</code>这个常量。</p><p>先看下重写的<code>dispatch</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch: noNamespace</span><br><span class="line">  ? store.dispatch <span class="comment">// ! 没有命名空间模块，直接使用根的 dispatch --&gt; dispatch(actionName, payload)</span></span><br><span class="line">: <span class="comment">// ! 有命名空间，提交的类型 type 不一样</span></span><br><span class="line">  (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">    <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">    <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! options: &#123; root: true &#125; -&gt; 也不会拼接命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">      type = namespace + type <span class="comment">// ! 拼接 type =&gt; 'moduleName/actionName'</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        !store._actions[type]</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(</span><br><span class="line">          <span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ! 传入新的 type 为参数 --&gt; dispatch(moduleName/actionName, payload)</span></span><br><span class="line">   <span class="keyword">return</span> store.dispatch(type, payload)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>首先还是判断<code>noNamespace</code>的值，如果没有命名空间的模块，就直接调用<code>store.diaptch</code>，它的参数中的<code>type</code>不变，就是我们传入的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(actionName, payload) <span class="comment">// ! 这里的 actionName 是 root 下面的</span></span><br></pre></td></tr></table></figure><p>如果有命名空间的模块或者没有设置第三个选项参数<code>{root: true}</code>，会拼接<code>type</code>，使得<code>type</code>变成<code>moduleName/actionName</code>，也就是说在模块中提交<code>action</code>时，提交的<code>actionName</code>会变成<code>moduleName/actionName</code>，这样就和 root 中的<code>actionName</code>很好的区分开来，调用的时候就是调用<code>moduleName/actionName</code>函数，而不是<code>actionName</code>函数。</p><p>重写的<code>commit</code>方法和<code>dispatch</code>逻辑一样，这里就不多赘述。</p><p>下面看下重写<code>getters</code>和<code>state</code>代码，它们有点不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="keyword">get</span>: noNamespace</span><br><span class="line">      ? () =&gt; store.getters</span><br><span class="line">      : () =&gt; makeLocalGetters(store, namespace) // ! 使用一个对象来代理模块里面的 getters</span><br><span class="line">  &#125;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path) // ! 通过路径获取嵌套的 state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先看<code>getters</code>，如果没有命名空间模块，函数的返回值是<code>store.getters</code>，否则函数返回值是<code>_makeLocalGettersCache</code>属性中对应的值，它是一个代理对象，这个代理对象是通过<code>makeLocalGetters</code>函数生成的。</p><p>看下<code>makeLocalGetters</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalGetters</span>(<span class="params">store, namespace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 添加模块的 getters 到 _makeLocalGettersCache 中</span></span><br><span class="line">  <span class="keyword">if</span> (!store._makeLocalGettersCache[namespace]) &#123;</span><br><span class="line">    <span class="keyword">const</span> gettersProxy = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> splitPos = namespace.length <span class="comment">// ! 分割点：namespace 的长度</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(store.getters).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// skip if the target getter is not match this namespace</span></span><br><span class="line">      <span class="keyword">if</span> (type.slice(<span class="number">0</span>, splitPos) !== namespace) <span class="keyword">return</span> <span class="comment">// ! 命名空间和 type 的模块名不一致时直接返回，即没有匹配成功</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// extract local getter type</span></span><br><span class="line">      <span class="keyword">const</span> localType = type.slice(splitPos) <span class="comment">// ! 截取 type 名称：moduleName/getterName --&gt; getterName</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add a port to the getters proxy.</span></span><br><span class="line">      <span class="comment">// Define as getter property because</span></span><br><span class="line">      <span class="comment">// we do not want to evaluate the getters in this time.</span></span><br><span class="line">      <span class="comment">// ! 代理 gettersProxy，gettersProxy.localType === store.getters[type]</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; store.getters[type],</span><br><span class="line">        enumerable: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    store._makeLocalGettersCache[namespace] = gettersProxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return store._makeLocalGettersCache[namespace]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要判断<code>_makeLocalGettersCache</code>属性中是否有模块，如果没有需要把模块的<code>getters</code>添加进去。</p><p>声明常量<code>gettersProxy</code>为一个空对象，用来代理模块的<code>getters</code>，最后返回这个对象。</p><p>声明常量<code>splitPos</code>存储<code>namespace</code>的长度值。</p><p>然后遍历<code>store.getters</code>的<code>keys</code>，当命名空间的值和<code>type</code>的模块名不一样时直接返回，即没有匹配到相应的模块。</p><p>如果匹配成功，声明常量<code>localType</code>截取 type 的名称，即原来是<code>moduleName/getterName</code>的名称现在变成<code>getterName</code>。然后使用<code>Object.defineProperty</code>定义<code>gettersProxy</code>对象的<code>localType</code>属性，但是它的<code>getter</code>返回的确实<code>store.getters</code>中的<code>type</code>的值。</p><p>这里请注意下，在<code>store.getters</code>中的<code>type</code>键名是带模块名前缀的，而<code>localType</code>键名是不带模块名前缀的。</p><p>这里也有点绕，其实就是在模块里面访问<code>getter</code>属性是不需要带模块名前缀的，直接访问。但是我们在输出它的值时从<code>store.getters</code>属性中获取的，这里属性是带有模块名前缀的，不然输出的就不是模块的<code>getter</code>，而是 root 的<code>getter</code>。我们现在还不知道<code>store.getters</code>属性的结构，后面知道后就会比较清楚了。</p><p>最后看下<code>state</code>，它是直接通过<code>getNestedState</code>来获取<code>state</code>的值，不管是 root 的<code>state</code>值还是在模块的<code>state</code>值。因为在定义模块上下文之前，我们已经把所有模块的<code>state</code>已经被放在 root 的<code>state</code>中，所以通过<code>getNestedState</code>函数可以很好获取它们的值。</p><p>创建好上下文对象<code>local</code>之后，我们看下<code>installModule</code>剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历和注册模块，下同</span></span><br><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/mutationName'</span></span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.root ? key : namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/actionName'</span></span><br><span class="line">  <span class="keyword">const</span> handler = action.handler || action <span class="comment">// ! 获取 action 函数</span></span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/getterName'</span></span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 递归注册子模块</span></span><br><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot) <span class="comment">// ! path 连接 key(模块名)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历模块中的存储的原始数据，然后注册这些原始数据。这里分别注册了<code>mutation</code>、<code>action</code>、<code>getter</code>和子模块。</p><p>在<code>Module</code>类的构造函数中，我们知道原始的数据<code>rawModule</code>是存储在<code>_rawModule</code>属性中的。</p><p>先看下如何遍历<code>mutaions</code>的值，查看<code>forEachMutation</code>方法的代码，在<code>module/module.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历并处理 mutations</span></span><br><span class="line">forEachMutation(fn) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.mutations) &#123;</span><br><span class="line">    forEachValue(<span class="keyword">this</span>._rawModule.mutations, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下工具函数<code>forEachValue</code>的代码，在<code>util.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forEach for object</span></span><br><span class="line"><span class="comment"> * ! 使用函数处理对象的所有 value 和 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">forEachValue</span>(<span class="params">obj, fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> fn(obj[key], key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数遍历传入的对象<code>obj</code>的<code>keys</code>，然后在调用传入的函数<code>fn</code>处理对象的<code>value</code>和<code>key</code>。</p><p><code>forEachMutation</code>函数就是遍历传入的<code>mutions</code>对象，然后处理对象里面的<code>value</code>和<code>key</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/mutationName'</span></span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数体中先声明常量<code>namespacedType</code>存储拼接<code>namespace</code>和<code>key</code>后的值，然后调用函数<code>registerMutation</code>注册<code>mutation</code>。</p><p>看下<code>registerMutation</code>函数的代码，它是如何注册<code>mutation</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! &#123; 'moduleName/mutationName': entry &#125;</span></span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! _mutations = &#123; 'moduleName/mutationName': [wrappedMutationHandler] &#125;</span></span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    handler.call(store, local.state, payload) <span class="comment">// ! mutationFn(local.state, payload) -&gt; 第一个参数是模块的 state</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是把原始的<code>mutaions</code>放入到<code>store</code>实例属性的<code>_mutations</code>中。注意这里就用到了模块上下文<code>local</code>，在第一个参数中传入的是<code>local.state</code>，即模块的<code>state</code>，这里的<code>state</code>就是通过<code>getNestedState</code>函数获取的，不管是 root 的<code>state</code>，还是模块的<code>state</code>，都能正确获取到值。</p><p>其实在创建模块上下文的函数中，会先判断是否有命名空间模块，如果没有也会兼容没有命名空间模块的处理。所以看到使用了<code>local</code>的属性时，不要慌，他已经做了兼容处理，如果没有命名空间的模块的话，会按照 root 的值去处理。</p><p>接下来看下<code>actions</code>的遍历和注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 mutations，把 mutation 放入到 _mutations 中，并重写里面的函数</span></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.root ? key : namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/actionName'</span></span><br><span class="line">  <span class="keyword">const</span> handler = action.handler || action <span class="comment">// ! 获取 action 函数</span></span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和<code>mutaion</code>的逻辑差不多，不过从代码中可以看出<code>action</code>更加灵活，即可以是一个函数，也可以是一个对象。如果它是一个对象，会把函数放在对象的<code>handler</code>属性中。</p><p>看下<code>registerAction</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 actions，把 action 放入到 _actions 中，并重写里面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span>(<span class="params">payload, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.call(</span><br><span class="line">      store,</span><br><span class="line">      <span class="comment">// ! 第一个参数有很多选项，注意区分是模块 local 的属性还是根 store 的属性</span></span><br><span class="line">      &#123;</span><br><span class="line">        dispatch: local.dispatch,</span><br><span class="line">        commit: local.commit,</span><br><span class="line">        getters: local.getters,</span><br><span class="line">        state: local.state,</span><br><span class="line">        rootGetters: store.getters,</span><br><span class="line">        rootState: store.state</span><br><span class="line">      &#125;,</span><br><span class="line">      payload,</span><br><span class="line">      cb</span><br><span class="line">    ) <span class="comment">// ! actionFn(&#123; commit... rootState &#125;, payload, cb)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 判断返回值是否是 Promise，不是就调用 Promise.resolve() 转换成 Promise</span></span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也和<code>mutaion</code>的组成差不多，只是<code>action</code>函数的第一个参数有非常多的选项。有四个模块的属性和两个 root 的属性。</p><p>另外，我们都知道<code>action</code>函数是可以进行异步执行的，所以这里会判断函数的返回值是不是一个 Promise 对象，如果不是的话，会使用<code>Promise.resolve()</code>方法把它转换成一个 Promise 对象。</p><p>下面看下<code>getters</code>的遍历和注册，逻辑和前面的一样，这里不在赘述了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type --&gt; 'moduleName/getterName'</span></span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再查看<code>registerGetter</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 getters，把 getter 放入到 _wrappedGetters 中，并重写里面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span>(<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 已经在里面了，就不要注册了</span></span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 使用原始函数</span></span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      <span class="comment">// ! 传入多个参数</span></span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    ) <span class="comment">// ! getterFn(state, getter, rootState, rootGetter)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断下<code>_wrappedGetters</code>是否已经存在<code>getterName</code>，如果存在，即它们的<code>key</code>值相同，这时在开发环境中会报错。这说明可能创建了两个一样的模块，需要删除其中的一个模块。</p><p>注意这里的是<code>_wrappedGetters</code>属性，而不是<code>getters</code>属性，<code>_wrappedGetters</code>里面的函数包装了原始的<code>rawGetter</code>，然后把包装后的<code>wrappedGetter</code>函数组成的对象赋值给<code>_wrappedGetters</code>属性。</p><p>看下<code>installModule</code>函数的最后代码，递归注册子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 递归注册子模块</span></span><br><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot) <span class="comment">// ! path 连接 key(模块名)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先看下模块的<code>forEachChild</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历并处理子模块</span></span><br><span class="line">forEachChild(fn) &#123;</span><br><span class="line">  forEachValue(<span class="keyword">this</span>._children, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遍历的是模块的子模块<code>this._children</code>的值。然后递归调用<code>installModule</code>进行注册，注意<code>path</code>的变化，这里不在是空数组，而是合并了<code>key</code>值（即子模块的名称）。</p><p>模块安装完成后，继续看<code>Store</code>的构造函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line"><span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">resetStoreVM(<span class="keyword">this</span>, state) <span class="comment">// ! ③ 初始化 store._vm</span></span><br></pre></td></tr></table></figure><p>调用<code>resetStoreVM</code>函数初始化<code>store._vm</code>属性。这里是<code>Store</code>实例初始化的第三个重点阶段：初始化<code>store._vm</code>。</p><h2 id="初始化store-vm"><a href="#初始化store-vm" class="headerlink" title="初始化store._vm"></a>初始化<code>store._vm</code></h2><p>这里传入的参数是<code>store</code>实例自身和 root 的<code>state</code>的值。下面看下<code>resetStoreVM</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store._vm <span class="comment">// ! 缓存旧的 VM，用于热重载</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125; <span class="comment">// ! 创建 getters 属性</span></span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters <span class="comment">// ! 获取 wrappedGetters 对象</span></span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125; <span class="comment">// ! 设置计算属性对象</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先缓存旧的<code>store._vm</code>用于热重载时销毁，然后定义<code>store.getters</code>的初始值为一个空对象，注意这里才正式开始定于<code>getters</code>属性，再声明常量<code>wrappedGetters</code>存储<code>store._wrappedGetters</code>，声明<code>computed</code>对象，初始值是一个空对象。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历 wrappedGetters</span></span><br><span class="line">forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">  <span class="comment">// using partial to return function with only arguments preserved in closure enviroment</span></span><br><span class="line">  <span class="comment">// ! 把 wrappedGetter 函数的返回值赋值到 VM 的 computed 中</span></span><br><span class="line">  computed[key] = partial(fn, store) <span class="comment">// ! fn(store) -&gt; wrappedGetter(store)</span></span><br><span class="line">  <span class="comment">// ! 定义 store.getters 的属性</span></span><br><span class="line">  <span class="comment">// ! store.getters.xxx -&gt; store._vm[xxx] -&gt; store._vm.computed[xxx]</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">    enumerable: true // for local getters</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里遍历<code>wrappedGetters</code>，然后把它里面的数据赋值给上面声明的<code>computed</code>对象。注意这里是调用了<code>fn</code>函数，去掉函数包装，生成真正的<code>getter</code>。</p><p><code>store.getters</code>的数据结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  getterFn()&#123;&#125;, <span class="comment">// root getters</span></span><br><span class="line">  <span class="string">'modulesA/getterFn'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesA/getterFn2'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesB/getterFn'</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>Object.defineProperty</code>定义<code>key</code>的属性中的<code>getter</code>的返回值为<code>store._vm[key]</code>。</p><p>我们知道在 Vue 的实例对象中计算属性<code>computed</code>的值会出现在代理的实例对象中。后面会把<code>computed</code>对象作为计算属性注入到 Vue 的实例中，因为计算属性都会被代理到 Vue 的实例中，所以可以通过<code>store._vm[key]</code>获取到计算属性。当访问<code>store.getters</code>的时候，就是访问<code>store._vm[key]</code>，也就是访问计算属性。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> silent = Vue.config.silent <span class="comment">// ! 缓存原来的 silent</span></span><br><span class="line">Vue.config.silent = <span class="literal">true</span> <span class="comment">// ! 设为 true，将不会报任何警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 创建 store._vm 实例</span></span><br><span class="line"><span class="comment">// ! 绑定 state 和 getter 为 Vue 实例的 data 和 computed 属性，变成响应式数据</span></span><br><span class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    $$state: state <span class="comment">// !  store.state -&gt; store._vm.data.$$state</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed <span class="comment">// ! store._vm.computed[xxx] -&gt; store._vm[xxx]</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.config.silent = silent <span class="comment">// ! 恢复原来的 silent</span></span><br></pre></td></tr></table></figure><p>先处理 silent 的设置，然后生成一个新的 Vue 实例对象，赋值给<code>store._vm</code>，在生成的过程中把根数据<code>state</code>赋值为到 Vue 实例的<code>data</code>属性的<code>$$state</code>，然后把上面定义的<code>computed</code>对象也传入进去。这样<code>store</code>的<code>state</code>和<code>getters</code>属性都变成了响应式数据。</p><p>我们都知道，Vuex 状态管理器的数据不同意一般的模块文件中的数据，它是响应式的，当我们修改了 Vuex 的数据时，依赖 Vuex 的数据的组件的视图会自动更新。这里的源码就是 Vuex 的数据变成响应式数据的原因。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enable strict mode for new vm</span></span><br><span class="line"><span class="comment">// ! 在严格模式下，确保只能通过 commit 来显示的修改 state 的值</span></span><br><span class="line"><span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">  enableStrictMode(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在严格模式下，我们修改 Vuex 的数据必须显示的提交<code>commit</code>来进行修改，否则会报错。</p><p>看下<code>enableStrictMode</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 执行严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 在开发环境，如果没有使用 commit 修改了 state 的值，会报错</span></span><br><span class="line">  store._vm.$watch(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._data.$$state <span class="comment">// ! 严格模式下监听 store.state 值的变化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          store._committing,</span><br><span class="line">          <span class="string">`do not mutate vuex store state outside mutation handlers.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">sync</span>: <span class="literal">true</span> &#125; <span class="comment">// ! 深度监听和同步执行，有性能消耗，只能在开发环境使用 strict</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 Vue 实例的侦听器<code>$watch</code>去监听<code>state</code>的变化，在变化的时候，如果<code>store._committing</code>为<code>false</code>会在开发环境中报错。同时还设置了深度监听和同步执行，这样会有很大的性能消耗，所以<code>strick</code>只能在开发环境中开启，千万不要在生产环境时开启。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 热重载处理</span></span><br><span class="line"><span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">    <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">    <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">    store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      oldVm._data.$$state = <span class="literal">null</span> <span class="comment">// ! 数据重置为 null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> oldVm.$destroy()) <span class="comment">// ! 销毁旧的 VM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是 Vuex 热重载的设置，热重载后需要重置旧的 VM 的数据和销毁旧的 VM 实例。</p><p>初始化<code>store._vm</code>完成后，继续看<code>Store</code>类的构造函数剩下的最后代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply plugins</span></span><br><span class="line">plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin(<span class="keyword">this</span>)) <span class="comment">// ! 调用所有插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 处理 devtool 插件</span></span><br><span class="line"><span class="keyword">const</span> useDevtools =</span><br><span class="line">  options.devtools !== <span class="literal">undefined</span> ? options.devtools : Vue.config.devtools</span><br><span class="line"><span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">  devtoolPlugin(<span class="keyword">this</span>) <span class="comment">// ! 安装 devtool 插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用所有的插件，最后设置官方的 devtool 插件。</p><p>到了这一步，<code>Store</code>的实例对象的初始化就完成了，其实这也就是 Vuex 的初始化。在我们使用<code>script</code>标签使用 Vuex 的时候，此时 Vue 库的代码必须先引入，然后再引入 Vuex 库的代码，这样才能使用 Vuex。在用外链引入 Vue 和 Vue 的代码时， Vue 的构造函数会被赋值给<code>window.Vue</code>且浏览器对象<code>window</code>也是有定义的，<code>store.js</code>文件中的全局变量<code>Vue</code>也还没有赋值，此时才会安装 Vuex。</p><p>示例代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.1/vuex.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span></span><br><span class="line">      state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        addOne(state) &#123;</span><br><span class="line">          state.count += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: `<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"$store.commit('addOne')"</span>&gt;</span>count: </span><span class="template-variable">&#123;&#123;$store.state.count&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">      store</span><br><span class="line"><span class="actionscript">    &#125;).$mount(<span class="string">'#app'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码，是在开发环境中，执行三个断言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  assert(</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>,</span><br><span class="line">    <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">  )</span><br><span class="line">  assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`store must be called with the new operator.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下断言函数<code>assert</code>的代码，在<code>util.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 断言：当条件没达成的时候，抛出错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`[vuex] <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，没有满足断言条件的话，就会抛出错误。</p><p>下面分析下三个断言</p><ul><li>Vue 必须有值（存在），因为 Vuex 只有依赖 Vue 才能使用。</li><li>必须是支持 Promise 的环境，因为 Vuex 中的 actions 使用了 Promise 语法来处理异步。</li><li>传入到 Vue 的选项中的<code>store</code>实例对象必须是通过操作符 new 出来的<code>Store</code>实例。</li></ul><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取选项中的插件（默认是空数组）和严格模式定义（默认是 false）</span></span><br><span class="line"><span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line"><span class="comment">// store internal state</span></span><br><span class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span> <span class="comment">// ! 判断是否使用 commit 修改数据</span></span><br><span class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 actions</span></span><br><span class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">// ! 存储 action 的所有订阅函数</span></span><br><span class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 mutations</span></span><br><span class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储 wrapper getters</span></span><br><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// ! ① 模块收集 =&gt; &#123; root: rootModule &#125;</span></span><br><span class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 模块命名映射表 &#123; 'moduleName/': module&#125;</span></span><br><span class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">// ! 存储 mutation 的所有订阅函数</span></span><br><span class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">// ! 创建一个 Vue 实例，用来使用实例属性 $watch 实现 watch API</span></span><br><span class="line"><span class="keyword">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 模块的 getters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>从<code>options</code>获取插件和<code>strict</code>模式。</p><p>然后定义了一堆的属性，属性解析请看上面的注释。</p><p>这里主要看下<code>this._modules</code>属性，它是<code>ModuleCollection</code>类的实例对象，通过创建这个实例对象，进行模块的收集。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// ! ① 模块收集 =&gt; &#123; root: rootModule &#125;</span></span><br></pre></td></tr></table></figure><p>这里是<code>Store</code>实例初始化的第一个重点阶段：模块收集。</p><h2 id="模块收集-1"><a href="#模块收集-1" class="headerlink" title="模块收集"></a>模块收集</h2><h3 id="ModuleCollection模块收集类-1"><a href="#ModuleCollection模块收集类-1" class="headerlink" title="ModuleCollection模块收集类"></a><code>ModuleCollection</code>模块收集类</h3><p>查看<code>ModuleCollection</code>类的代码，在<code>module/module-collection.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 模块收集类，设置 root 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawRootModule) &#123;</span><br><span class="line">    <span class="comment">// register root module (Vuex.Store options)</span></span><br><span class="line">    <span class="keyword">this</span>.register([], rawRootModule, <span class="literal">false</span>) <span class="comment">// ! 初始化时注册模块</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的主要作用是收集模块，它会创建一个<code>{ root: Module instance}</code>实例对象。</p><p>看类的构造函数，在初始化时只调用<code>register</code>方法来注册模块。</p><p>查看<code>register</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">register(path, rawModule, runtime = <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// ! 开发模式下断言原始数据，判断输入的数据类型和格式是否有错</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assertRawModule(path, rawModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime) <span class="comment">// ! 创建一个模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! path 为空时</span></span><br><span class="line">  <span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = newModule <span class="comment">// ! 创建的模块为根模块，注意：this.root 是这里类唯一的属性值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>)) <span class="comment">// ! 根据路径获取到父模块（在数组里面它前面的元素）</span></span><br><span class="line">    parent.addChild(path[path.length - <span class="number">1</span>], newModule) <span class="comment">// ! 添加子模块，建立父子关系</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register nested modules</span></span><br><span class="line">  <span class="comment">// ! 用户自定义模块，注册嵌套模块</span></span><br><span class="line">  <span class="keyword">if</span> (rawModule.modules) &#123;</span><br><span class="line">    forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! 把 key 放入到 path 中，key === moduleName</span></span><br><span class="line">      <span class="keyword">this</span>.register(path.concat(key), rawChildModule, runtime)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在开发环境中会使用断言函数校验用户输入的原始选项数据的类型或者格式是否有错。</p><p>然后声明常量<code>newModule</code>，存储通过操作符 new 创建一个<code>Module</code>实例对象的。先不管生成的实例对象是怎么样子的，继续看下面的代码。</p><p>如果<code>path</code>数组的长度为 0 时，生成的模块被赋值给<code>this.root</code>，即生成根模块。注意：<code>root</code>属性是类<code>ModuleCollection</code> 实例对象的唯一一个的属性值。我们在初始化模块时，<code>path</code>是一个空数组，所有先不看 else 代码块的代码，后面再解析。</p><p>继续看下面的代码，如果我们的原始数据中设置了模块，会遍历这些模块，然后还是通过<code>register</code>方法注册这些模块。这里注册时，<code>path</code>就不是一个空数组了，而是合并了<code>key</code>，也就是模块名。这时，会进入上面的 else 代码块的逻辑，首先需要通过<code>get</code>方法根据传入<code>path</code>数组中的<code>key</code>之前的元素获取父级模块，然后使用<code>addChild</code>方法添加模块，添加的模块名就是之前传入到<code>path</code>数组的<code>key</code>，这样就建立好了父子关系。</p><p>这里可能有点难以理解，请看下面的示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line">modules: &#123;</span><br><span class="line">  moduleA: &#123;<span class="comment">/* */</span>&#125;,</span><br><span class="line">  moduleB: &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初步收集模块后的 _modules 属性</span></span><br><span class="line">_modules: &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    _children: &#123;</span><br><span class="line">      moduleA: &#123;<span class="comment">/* Module instance */</span>&#125;,</span><br><span class="line">      moduleB: &#123;<span class="comment">/* Module instance */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下它是怎么获取父级模块的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(path) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">  &#125;, <span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，模块对应的<code>path</code>数组中只有模块名一个元素，取它之前的元素构成一个新的<code>path</code>，此时<code>path</code>其实是一个空数组<code>[]</code>，这时获取到的父级模块就是根模块。所以会把<code>moduleA</code>和<code>moduleB</code>这两个模块添加到根模块的<code>_children</code>属性中。</p><h3 id="Module模块类-1"><a href="#Module模块类-1" class="headerlink" title="Module模块类"></a><code>Module</code>模块类</h3><p>模块的实例对象是通过<code>Module</code>生成的，它里面定义了一些操作模块的属性和方法。</p><p>查看<code>Module</code>类的代码，在<code>module/module.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawModule, runtime) &#123;</span><br><span class="line">    <span class="keyword">this</span>.runtime = runtime <span class="comment">// ! 存储 runtime 的值</span></span><br><span class="line">    <span class="comment">// Store some children item</span></span><br><span class="line">    <span class="keyword">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// ! 存储子模块</span></span><br><span class="line">    <span class="comment">// Store the origin module object which passed by programmer</span></span><br><span class="line">    <span class="keyword">this</span>._rawModule = rawModule <span class="comment">// ! 存储原始模块数据</span></span><br><span class="line">    <span class="keyword">const</span> rawState = rawModule.state <span class="comment">// ! 获取根的 state 原始数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the origin module's state</span></span><br><span class="line">    <span class="keyword">this</span>.state = (<span class="keyword">typeof</span> rawState === <span class="string">'function'</span> ? rawState() : rawState) || &#123;&#125; <span class="comment">// ! 存储 state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的构造函数中，定义了一些属性，查看上面代码的注释。比如我们刚才用到的<code>_children</code>属性就是用来存储子模块的。</p><p>另外还定义了一些方法。比如我们刚才用到的添加子模块的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 增加子模块</span></span><br><span class="line">addChild(key, <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._children[key] = <span class="built_in">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把子模块添加到<code>_children</code>属性中，以键值对的形式存储。</p><p>到这里，模块的收集工作就完成了，其实就是通过用户输入的原始模块数据，创建一个根模块。这个根模块对应的<code>key</code>，就是<code>root</code>，即对象<code>{ root: root Module}</code>，然后把这个对象添加到<code>store</code>实例的<code>_modules</code>属性中。</p><p>下面继续看<code>Store</code>类的构造函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 绑定 this，指向 store 实例本身</span></span><br><span class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里绑定<code>commit</code>和<code>dispatch</code>方法的<code>this</code>指向，它们的<code>this</code>都指向<code>store</code>实例本身。</p><p>为什么要这么绑定呢？因为我们把<code>store</code>实例对象赋值给 Vue 的<code>$store</code>属性中，所以我们在实例组件中就可以像下面这样调用<code>commit</code>和<code>dispatch</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commti(<span class="string">'xxx'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>此时，如果不绑定<code>this</code>，<code>commit</code>和<code>diaptch</code>方法中的<code>this</code>指向的就是调用的它们的 Vue 实例组件，而不是<code>Store</code>实例对象。但是 Vue 实例组件中并没有这两个方法的，这样就会出错。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="comment">// ! 在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。</span></span><br><span class="line"><span class="keyword">this</span>.strict = strict</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state <span class="comment">// ! 获取根的 state</span></span><br></pre></td></tr></table></figure><p>设置严格模式和获取根的 state 数据。严格模式一般只在开发环境中启用，而不能再生成环境中启用，理由在后面会讲。</p><p>继续往下看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init root module.</span></span><br><span class="line"><span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line"><span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root) <span class="comment">// ! ② 安装 root 模块 ，模块初始化</span></span><br></pre></td></tr></table></figure><p>调用<code>installModule</code>函数安装模块。这里是<code>Store</code>实例初始化的第二个重点阶段：模块安装。</p><h2 id="模块安装-1"><a href="#模块安装-1" class="headerlink" title="模块安装"></a>模块安装</h2><p>安装模块，说白了就是初始化<code>store</code>实例的一些属性，在前面模块收集时只是初步处理了原始数据，这里会更进一步处理原始数据，把处理后的数据放到一开始定义的属性中，比如<code>_actions</code> 、<code>_mutations</code>等属性中。</p><p>查看<code>installModule</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length <span class="comment">// ! 判断是否是根模块</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path) <span class="comment">// ! 获取命名空间模块的名称 'moduleName/'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看函数体前面的代码，首先判断是否是根模块，当<code>path</code>是一个空数组时，传入的模块<code>module</code>就是根模块。</p><p>然后获取有命名空间模块的名称，是通过<code>ModuleCollection</code>实例对象的<code>getNamespace</code>方法获取的，看下这个方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取命名空间模块的名称</span></span><br><span class="line">getNamespace(path) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">this</span>.root <span class="comment">// ! 获取根模块</span></span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key) <span class="comment">// ! 获取子模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 子模块 key 设置了命名空间，获取 key，并且拼接 '/'</span></span><br><span class="line">    <span class="comment">// ! 第一轮循环：path = [ moduleName ]，namespace = ''，key = moduleName =&gt;  'moduleName/'</span></span><br><span class="line">    <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">  &#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>path</code>获取有命名空间的模块的名称。因为<code>Module</code>的实例对象中是通过<code>_children</code>属性存储子模块的，它的存储方式是键值对结构，其中的键名就是模块名，然后模块名在模块收集时，已经通过调用注册方法<code>register</code>把它放入到<code>path</code>数组中，所以可以通过不断的遍历，使用<code>getChild</code>方法获取子模块，然后在最后返回它的模块名。另外还需要在模块名后面拼接<code>/</code>符号，是为了在后面更好的拼接模块内的类型名。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register in namespace map</span></span><br><span class="line"><span class="comment">// ! 如果设置了命名空间，即 namespaced = true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    store._modulesNamespaceMap[namespace] &amp;&amp;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;namespace&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="string">'/'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  store._modulesNamespaceMap[namespace] = <span class="built_in">module</span> <span class="comment">// ! 赋值到命名映射表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>有了模块名和模块，就把它们赋值到<code>_modulesNamespaceMap</code>属性中，方面后面使用。在注册之前还需要判断<code>_modulesNamespaceMap</code>映射表中是否已经存储这个模块，如果存在，在开发环境中会报错，提示你模块重复，这时候需要检测下是否编写了相同的模块。</p><p>成功赋值后，<code>_modulesNamespaceMap</code>映射表属性的示例代码就会像下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  moduleA/: &#123;<span class="comment">/* Module instance */</span>&#125;,</span><br><span class="line">  moduleB/: &#123;<span class="comment">/* Module instance */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set state</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>)) <span class="comment">// ! 获取父级的 state</span></span><br><span class="line">  <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>] <span class="comment">// ! 获取模块名</span></span><br><span class="line">  store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.set(parentState, moduleName, <span class="built_in">module</span>.state) <span class="comment">// ! 设置子模块，建立父子关系，并且为响应性数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是设置<code>state</code>数据，把所有模块下面的<code>state</code>数据统一放入到 root 的<code>state</code>属性中。</p><p>这里通过<code>getNestedState</code>函数来获取模块下面的<code>state</code>，通过<code>path</code>数组来查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span>(<span class="params">state, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.length ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state) : state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如根的<code>state</code>数据和模块的<code>state</code>的结构之前是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把所有模块的<code>state</code>数据放到 root 的<code>state</code>中就变成下面这样子。后面还会把<code>state</code>数据放入到 Vue 组件的<code>data</code>属性下面，变成响应式数据，这里先买个关子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root state</span></span><br><span class="line">state: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">  moduleA: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  moduleB: &#123;</span><br><span class="line">    count: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 构造了一个本地上下文环境（模块内部）</span></span><br><span class="line"><span class="comment">// ! local 中的 commit dispatch state getter 的效果会不一样</span></span><br><span class="line"><span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br></pre></td></tr></table></figure><p>这里使用<code>makeLocalContext</code>函数创建一个模块上下文环境（<code>module.context</code>属性），重写<code>local</code>下面的一些属性。</p><h3 id="makeLocalContext创建模块上下文-1"><a href="#makeLocalContext创建模块上下文-1" class="headerlink" title="makeLocalContext创建模块上下文"></a><code>makeLocalContext</code>创建模块上下文</h3><p>查看<code>makeLocalContext</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span>(<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 创建 local 属性</span></span><br><span class="line">  <span class="comment">// ! 重写有命名空间的模块里面的 dispatch commit 方法和 getters state 属性</span></span><br><span class="line">  <span class="keyword">const</span> local = &#123;</span><br><span class="line">    dispatch: noNamespace</span><br><span class="line">      ? store.dispatch <span class="comment">// ! 没有命名空间，直接使用根的 dispatch --&gt; dispatch(actionName, payload)</span></span><br><span class="line">      : <span class="comment">// ... 省略重写的方法</span></span><br><span class="line"></span><br><span class="line">    commit: noNamespace</span><br><span class="line">      ? store.commit</span><br><span class="line">      : <span class="comment">// ... 省略重写的方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and state object must be gotten lazily</span></span><br><span class="line">  <span class="comment">// because they will be changed by vm update</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="keyword">get</span>: noNamespace</span><br><span class="line">        ? () =&gt; store.getters</span><br><span class="line">        : () =&gt; makeLocalGetters(store, namespace) // ! 使用一个对象来代理模块里面的 getters</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path) // ! 通过路径获取嵌套的 state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明常量<code>noNamespace</code>表示是否存在命名空间的模块，它的值是<code>true</code>时表示没有，即<code>namespace</code>为空字符串。</p><p>然后定义了一个<code>local</code>常量，里面重写了在有命名空间中的模块里面的<code>dispatch</code>、<code>commit</code>、<code>getters</code>、<code>state</code>的逻辑，最后返回<code>local</code>这个常量。</p><p>先看下重写的<code>dispatch</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch: noNamespace</span><br><span class="line">  ? store.dispatch <span class="comment">// ! 没有命名空间模块，直接使用根的 dispatch --&gt; dispatch(actionName, payload)</span></span><br><span class="line">: <span class="comment">// ! 有命名空间，提交的类型 type 不一样</span></span><br><span class="line">  (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">    <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">    <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! options: &#123; root: true &#125; -&gt; 也不会拼接命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">      type = namespace + type <span class="comment">// ! 拼接 type =&gt; 'moduleName/actionName'</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        !store._actions[type]</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(</span><br><span class="line">          <span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ! 传入新的 type 为参数 --&gt; dispatch(moduleName/actionName, payload)</span></span><br><span class="line">   <span class="keyword">return</span> store.dispatch(type, payload)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>首先还是判断<code>noNamespace</code>的值，如果没有命名空间的模块，就直接调用<code>store.diaptch</code>，它的参数中的<code>type</code>不变，就是我们传入的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(actionName, payload) <span class="comment">// ! 这里的 actionName 是 root 下面的</span></span><br></pre></td></tr></table></figure><p>如果有命名空间的模块或者没有设置第三个选项参数<code>{root: true}</code>，会拼接<code>type</code>，使得<code>type</code>变成<code>moduleName/actionName</code>，也就是说在模块中提交<code>action</code>时，提交的<code>actionName</code>会变成<code>moduleName/actionName</code>，这样就和 root 中的<code>actionName</code>很好的区分开来，调用的时候就是调用<code>moduleName/actionName</code>函数，而不是<code>actionName</code>函数。</p><p>重写的<code>commit</code>方法和<code>dispatch</code>逻辑一样，这里就不多赘述。</p><p>下面看下重写<code>getters</code>和<code>state</code>代码，它们有点不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="keyword">get</span>: noNamespace</span><br><span class="line">      ? () =&gt; store.getters</span><br><span class="line">      : () =&gt; makeLocalGetters(store, namespace) // ! 使用一个对象来代理模块里面的 getters</span><br><span class="line">  &#125;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path) // ! 通过路径获取嵌套的 state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先看<code>getters</code>，如果没有命名空间模块，函数的返回值是<code>store.getters</code>，否则函数返回值是<code>_makeLocalGettersCache</code>属性中对应的值，它是一个代理对象，这个代理对象是通过<code>makeLocalGetters</code>函数生成的。</p><p>看下<code>makeLocalGetters</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalGetters</span>(<span class="params">store, namespace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 添加模块的 getters 到 _makeLocalGettersCache 中</span></span><br><span class="line">  <span class="keyword">if</span> (!store._makeLocalGettersCache[namespace]) &#123;</span><br><span class="line">    <span class="keyword">const</span> gettersProxy = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> splitPos = namespace.length <span class="comment">// ! 分割点：namespace 的长度</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(store.getters).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// skip if the target getter is not match this namespace</span></span><br><span class="line">      <span class="keyword">if</span> (type.slice(<span class="number">0</span>, splitPos) !== namespace) <span class="keyword">return</span> <span class="comment">// ! 命名空间和 type 的模块名不一致时直接返回，即没有匹配成功</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// extract local getter type</span></span><br><span class="line">      <span class="keyword">const</span> localType = type.slice(splitPos) <span class="comment">// ! 截取 type 名称：moduleName/getterName --&gt; getterName</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add a port to the getters proxy.</span></span><br><span class="line">      <span class="comment">// Define as getter property because</span></span><br><span class="line">      <span class="comment">// we do not want to evaluate the getters in this time.</span></span><br><span class="line">      <span class="comment">// ! 代理 gettersProxy，gettersProxy.localType === store.getters[type]</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; store.getters[type],</span><br><span class="line">        enumerable: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    store._makeLocalGettersCache[namespace] = gettersProxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return store._makeLocalGettersCache[namespace]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要判断<code>_makeLocalGettersCache</code>属性中是否有模块，如果没有需要把模块的<code>getters</code>添加进去。</p><p>声明常量<code>gettersProxy</code>为一个空对象，用来代理模块的<code>getters</code>，最后返回这个对象。</p><p>声明常量<code>splitPos</code>存储<code>namespace</code>的长度值。</p><p>然后遍历<code>store.getters</code>的<code>keys</code>，当命名空间的值和<code>type</code>的模块名不一样时直接返回，即没有匹配到相应的模块。</p><p>如果匹配成功，声明常量<code>localType</code>截取 type 的名称，即原来是<code>moduleName/getterName</code>的名称现在变成<code>getterName</code>。然后使用<code>Object.defineProperty</code>定义<code>gettersProxy</code>对象的<code>localType</code>属性，但是它的<code>getter</code>返回的确实<code>store.getters</code>中的<code>type</code>的值。</p><p>这里请注意下，在<code>store.getters</code>中的<code>type</code>键名是带模块名前缀的，而<code>localType</code>键名是不带模块名前缀的。</p><p>这里也有点绕，其实就是在模块里面访问<code>getter</code>属性是不需要带模块名前缀的，直接访问。但是我们在输出它的值时从<code>store.getters</code>属性中获取的，这里属性是带有模块名前缀的，不然输出的就不是模块的<code>getter</code>，而是 root 的<code>getter</code>。我们现在还不知道<code>store.getters</code>属性的结构，后面知道后就会比较清楚了。</p><p>最后看下<code>state</code>，它是直接通过<code>getNestedState</code>来获取<code>state</code>的值，不管是 root 的<code>state</code>值还是在模块的<code>state</code>值。因为在定义模块上下文之前，我们已经把所有模块的<code>state</code>已经被放在 root 的<code>state</code>中，所以通过<code>getNestedState</code>函数可以很好获取它们的值。</p><p>创建好上下文对象<code>local</code>之后，我们看下<code>installModule</code>剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历和注册模块，下同</span></span><br><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/mutationName'</span></span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.root ? key : namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/actionName'</span></span><br><span class="line">  <span class="keyword">const</span> handler = action.handler || action <span class="comment">// ! 获取 action 函数</span></span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/getterName'</span></span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 递归注册子模块</span></span><br><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot) <span class="comment">// ! path 连接 key(模块名)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历模块中的存储的原始数据，然后注册这些原始数据。这里分别注册了<code>mutation</code>、<code>action</code>、<code>getter</code>和子模块。</p><p>在<code>Module</code>类的构造函数中，我们知道原始的数据<code>rawModule</code>是存储在<code>_rawModule</code>属性中的。</p><p>先看下如何遍历<code>mutaions</code>的值，查看<code>forEachMutation</code>方法的代码，在<code>module/module.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历并处理 mutations</span></span><br><span class="line">forEachMutation(fn) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.mutations) &#123;</span><br><span class="line">    forEachValue(<span class="keyword">this</span>._rawModule.mutations, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下工具函数<code>forEachValue</code>的代码，在<code>util.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forEach for object</span></span><br><span class="line"><span class="comment"> * ! 使用函数处理对象的所有 value 和 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">forEachValue</span>(<span class="params">obj, fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> fn(obj[key], key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数遍历传入的对象<code>obj</code>的<code>keys</code>，然后在调用传入的函数<code>fn</code>处理对象的<code>value</code>和<code>key</code>。</p><p><code>forEachMutation</code>函数就是遍历传入的<code>mutions</code>对象，然后处理对象里面的<code>value</code>和<code>key</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/mutationName'</span></span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数体中先声明常量<code>namespacedType</code>存储拼接<code>namespace</code>和<code>key</code>后的值，然后调用函数<code>registerMutation</code>注册<code>mutation</code>。</p><p>看下<code>registerMutation</code>函数的代码，它是如何注册<code>mutation</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! &#123; 'moduleName/mutationName': entry &#125;</span></span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! _mutations = &#123; 'moduleName/mutationName': [wrappedMutationHandler] &#125;</span></span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    handler.call(store, local.state, payload) <span class="comment">// ! mutationFn(local.state, payload) -&gt; 第一个参数是模块的 state</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是把原始的<code>mutaions</code>放入到<code>store</code>实例属性的<code>_mutations</code>中。注意这里就用到了模块上下文<code>local</code>，在第一个参数中传入的是<code>local.state</code>，即模块的<code>state</code>，这里的<code>state</code>就是通过<code>getNestedState</code>函数获取的，不管是 root 的<code>state</code>，还是模块的<code>state</code>，都能正确获取到值。</p><p>其实在创建模块上下文的函数中，会先判断是否有命名空间模块，如果没有也会兼容没有命名空间模块的处理。所以看到使用了<code>local</code>的属性时，不要慌，他已经做了兼容处理，如果没有命名空间的模块的话，会按照 root 的值去处理。</p><p>接下来看下<code>actions</code>的遍历和注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 mutations，把 mutation 放入到 _mutations 中，并重写里面的函数</span></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.root ? key : namespace + key <span class="comment">// ! 拼接 type -&gt; 'moduleName/actionName'</span></span><br><span class="line">  <span class="keyword">const</span> handler = action.handler || action <span class="comment">// ! 获取 action 函数</span></span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和<code>mutaion</code>的逻辑差不多，不过从代码中可以看出<code>action</code>更加灵活，即可以是一个函数，也可以是一个对象。如果它是一个对象，会把函数放在对象的<code>handler</code>属性中。</p><p>看下<code>registerAction</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 actions，把 action 放入到 _actions 中，并重写里面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span>(<span class="params">payload, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.call(</span><br><span class="line">      store,</span><br><span class="line">      <span class="comment">// ! 第一个参数有很多选项，注意区分是模块 local 的属性还是根 store 的属性</span></span><br><span class="line">      &#123;</span><br><span class="line">        dispatch: local.dispatch,</span><br><span class="line">        commit: local.commit,</span><br><span class="line">        getters: local.getters,</span><br><span class="line">        state: local.state,</span><br><span class="line">        rootGetters: store.getters,</span><br><span class="line">        rootState: store.state</span><br><span class="line">      &#125;,</span><br><span class="line">      payload,</span><br><span class="line">      cb</span><br><span class="line">    ) <span class="comment">// ! actionFn(&#123; commit... rootState &#125;, payload, cb)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 判断返回值是否是 Promise，不是就调用 Promise.resolve() 转换成 Promise</span></span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也和<code>mutaion</code>的组成差不多，只是<code>action</code>函数的第一个参数有非常多的选项。有四个模块的属性和两个 root 的属性。</p><p>另外，我们都知道<code>action</code>函数是可以进行异步执行的，所以这里会判断函数的返回值是不是一个 Promise 对象，如果不是的话，会使用<code>Promise.resolve()</code>方法把它转换成一个 Promise 对象。</p><p>下面看下<code>getters</code>的遍历和注册，逻辑和前面的一样，这里不在赘述了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key <span class="comment">// ! 拼接 type --&gt; 'moduleName/getterName'</span></span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再查看<code>registerGetter</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 注册 getters，把 getter 放入到 _wrappedGetters 中，并重写里面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span>(<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 已经在里面了，就不要注册了</span></span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 使用原始函数</span></span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      <span class="comment">// ! 传入多个参数</span></span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    ) <span class="comment">// ! getterFn(state, getter, rootState, rootGetter)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断下<code>_wrappedGetters</code>是否已经存在<code>getterName</code>，如果存在，即它们的<code>key</code>值相同，这时在开发环境中会报错。这说明可能创建了两个一样的模块，需要删除其中的一个模块。</p><p>注意这里的是<code>_wrappedGetters</code>属性，而不是<code>getters</code>属性，<code>_wrappedGetters</code>里面的函数包装了原始的<code>rawGetter</code>，然后把包装后的<code>wrappedGetter</code>函数组成的对象赋值给<code>_wrappedGetters</code>属性。</p><p>看下<code>installModule</code>函数的最后代码，递归注册子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 递归注册子模块</span></span><br><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot) <span class="comment">// ! path 连接 key(模块名)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先看下模块的<code>forEachChild</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历并处理子模块</span></span><br><span class="line">forEachChild(fn) &#123;</span><br><span class="line">  forEachValue(<span class="keyword">this</span>._children, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遍历的是模块的子模块<code>this._children</code>的值。然后递归调用<code>installModule</code>进行注册，注意<code>path</code>的变化，这里不在是空数组，而是合并了<code>key</code>值（即子模块的名称）。</p><p>模块安装完成后，继续看<code>Store</code>的构造函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line"><span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">resetStoreVM(<span class="keyword">this</span>, state) <span class="comment">// ! ③ 初始化 store._vm</span></span><br></pre></td></tr></table></figure><p>调用<code>resetStoreVM</code>函数初始化<code>store._vm</code>属性。这里是<code>Store</code>实例初始化的第三个重点阶段：初始化<code>store._vm</code>。</p><h2 id="初始化store-vm-1"><a href="#初始化store-vm-1" class="headerlink" title="初始化store._vm"></a>初始化<code>store._vm</code></h2><p>这里传入的参数是<code>store</code>实例自身和 root 的<code>state</code>的值。下面看下<code>resetStoreVM</code>函数的代码，在<code>store.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store._vm <span class="comment">// ! 缓存旧的 VM，用于热重载</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125; <span class="comment">// ! 创建 getters 属性</span></span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters <span class="comment">// ! 获取 wrappedGetters 对象</span></span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125; <span class="comment">// ! 设置计算属性对象</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先缓存旧的<code>store._vm</code>用于热重载时销毁，然后定义<code>store.getters</code>的初始值为一个空对象，注意这里才正式开始定于<code>getters</code>属性，再声明常量<code>wrappedGetters</code>存储<code>store._wrappedGetters</code>，声明<code>computed</code>对象，初始值是一个空对象。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历 wrappedGetters</span></span><br><span class="line">forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">  <span class="comment">// using partial to return function with only arguments preserved in closure enviroment</span></span><br><span class="line">  <span class="comment">// ! 把 wrappedGetter 函数的返回值赋值到 VM 的 computed 中</span></span><br><span class="line">  computed[key] = partial(fn, store) <span class="comment">// ! fn(store) -&gt; wrappedGetter(store)</span></span><br><span class="line">  <span class="comment">// ! 定义 store.getters 的属性</span></span><br><span class="line">  <span class="comment">// ! store.getters.xxx -&gt; store._vm[xxx] -&gt; store._vm.computed[xxx]</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">    enumerable: true // for local getters</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里遍历<code>wrappedGetters</code>，然后把它里面的数据赋值给上面声明的<code>computed</code>对象。注意这里是调用了<code>fn</code>函数，去掉函数包装，生成真正的<code>getter</code>。</p><p><code>store.getters</code>的数据结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  getterFn()&#123;&#125;, <span class="comment">// root getters</span></span><br><span class="line">  <span class="string">'modulesA/getterFn'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesA/getterFn2'</span>() &#123;&#125;,</span><br><span class="line">  <span class="string">'modulesB/getterFn'</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>Object.defineProperty</code>定义<code>key</code>的属性中的<code>getter</code>的返回值为<code>store._vm[key]</code>。</p><p>我们知道在 Vue 的实例对象中计算属性<code>computed</code>的值会出现在代理的实例对象中。后面会把<code>computed</code>对象作为计算属性注入到 Vue 的实例中，因为计算属性都会被代理到 Vue 的实例中，所以可以通过<code>store._vm[key]</code>获取到计算属性。当访问<code>store.getters</code>的时候，就是访问<code>store._vm[key]</code>，也就是访问计算属性。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> silent = Vue.config.silent <span class="comment">// ! 缓存原来的 silent</span></span><br><span class="line">Vue.config.silent = <span class="literal">true</span> <span class="comment">// ! 设为 true，将不会报任何警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 创建 store._vm 实例</span></span><br><span class="line"><span class="comment">// ! 绑定 state 和 getter 为 Vue 实例的 data 和 computed 属性，变成响应式数据</span></span><br><span class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    $$state: state <span class="comment">// !  store.state -&gt; store._vm.data.$$state</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed <span class="comment">// ! store._vm.computed[xxx] -&gt; store._vm[xxx]</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.config.silent = silent <span class="comment">// ! 恢复原来的 silent</span></span><br></pre></td></tr></table></figure><p>先处理 silent 的设置，然后生成一个新的 Vue 实例对象，赋值给<code>store._vm</code>，在生成的过程中把根数据<code>state</code>赋值为到 Vue 实例的<code>data</code>属性的<code>$$state</code>，然后把上面定义的<code>computed</code>对象也传入进去。这样<code>store</code>的<code>state</code>和<code>getters</code>属性都变成了响应式数据。</p><p>我们都知道，Vuex 状态管理器的数据不同意一般的模块文件中的数据，它是响应式的，当我们修改了 Vuex 的数据时，依赖 Vuex 的数据的组件的视图会自动更新。这里的源码就是 Vuex 的数据变成响应式数据的原因。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enable strict mode for new vm</span></span><br><span class="line"><span class="comment">// ! 在严格模式下，确保只能通过 commit 来显示的修改 state 的值</span></span><br><span class="line"><span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">  enableStrictMode(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在严格模式下，我们修改 Vuex 的数据必须显示的提交<code>commit</code>来进行修改，否则会报错。</p><p>看下<code>enableStrictMode</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 执行严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 在开发环境，如果没有使用 commit 修改了 state 的值，会报错</span></span><br><span class="line">  store._vm.$watch(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._data.$$state <span class="comment">// ! 严格模式下监听 store.state 值的变化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          store._committing,</span><br><span class="line">          <span class="string">`do not mutate vuex store state outside mutation handlers.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">sync</span>: <span class="literal">true</span> &#125; <span class="comment">// ! 深度监听和同步执行，有性能消耗，只能在开发环境使用 strict</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 Vue 实例的侦听器<code>$watch</code>去监听<code>state</code>的变化，在变化的时候，如果<code>store._committing</code>为<code>false</code>会在开发环境中报错。同时还设置了深度监听和同步执行，这样会有很大的性能消耗，所以<code>strick</code>只能在开发环境中开启，千万不要在生产环境时开启。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 热重载处理</span></span><br><span class="line"><span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">    <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">    <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">    store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      oldVm._data.$$state = <span class="literal">null</span> <span class="comment">// ! 数据重置为 null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> oldVm.$destroy()) <span class="comment">// ! 销毁旧的 VM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是 Vuex 热重载的设置，热重载后需要重置旧的 VM 的数据和销毁旧的 VM 实例。</p><p>初始化<code>store._vm</code>完成后，继续看<code>Store</code>类的构造函数剩下的最后代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply plugins</span></span><br><span class="line">plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin(<span class="keyword">this</span>)) <span class="comment">// ! 调用所有插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 处理 devtool 插件</span></span><br><span class="line"><span class="keyword">const</span> useDevtools =</span><br><span class="line">  options.devtools !== <span class="literal">undefined</span> ? options.devtools : Vue.config.devtools</span><br><span class="line"><span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">  devtoolPlugin(<span class="keyword">this</span>) <span class="comment">// ! 安装 devtool 插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用所有的插件，最后设置官方的 devtool 插件。</p><p>到了这一步，<code>Store</code>的实例对象的初始化就完成了，其实这也就是 Vuex 的初始化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 文档</a></p></li><li><p><a href="https://github.com/haledc/vuex/tree/learn-vuex" target="_blank" rel="noopener">Vuex 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Store.js&lt;/code&gt;文件中的代码中，会导出一个&lt;code&gt;Store&lt;/code&gt;类，我们在使用 Vuex 的时候都是从先创建一个&lt;code&gt;Store&lt;/code&gt;实例对象开始的。&lt;/p&gt;
&lt;p&gt;下面看下&lt;code&gt;Store&lt;/code&gt;实例对象的初始化过程。&lt;/p&gt;
&lt;h2 id=&quot;Store-的初始化&quot;&gt;&lt;a href=&quot;#Store-的初始化&quot; class=&quot;headerlink&quot; title=&quot;Store 的初始化&quot;&gt;&lt;/a&gt;Store 的初始化&lt;/h2&gt;&lt;p&gt;先看下&lt;code&gt;Store&lt;/code&gt;类的初始化函数&lt;code&gt;constructor&lt;/code&gt;的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(options = &amp;#123;&amp;#125;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Auto install if it is not done yet and `window` has `Vue`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// To allow users to avoid auto-installation in some cases,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// this code should be placed here. See #731&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ! 使用 Vuex 为引入外链时，会自动安装插件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Vue &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt; !== &lt;span class=&quot;string&quot;&gt;&#39;undefined&#39;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.Vue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    install(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.Vue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在我们使用外链来引入 Vuex 时，会自动安装 Vuex，不需要再手动调用&lt;code&gt;use&lt;/code&gt;方法来安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vuex" scheme="https://haledeng.com/categories/Vuex/"/>
    
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Vuex" scheme="https://haledeng.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex3源码学习笔记之Vuex的安装</title>
    <link href="https://haledeng.com/blog/20191005-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://haledeng.com/blog/20191005-Vuex3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVuex%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2019-10-05T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:37.164Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>先查看下 src 下面的文件目录结构</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── module</span><br><span class="line">  ├── module-collection.js  <span class="comment"># 模块收集类 ModuleCollection</span></span><br><span class="line">  ├── module.js             <span class="comment"># 模块类 Module</span></span><br><span class="line">├── plugins</span><br><span class="line">  ├── devtool.js            <span class="comment"># devtool 插件</span></span><br><span class="line">  ├── logger.js             <span class="comment"># logger 插件</span></span><br><span class="line">├── helpers.js                <span class="comment"># 辅助函数，定义 mapXXX 语法糖</span></span><br><span class="line">├── index.esm.js              <span class="comment"># 模块 esm 入口</span></span><br><span class="line">├── index.js                  <span class="comment"># 入口</span></span><br><span class="line">├── mixin.js                  <span class="comment"># 混入到 Vue 的函数 applyMixin</span></span><br><span class="line">├── store.js                  <span class="comment"># 仓库类 Store</span></span><br><span class="line">├── util.js                   <span class="comment"># 工具函数</span></span><br></pre></td></tr></table></figure><p>先看下入口文件<code>index.js</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Store, install &#125; <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: <span class="string">'__VERSION__'</span>,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>store.js</code>文件中导入仓库类<code>Store</code>和安装方法<code>install</code>，从<code>helpers.js</code>文件中导入我们常用的语法糖<code>mapXXX</code>和一个绑定命名空间的辅助函数<code>createNamespacedHelpers</code>，然后再把这些属性方法导出去供用户使用。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>先看下 Vuex 的怎么安装在 Vue 上的，我们平时是这样使用 Vuex 的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>可以看出是通过 Vue 的<code>use</code>方法来安装 Vuex 的，这和安装 Vue 的插件是一样的方法。看过 Vue 的源码的同学都知道，使用<code>use</code>方法安装插件时，会在方法里面调用插件自带的<code>install</code>方法把插件安装到 Vue 中。</p><p>下面我们看下 Vuex 的<code>install</code>方法的代码，在<code>store.js</code>文件的最后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! Vuex 安装方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 插件只安装一次（单例模式）</span></span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue <span class="comment">// ! 传入的 _Vue 赋值给全局变量 Vue，也用来检测是否重复安装</span></span><br><span class="line">  applyMixin(Vue) <span class="comment">// ! 把 vuexInit 方法混入到 Vue 的 beforeCreated 钩子函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般安装 Vue 的插件都需要把 Vue 作为参数传入，因为插件是安装在 Vue 上的，Vuex 也不例外。首先声明了全局变量<code>Vue</code>存储 Vue 这个库，在安装的时候会把传入的<code>_Vue</code>存储到<code>Vue</code>变量中，这样下次查询一下全局变量存储的库是否和传入的库相同，如果相同，说明已经安装过这个插件了，直接返回。也就是说 Vuex 只能安装一次，不能重复安装，这是一个单例模式的设计方案。然后在最后调用<code>applyMixin</code>函数，同时把变量<code>Vue</code>传入。</p><p>这里主要是通过<code>applyMixin</code>函数来安装 Vuex。</p><p>下面看下<code>applyMixin</code>函数的代码，在<code>mixin.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>]) <span class="comment">// ! 获取主版本号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;) <span class="comment">// ! 使用 Vue 的 mixin 方法把 vuexInit 混入到 beforeCreate 钩子中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">    <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">    <span class="comment">// ! 兼容 v1.0 版本</span></span><br><span class="line">    <span class="keyword">const</span> _init = Vue.prototype._init</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit</span><br><span class="line">      _init.call(<span class="keyword">this</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看前面的代码，声明变量<code>version</code>存储获取的 Vue 的主版本号。即版本号中第一个点前面的数字，比如版本是 2.6.10，获取的值就是 2。然后根据主版本号使用不同的安装方法，这里兼容了 Vue 1.0 的安装方法，先不管它。</p><p>看下 2.0 以上版本的安装方法，调用 Vue 的<code>mixin</code>方法，在<code>beforeCreate</code>生命周期中混入一个<code>vuexInit</code>函数，也就是说在 Vue 初始化实例的时候，也会初始化 Vuex。</p><p>下面看下<code>vuexInit</code>函数的代码，它在<code>applyMixin</code>函数的尾部，了解 Vuex 是如何初始化的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! Vuex 初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options <span class="comment">// ! 获取 Vue 实例的选项</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// store injection</span></span><br><span class="line">  <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">    <span class="comment">// ! 把用户定义的 store 实例赋值给 Vue 实例的 $store 属性，方便组件操作 store</span></span><br><span class="line">    <span class="keyword">this</span>.$store =</span><br><span class="line">      <span class="keyword">typeof</span> options.store === <span class="string">'function'</span> ? options.store() : options.store</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store = options.parent.$store <span class="comment">// ! 从父组件中获取 store，因为全局的 store 都是同一个</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明常量<code>options</code>存储 Vue 实例初始化的选项，然后判断选项中是否有<code>store</code>属性，这个属性就是使用 Vuex 时创建的 Store 实例对象，这个实例对象会传入到 Vue 的选项中。如下面代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store, <span class="comment">// 放入到 Vue 的 options 中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先判断<code>options.store</code>的类型，如果是一个函数，需要调用它生成一个<code>Store</code>实例对象，如果是对象则直接赋值。</p><p>什么时候会使用函数类型呢？在我们构建 Vue 的服务端渲染时会使用，通过函数生成一个<code>Store</code>实例对象，这样每次都会生成一个新的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>然后如果没有<code>options.store</code>，则会从它的父级组件中去寻找，判断父级中是否已经存在<code>$store</code>属性，如果存在，把它赋值到自身的<code>$store</code>属性中，因为 Vuex 的设计模式是一个单例模式，全局的<code>store</code>都是同一个的，也是唯一的一个，全部组件都共享这个属性，所以从父级中获取也是一样的。</p><p>这样，Vuex 的安装过程就完成了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 文档</a></p></li><li><p><a href="https://github.com/haledc/vuex/tree/learn-vuex" target="_blank" rel="noopener">Vuex 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;h2 id=&quot;源码结构&quot;&gt;&lt;a href=&quot;#源码结构&quot; class=&quot;headerlink&quot; title=&quot;源码结构&quot;&gt;&lt;/a&gt;源码结构&lt;/h2&gt;&lt;p&gt;先查看下 src 下面的文件目录结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vuex" scheme="https://haledeng.com/categories/Vuex/"/>
    
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Vuex" scheme="https://haledeng.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之初始化终局</title>
    <link href="https://haledeng.com/blog/20190930-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%88%E5%B1%80/"/>
    <id>https://haledeng.com/blog/20190930-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%88%E5%B1%80/</id>
    <published>2019-09-30T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:31.026Z</updated>
    
    <content type="html"><![CDATA[<p>再次回到<code>initState</code>函数中，其中<code>data</code>、<code>watch</code>、<code>computed</code>和<code>props</code>选项的初始化都已讲解，下面还剩下<code>methods</code>选项的初始化未讲解。看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br></pre></td></tr></table></figure><p>通过调用<code>initMethods</code>函数初始化<code>methods</code>选项，还需要传入实例对象<code>vm</code>和合并选项后的<code>methods</code>属性。</p><h2 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a><code>initMethods</code></h2><p>下面看下<code>initMethods</code> 函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = vm.$options.props</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量<code>props</code>存储合并选项后的<code>props</code>选项，这个常量在后面会用到。</p><p>然后接下来就是一个<code>for</code>循环语句，遍历<code>methods</code>选项，下面看下<code>for</code>循环语句里面的内容。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// ! 方法必须是函数，否则报错</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has type "<span class="subst">$&#123;<span class="keyword">typeof</span> methods[</span></span></span><br><span class="line"><span class="string"><span class="subst">        key</span></span></span><br><span class="line"><span class="string"><span class="subst">      ]&#125;</span>" in the component definition. `</span> +</span><br><span class="line">        <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非生产环境中，如果<code>methods</code>选项里面的<code>value</code>值不是函数类型会报错。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 方法名不能和 props 里面的属性名相同，否则报错，这样会产生冲突，覆盖掉 props 的属性</span></span><br><span class="line"><span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">  warn(<span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>, vm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 方法和实例对象属性同名 且 是 Vue 的保留字时（以_或者$开头的，如 _data $parent 等）会报错</span></span><br><span class="line"><span class="comment">// ! 会产生冲突，覆盖掉实例属性</span></span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> vm &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">  warn(</span><br><span class="line">    <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">      <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非生产环境中，<code>methods</code>选项中的方法名不能和<code>props</code>选项中的<code>key</code>相同，否则会报错，因为这样会产生冲突，方法会覆盖掉<code>props</code>中的数据。</p><p>另外，<code>methods</code>选项中的方法和实例对象<code>vm</code>中的属性同名，并且方法名和 Vue 的保留属性重名时，会报错。</p><p>继续看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 代理方法到实例，并且指向实例</span></span><br><span class="line">vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span> ? noop : bind(methods[key], vm)</span><br></pre></td></tr></table></figure><p>把<code>methods</code>中的方法代理到实例对象<code>vm</code>中。这里并没有用<code>object.definedProperty</code>方法代理属性，而是直接调用了<code>bind</code>的函数，把方法的<code>this</code>指向实例对象。这个<code>bind</code>函数是对原生的<code>Function.prototype.bind</code>方法的做了兼容性处理的函数。</p><p>到这里，<code>methods</code>选项的初始化就讲解完成，<code>initState</code>函数的初始化全部讲解完成。</p><h2 id="provide"><a href="#provide" class="headerlink" title="provide"></a><code>provide</code></h2><p>再次回到<code>Vue.prototype._init</code>函数中，查看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initLifecycle(vm) <span class="comment">// ! 初始化生命周期相关配置 存储本身实例到父节点 新增属性 $parent $root $children $refs 等</span></span><br><span class="line">initEvents(vm) <span class="comment">// ! 初始化事件相关配置 更新 listeners</span></span><br><span class="line">initRender(vm) <span class="comment">// ! 初始化渲染, 创建 VNode 另新增属性 $attrs 和 $listeners</span></span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// ! 执行 beforeCreate 钩子函数</span></span><br><span class="line">initInjections(vm) <span class="comment">// ! 初始化 Injections resolve injections before data/props</span></span><br><span class="line">initState(vm) <span class="comment">// ! 初始化状态，响应式相关 按顺序 props =&gt; methods =&gt; data =&gt; computed  =&gt; watch</span></span><br><span class="line">initProvide(vm) <span class="comment">// ! 初始化 Provide resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>) <span class="comment">// ! 执行 created 钩子函数</span></span><br></pre></td></tr></table></figure><p>上面初始化的函数中，只剩下<code>initInjections</code>函数和<code>initProvide</code>函数没有讲解，注意在上面的代码中，<code>initInjections</code>函数要比<code>initProvide</code>函数更早执行。</p><p>这是为什么呢？等我们讲解到<code>initInjections</code>函数时就知道了。</p><p>下面先看下<code>provide</code>选项的初始化，查看<code>initProvide</code>函数的代码，在<code>core/instance/inject.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initProvide</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.$options.provide</span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm._provided = <span class="keyword">typeof</span> provide === <span class="string">'function'</span> ? provide.call(vm) : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数非常简单，只有几行代码。声明常量<code>provide</code>存储合并选项后<code>provide</code>选项，先判断<code>provide</code>是否存在，如果存在，定义实例对象的<code>vm._provided</code>属性存储<code>provide</code>，在存储前判断<code>provide</code>是不是函数类型，如果是的话，还需要执行函数获取值。</p><p><strong>小结</strong>，<code>initProvide</code>函数的作用就是创建实例的<code>_provided</code>属性，然后存储合并后的<code>provide</code>选项。</p><h2 id="inject"><a href="#inject" class="headerlink" title="inject"></a><code>inject</code></h2><h3 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a><code>initInjections</code></h3><p>下面看<code>inject</code>的选项的初始化，查看<code>initInjections</code>函数的代码，在<code>core/instance/inject.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInjections</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm) <span class="comment">// ! 讲解 inject，获取父组件 provide 的值</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量<code>result</code>存储<code>resolveInject</code>函数的返回值。<code>resolveInject</code>函数调用时需要传入合并后的<code>inject</code>选项和实例对象<code>vm</code>。</p><p>这个函数的作用应该是讲解<code>inject</code>选项。用过<code>inject</code>选项的同学应该都知道，<code>inject</code>选项中注入的属性是它所在实例组件的父组件或者更上一级的组件的<code>provide</code>选项提供的值。这个函数的作用是获取它所在组件的父组件中的<code>_provide</code>属性的值，实例组件的<code>_provide</code>属性是存储初始化后的<code>provide</code>选项。</p><h3 id="resolveInject"><a href="#resolveInject" class="headerlink" title="resolveInject"></a><code>resolveInject</code></h3><p>查看<code>resolveInject</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveInject</span>(<span class="params">inject: any, vm: Component</span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="comment">// inject is :any because flow is not smart enough to figure out cached</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> keys = hasSymbol ? <span class="built_in">Reflect</span>.ownKeys(inject) : <span class="built_in">Object</span>.keys(inject)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先判断通过参数传入的<code>inject</code>是否存在，如果存在，才能继续下面的逻辑。</p><p>声明变量<code>result</code>，它的初始值是一个空对象，它也是这个函数的返回值，它的作用是存储从父组件的<code>_provide</code>属性中获取的值。</p><p>声明变量<code>keys</code>存储<code>inject</code>的<code>keys</code>，先判断当前宿主环境是否支持<code>Symbol</code>，如果支持的话，使用<code>Reflect.ownKeys</code>方法获取<code>keys</code>的值；如果不支持，使用<code>Object.keys</code>方法获取<code>keys</code>的值。</p><p>再看下中间省略的代码，这里是一个<code>for</code>循环语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i]</span><br><span class="line">  <span class="comment">// #6574 in case the inject object is observed...</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'__ob__'</span>) <span class="keyword">continue</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看前面的代码，声明常量<code>key</code>缓存循环中的<code>key</code>值。</p><p>首先判断<code>key</code>是不是<code>__ob__</code>属性，如果是的话，跳过这次循环，这行代码是为了解决 Vue 的<a href="https://github.com/vuejs/vue/issues/6574" target="_blank" rel="noopener">6574 issue</a>的，我猜测主要原因是因为<code>__ob__</code>属性是通过<code>Object.defineProperty</code>方法定义的，而这个属性是不能通过<code>Object.keys</code>方法获取到的，所以为了保持在不支持<code>Symbol</code>环境下时<code>keys</code>的一致性，才会跳过这个循环。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> provideKey = inject[key].from <span class="comment">// ! 从 from 中获取对于 provide 的 key</span></span><br></pre></td></tr></table></figure><p>声明常量<code>provideKey</code>存储<code>inject[key]</code>的<code>from</code>属性，这个<code>from</code>属性就是父组件的<code>_provide</code>属性对应的<code>key</code>，从规范化<code>inject</code>选项的代码中我们知道，<code>inject</code>中的<code>from</code>属性存储它的来源属性的<code>key</code>值，另外，<code>inject</code>选项中的<code>key</code>值和这个<code>from</code>值不一定相同。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">provide: &#123;</span><br><span class="line">  name: <span class="string">'Hale'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 规范化前</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  n: <span class="string">'name'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化后</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  n: &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'name'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">n: <span class="string">'Hale'</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = vm</span><br><span class="line"><span class="keyword">while</span> (source) &#123;</span><br><span class="line">  <span class="comment">// ! 查找并获取父组件的 provide 的值</span></span><br><span class="line">  <span class="keyword">if</span> (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123;</span><br><span class="line">    result[key] = source._provided[provideKey] <span class="comment">// ! 注意：因为组件是先初始化 inject, 所以不会找到本身的 provide</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  source = source.$parent <span class="comment">// ! 循环往上找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量<code>source</code>缓存实例对象<code>vm</code>。然后就是一个<code>while</code>循环语句，它每次循环执行的代码是<code>source = source.$parent</code>，就是通过<code>$parent</code>属性一直在组件树中往上去寻找<code>source</code>。</p><p>循环的结束条件是找到组件<code>source</code>中有<code>_provide</code>属性且属性里面有和<code>provideKey</code>相同名字的<code>key</code>，这说明找到了父组件提供的<code>key</code>值，这个值就是<code>source._provided[provideKey]</code>，然后把值存储到变量<code>result</code>中。</p><p>这里有个问题，就是通过这样的方法去查找值，会不会找到实例本身定义的<code>provide</code>选项中的值呢？</p><p>答案是不会的。因为初始化实例对象时，初始化<code>inject</code>选项比初始化<code>provide</code>的时间更早，所以在那个时候，实例组件还没有创建<code>_provide</code>属性，只能去父组件中去寻找。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 如果循环之后还是找不到值</span></span><br><span class="line"><span class="keyword">if</span> (!source) &#123;</span><br><span class="line">  <span class="comment">// ! 如果定义了默认值则使用默认值，函数类型的默认字需要求值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'default'</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">    <span class="keyword">const</span> provideDefault = inject[key].default</span><br><span class="line">    result[key] =</span><br><span class="line">      <span class="keyword">typeof</span> provideDefault === <span class="string">'function'</span></span><br><span class="line">        ? provideDefault.call(vm)</span><br><span class="line">        : provideDefault</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 找不到又没有默认值，非生产环境下报错</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(<span class="string">`Injection "<span class="subst">$&#123;key&#125;</span>" not found`</span>, vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>source</code>是否存在，如果不存在，说明循环结束后还找到满足条件的父组件。</p><p>这时候先判断<code>inject</code>选项的属性里面是否设置了<code>default</code>属性，也就是默认值。如果设置了默认值，声明常量<code>provideDefault</code>存储这个默认值，即<code>inject[key].default</code>。</p><p>然后再判断这个默认值是不是一个函数，如果是函数，就执行函数求值，并把求值的结果赋值到<code>result</code>对象中，它的<code>key</code>还是以前的<code>key</code>，<code>vlaue</code>就是函数的求值结果。如果不是函数类型，直接赋值。</p><p>如果找不到满足条件的父组件，又没有设置默认值，在非生产环境中会报错，提示找不到<code>inject</code>中<code>key</code>的值。</p><p><code>resolveInject</code>函数讲解完毕，再次回到<code>initInjections</code>函数中，查看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取到 provide 的值后</span></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">  toggleObserving(<span class="literal">false</span>) <span class="comment">// ! 不监听 inject 选项的属性不是响应式的</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  toggleObserving(<span class="literal">true</span>) <span class="comment">// ! 恢复监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断是否获取到<code>provide</code>选项的值，获取到之后才能进行下面的逻辑。</p><p>执行<code>toggleObserving(false)</code>代码把<code>shouleObserve</code>的值设置为<code>false</code>，在前面我们知道把<code>shouleObserve</code>设置为<code>false</code>时，就不会去创建监听器属性。也就是说不会把<code>inject</code>中的数据变成响应式数据，因为<code>inject</code>选项的数据不需要是响应式数据。</p><p>这里中间省略了一些代码。</p><p>在最后又执行<code>toggleObserving(true)</code>代码把<code>shouleObserve</code>的值重新设置为<code>true</code>，这样就不会影响到其他选项的数据变成响应式数据。</p><p>下面看下中间的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// ! 实例代理 key，另外不能修改 inject 的数据，否则报错</span></span><br><span class="line">    defineReactive(vm, key, result[key], () =&gt; &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Avoid mutating an injected value directly since the changes will be `</span> +</span><br><span class="line">          <span class="string">`overwritten whenever the provided component re-renders. `</span> +</span><br><span class="line">          <span class="string">`injection being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(vm, key, result[key]) <span class="comment">// ! 实例代理 key</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过<code>Object.keys</code>获取<code>result</code>的<code>keys</code>的值，然后使用<code>forEach</code>遍历<code>keys</code>，再调用<code>defineReactive</code>函数使得实例对象<code>vm</code>代理<code>inject</code>上的<code>key</code>值。</p><p><strong>注意</strong>，这里通过<code>defineReactive</code>定义的数据并不会变成响应式数据。因为前面已经把<code>shouleObserve</code>变量设置为<code>false</code>了。但是如果父组件的<code>provide</code>选项提供的值是一个响应式数据，那么注入的值也是响应式数据。</p><p>另外，不能修改<code>inject</code>选项中的值，因为它的值来源于父组件，有点类似于<code>props</code>属性。如果修改了<code>inject</code>的值在非生产环境中会报错。</p><p><strong>到这里，Vue 的初始化就暂时告一个段落了</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再次回到&lt;code&gt;initState&lt;/code&gt;函数中，其中&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;和&lt;code&gt;props&lt;/code&gt;选项的初始化都已讲解，下面还剩下&lt;code&gt;methods&lt;/code&gt;选项的初始化未讲解。看下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.methods) initMethods(vm, opts.methods)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通过调用&lt;code&gt;initMethods&lt;/code&gt;函数初始化&lt;code&gt;methods&lt;/code&gt;选项，还需要传入实例对象&lt;code&gt;vm&lt;/code&gt;和合并选项后的&lt;code&gt;methods&lt;/code&gt;属性。&lt;/p&gt;
&lt;h2 id=&quot;initMethods&quot;&gt;&lt;a href=&quot;#initMethods&quot; class=&quot;headerlink&quot; title=&quot;initMethods&quot;&gt;&lt;/a&gt;&lt;code&gt;initMethods&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;下面看下&lt;code&gt;initMethods&lt;/code&gt; 函数的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; props = vm.$options.props&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; methods) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;声明常量&lt;code&gt;props&lt;/code&gt;存储合并选项后的&lt;code&gt;props&lt;/code&gt;选项，这个常量在后面会用到。&lt;/p&gt;
&lt;p&gt;然后接下来就是一个&lt;code&gt;for&lt;/code&gt;循环语句，遍历&lt;code&gt;methods&lt;/code&gt;选项，下面看下&lt;code&gt;for&lt;/code&gt;循环语句里面的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之Props</title>
    <link href="https://haledeng.com/blog/20190928-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BProps/"/>
    <id>https://haledeng.com/blog/20190928-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BProps/</id>
    <published>2019-09-28T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:26.102Z</updated>
    
    <content type="html"><![CDATA[<p>前面章节通过初始化<code>data</code>选项的<code>initData</code>函数讲解了 Vue 的响应式系统。</p><p>下面继续讲解<code>props</code>选项的初始化。</p><h2 id="props的初始化"><a href="#props的初始化" class="headerlink" title="props的初始化"></a><code>props</code>的初始化</h2><p>回到<code>initState</code>函数，查看初始化<code>props</code>选项的代码，在<code>core/instance/state.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br></pre></td></tr></table></figure><p>通过调用<code>initProps</code>函数初始化<code>props</code>选项，还需要传入实例对象<code>vm</code>和合并选项后的<code>props</code>属性。</p><p>下面看下<code>initProps</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125; <span class="comment">// ! 获取 props 数据来源</span></span><br><span class="line">  <span class="keyword">const</span> props = (vm._props = &#123;&#125;)</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = (vm.$options._propKeys = [])</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量<code>propsData</code>存储<code>vm.$options.propsData</code>属性，这是外界传进来的<code>props</code>数据。</p><a id="more"></a><p>声明常量<code>props</code>存储实例对象的<code>vm._props</code>属性，初始值为空对象，这个属性用来存储初始化后<code>props</code>的值。</p><p>声明常量<code>keys</code>存储<code>vm.$options._propsKeys</code>属性，初始值为空数组，这是<code>props</code>的<code>key</code>组成的数组。</p><p>声明常量<code>isRoot</code>存储表达式<code>!vm.$parent</code>的值，如果值为<code>true</code>，表示该组件是根组件，因为根组件没有<code>$parent</code>属性。</p><p>继续看下面的代码，只列出前面和后面的代码，中间的代码暂时省略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 不是根组件时，不进行监听，因为可能传过来的引用类型的值已经是响应式数据</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">  toggleObserving(<span class="literal">false</span>) <span class="comment">// ! 关闭监听开关 shouldObserve = false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">toggleObserving(<span class="literal">true</span>) <span class="comment">// ! 开启监听开关 shouldObserve = true</span></span><br></pre></td></tr></table></figure><p><code>toggleObserving</code>函数前面已经讲解过了，是控制变量<code>shouldObserve</code>的值的函数，而变量<code>shouldObserve</code>又是创建监听器对象的关键参数，是<code>observe</code>函数中创建监听器对象的五个必要条件之一。</p><p>这里先设置<code>shouldObserve</code>为<code>false</code>，最后把它的值重置为<code>true</code>。</p><p>下面看下中间的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">  keys.push(key)</span><br><span class="line">  <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm) <span class="comment">// ! 校验 props</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间代码是一个<code>for</code>循环语句，遍历的是通过参数传进来的合并选项后的<code>props</code>选项。在遍历的过程中把<code>key</code>值都放入上面定义的<code>keys</code>数组中。</p><p>声明变量<code>value</code>存储<code>validateProp</code>函数的返回值，<code>validateProp</code>函数是检验<code>props</code>传入值的函数，返回值是验证后的<code>prop</code>的值，后面再详细讲解。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! prop 的名字是保留的属性，发出警告</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">    config.isReservedAttr(hyphenatedKey)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非生产环境中，声明常量<code>hyphenatedKey</code>存储通过<code>hyphenate</code>函数把<code>key</code>值转换成连字符和小写字母的形式的值，然后再判断这个值是否是内置的属性名，如果是的话会发出警告。</p><p>看下<code>hyphenate</code>函数的代码，这个函数把驼峰形式的变量转换成连字符形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/\B([A-Z])/g</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hyphenate = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(hyphenateRE, <span class="string">'-$1'</span>).toLowerCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">'propName'</span></span><br><span class="line">hyphenate(key) <span class="comment">// 'prop-name'</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 定义 props 的属性，不是响应式</span></span><br><span class="line">defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">    <span class="comment">// ! 组件直接修改 props 属性，发出警告</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">        <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">        <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">        <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还是在非生产环境中，使用<code>defineReactive</code>函数把<code>props</code>对象下面的<code>key</code>值定义成<code>value</code>值，<code>props</code>也就是实例对象的<code>_props</code>属性，它们都是来自同一个引用。</p><p>另外，还传入第四个参数<code>customSetter</code>函数，这个函数的作用是，在不是根组件或者不是更新子组件的时候，如果修改了<code>props</code>的属性会发出警告。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ! 定义 props 的属性</span></span><br><span class="line">  <span class="comment">// ! 因为 shouldObserve = false, 不会变成响应式</span></span><br><span class="line">  defineReactive(props, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到生产环境，还是使用<code>defineReactive</code>函数把<code>props</code>对象下面的<code>key</code>值定义成<code>value</code>值。</p><p>因为在<code>for</code>循环之前因为把<code>shouldObserve</code>的值设置为<code>false</code>，所以<code>defineReactive</code>函数是不会把<code>props</code>的数据变成响应性数据的。为什么要这样做呢？因为传过来的<code>props</code>值一般都是响应式数据，这里就不需要定义了。</p><p>再看下<code>for</code>循环中的剩下的最后代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">  proxy(vm, <span class="string">`_props`</span>, key) <span class="comment">// ! 代理 props 上的属性 vm.xxx = vm._props.xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>proxy</code>函数把<code>props</code>的数据代理到实例对象中，这和<code>initData</code>函数中的逻辑一样。</p><p>到这里，<code>props</code>选项的初始化就已经完成。下面看下<code>props</code>的属性是怎么验证的。</p><h2 id="Props-的校验"><a href="#Props-的校验" class="headerlink" title="Props 的校验"></a><code>Props</code> 的校验</h2><p>在初始化<code>props</code>选项时，使用<code>for</code>循环语句遍历<code>props</code>选项，在每次循环时都会调用<code>validateProp</code>函数验证外界传过来的值是否符合要求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">  keys.push(key)</span><br><span class="line">  <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm) <span class="comment">// ! 校验 props</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下<code>validateProp</code>函数的代码，在<code>core/util/props.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateProp</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions: Object, <span class="regexp">//</span> ! 合并后的 props 选项</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: Object, <span class="regexp">//</span> ! 数据来源对象</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下函数的四个参数</p><ol><li><code>key</code>：遍历合并选项后的<code>props</code>选项的<code>key</code>。</li><li><code>propOptions</code>：合并选项后的<code>props</code>选项。</li><li><code>propsData</code>：外界传进来的<code>props</code>数据。</li><li><code>vm</code>：实例对象，这个参数是可选的。</li></ol><p>然后看下函数的代码，先看前面部分的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prop = propOptions[key] <span class="comment">// ! 获取定义的 prop 的属性包括 type 默认值等</span></span><br><span class="line"><span class="keyword">const</span> absent = !hasOwn(propsData, key) <span class="comment">// ! 外界没有传值进来</span></span><br><span class="line"><span class="keyword">let</span> value = propsData[key] <span class="comment">// ! 获取传进来的值</span></span><br><span class="line"><span class="comment">// boolean casting</span></span><br><span class="line"><span class="keyword">const</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type) <span class="comment">// ! 获取 Boolean 类型的索引</span></span><br></pre></td></tr></table></figure><p>声明常量<code>prop</code>存储用户定义的<code>pros</code>属性，里面包括类型<code>type</code>、默认值<code>default</code>、是否传值<code>required</code>等。声明常量<code>absent</code>存储表达式<code>!hasOwn(propsData, key)</code>的值，当表达式输出的值是<code>ture</code>时，表示外界没有传值进来。声明变量<code>value</code>存储外界传入的值。声明常量<code>booleanIndex</code>存储通过调用<code>getTypeIndex</code>函数获取到的类型的索引。</p><h3 id="getTypeIndex"><a href="#getTypeIndex" class="headerlink" title="getTypeIndex"></a><code>getTypeIndex</code></h3><p>下面看下<code>getTypeIndex</code>函数的代码，这个函数获取类型在数组中的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取匹配的类型索引。如果值大于 -1 时，说明匹配到了值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTypeIndex</span>(<span class="params">type, expectedTypes</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ! 期望的类型不是数组时，直接比较，是相同类型返回 0，不是返回 1</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(expectedTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameType(expectedTypes, type) ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 期望的类型是数组时，需要遍历，然后一一比较，返回匹配的类型在数组中的索引，如果都没有匹配到，返回 -1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = expectedTypes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSameType(expectedTypes[i], type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数传入的参数是类型<code>type</code>和用户定义（期望）的类型<code>expectedTypes</code>。</p><p>首先判断期望的类型是不是数组，如果不是数组，通过<code>isSameType</code>函数进行比较，确认它们的类型是否相同，如果相同，返回值是<code>0</code>。如果不相同，返回值是<code>-1</code>。如果期望的类型是数组，需要遍历数组，然后把数组中的每个期望类型和传入的类型进行比较，后面详细讲解。</p><p><code>props</code>定义的类型的示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  msg: &#123;</span><br><span class="line">    type: [<span class="built_in">String</span>, <span class="built_in">Number</span>, <span class="built_in">Boolean</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下<code>isSameType</code>函数是怎么比较的，查看它的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 判断类型是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameType</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(a) === getType(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 type 的字符串类型的值，比如 String =&gt; 'String'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = fn &amp;&amp; fn.toString().match(<span class="regexp">/^\s*function (\w+)/</span>)</span><br><span class="line">  <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSameType</code>函数通过调用<code>getType</code>函数获取<code>type</code>字符串类型的值，然后判断它们是否全等。</p><p>我们看下<code>getType</code>函数的代码，它的作用是获取类型的值，JavaScript 的类型（大写的）的值都是类，也就是构造函数，它是一个函数类型的值。这里匹配出函数字符串化后的名称，如果匹配到的话，返回这个函数名；如果匹配不到返回空字符串。比如<code>String</code>类型会返回<code>String</code>字符串类型的值。</p><p>这里为什么要<code>type</code>是字符串类型的名称呢？因为在一些浏览器中，不同<code>iframes</code>之间的相同类型的构造函数名称是不同的。</p><p>继续回到<code>getTypeIndex</code>函数，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 期望的类型是数组时，需要遍历，然后一一比较，返回匹配的类型在数组中的索引</span></span><br><span class="line"><span class="comment">// ! 如果都没有匹配到，返回 -1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = expectedTypes.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isSameType(expectedTypes[i], type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果期望的类型值是一个数组类型，需要遍历数组，获取到数组的每个类型，然后这些类型和传入的类型的值进行比较，如果发现它们全等，就返回期望的类型在数组中的索引。如果遍历之后没有发现值全等的，返回值是<code>-1</code>。</p><p><strong>小结</strong>，<code>getTypeIndex</code>函数就是输入一个类型，然后拿这个类型的值和期望的类型的值（用户定义的）进行比较，看这个类型是不是我们期望的类型（它们的值全等），或者这个类型是不是我们期望的类型之一（包含在期望的类型中）。如果是的话，返回一个大于<code>-1</code>的值。</p><p>了解了<code>getTypeIndex</code>函数的作用后，继续看<code>validateProp</code>函数下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 优先验证 Boolean 类型的值</span></span><br><span class="line"><span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ! 外界没有传值，且没有默认值，</span></span><br><span class="line">  <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">    value = <span class="literal">false</span> <span class="comment">// ! 值为 false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里优先验证 <code>Boolean</code>类型的值，即优先处理是布尔值数据的类型，也就是<code>booleanIndex</code>大于<code>-1</code>时。</p><p>首先判断外界有没有传入值且它有没有设置默认值，如果外界没有传入值，然后它又没有设置默认值，那么就把这个<code>prop</code>数据<code>value</code>设为<code>false</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">propsData: &#123;</span><br><span class="line">  <span class="comment">// ... 外界没有传值</span></span><br><span class="line">&#125;</span><br><span class="line">props: &#123;</span><br><span class="line">  propName: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span> <span class="comment">// 只设置了 Boolean，没有设置默认值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">propName: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 外界传入空字符串 或者 名字由驼峰转连字符后与值为相同字符串 (someProp="some-prop)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">  <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">  <span class="comment">// boolean has higher priority</span></span><br><span class="line">  <span class="keyword">const</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type) <span class="comment">// ! 获取 String 类型的索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 没有定义 String 类型</span></span><br><span class="line">  <span class="comment">// ! 或者 Boolean 类型的索引排在 String 类型的索引前 (类型是数组时 [Boolean String]))</span></span><br><span class="line">  <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">    value = <span class="literal">true</span> <span class="comment">// ! 值为 true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果外界传入的值是一个空的字符串或者传入的值和<code>key</code>转换成连字符的形式后的值相同时，先看下这个<code>prop</code>是否设置了类型是<code>String</code>，尝试获取<code>stringIndex</code>在期望的数组类型中的索引，如果没有获取到<code>stringIndex</code>（说明没有设置），或者获取到了但是<code>booleanIndex</code>索引在<code>stringIndex</code>索引的前面时，把这个<code>prop</code>的值<code>value</code>设置为<code>true</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">propsData: &#123;</span><br><span class="line">  <span class="comment">// propName: '' // 传值一 传进来的值是空字符串</span></span><br><span class="line">  propName: <span class="string">'prop-name'</span> <span class="comment">// 传值二 传进来的值是 'prop-name'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">  propName: &#123;</span><br><span class="line">    <span class="comment">// type: Boolean // 类型一 没有设置 String 类型</span></span><br><span class="line">    type: [<span class="built_in">Boolean</span>, <span class="built_in">String</span>] <span class="comment">// 类型二 没有设置 String 类型，但是 Boolean 排在 String 前面</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">propName: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check default value</span></span><br><span class="line"><span class="comment">// ! 处理 prop 未传值的情况</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  value = getPropDefaultValue(vm, prop, key) <span class="comment">// ! 获取默认值(非响应式)</span></span><br><span class="line">  <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">  <span class="comment">// make sure to observe it.</span></span><br><span class="line">  <span class="keyword">const</span> prevShouldObserve = shouldObserve <span class="comment">// ! 缓存原来的值</span></span><br><span class="line">  toggleObserving(<span class="literal">true</span>) <span class="comment">// ! 不管原来 shouldObserve 是否 true, 这里都先设置为 true</span></span><br><span class="line">  observe(shouldObserve) <span class="comment">// ! 把默认值设为响应式</span></span><br><span class="line">  toggleObserving(prevShouldObserve) <span class="comment">// ! 还原成原先的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>value</code>未定义，也就是外界没有传值，调用<code>getPropDefaultValue</code>函数获取设置的默认值并赋值给<code>value</code>。</p><p>先不管<code>getPropDefaultValue</code>函数的逻辑，继续看下面的代码。</p><p>声明常量<code>prevShouldObserve</code>缓存<code>shouldObserve</code>原先的值，然后调用<code>toggleObserving</code>函数把<code>shouldObserve</code>的值设置为<code>true</code>。然后调用<code>observe</code>函数监听<code>value</code>，把它变成响应式数据，最后把<code>shouldObserve</code>还原成原来的值。</p><p>这里的逻辑就是在外界没有传入值，但是有设置默认值时，把<code>prop</code>的值设置为默认值。</p><h3 id="getPropDefaultValue"><a href="#getPropDefaultValue" class="headerlink" title="getPropDefaultValue"></a><code>getPropDefaultValue</code></h3><p>下面看下<code>getPropDefaultValue</code>函数是怎么获取默认值的，查看它的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropDefaultValue</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: ?Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  prop: PropOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// no default, return undefined</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看下<code>getPropDefaultValue</code>函数的三个参数，分别是实例对象<code>vm</code>，定义的属性<code>prop</code>，以及合并选项后<code>props</code>的<code>key</code>。</p><p>下面看函数体代码，首先判断定义的属性里面有没有设置默认属性<code>default</code>，如果没有，函数返回<code>undefined</code>，也就是说外界没有传入值又没有设置默认值，这时<code>validateProp</code>函数下面的代码是无效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(value) <span class="comment">// observe(undefined) 是无效的</span></span><br></pre></td></tr></table></figure><p>继续看<code>getPropDefaultValue</code>函数下面的代码，在有设置默认值的时候。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> def = prop.default <span class="comment">// ! 获取默认值</span></span><br><span class="line"><span class="comment">// warn against non-factory defaults for Object &amp; Array</span></span><br><span class="line"><span class="comment">// ! 对象和数组类型的默认值必须使用函数返回值，否则会报错</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; isObject(def)) &#123;</span><br><span class="line">  warn(</span><br><span class="line">    <span class="string">'Invalid default value for prop "'</span> +</span><br><span class="line">      key +</span><br><span class="line">      <span class="string">'": '</span> +</span><br><span class="line">      <span class="string">'Props with type Object/Array must use a factory function '</span> +</span><br><span class="line">      <span class="string">'to return the default value.'</span>,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量<code>def</code>存储<code>prop.default</code>的值，即默认值。</p><p>然后在非生产环境下判断<code>def</code>是不是一个非<code>null</code>非<code>undefined</code>的普通对象，如果是的话报错，提示对象和数组类型的<code>prop</code>的默认值必须使用函数的返回值。因为<code>prop</code>的默认值只能是原始类型或者函数类型。</p><p>实例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'Hale'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  info: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  vm &amp;&amp;</span><br><span class="line">  vm.$options.propsData &amp;&amp;</span><br><span class="line">  vm.$options.propsData[key] === <span class="literal">undefined</span> &amp;&amp; <span class="comment">// ! 此时，外界还没传值</span></span><br><span class="line">  vm._props[key] !== <span class="literal">undefined</span> <span class="comment">// ! 已经定义非 undefined 的默认值</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> vm._props[key] <span class="comment">// ! 返回上次的默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上一次数组更新或者创建时外界没有给该组件传值且组件存在非<code>undefined</code>的默认值时，返回之前的值（默认值），而不用重新再去获取。</p><p>这样可以避免触发无意义的响应，因为默认值如果是一个通过函数创建的对象，那么每次都会重新获取新生成的对象，虽然对象的引用和以前的不一样，但是它们的值是一样的，这样导致页面也没有变化。所以每次都去获取新的引用类型的默认值就没有任何意义，而且还会损耗性能。</p><p>继续看<code>getPropDefaultValue</code>函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 默认值是函数类型，但是要求的类型不为 Function（类型是数组或者对象） 时需要求值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> def === <span class="string">'function'</span> &amp;&amp; getType(prop.type) !== <span class="string">'Function'</span></span><br><span class="line">  ? def.call(vm)</span><br><span class="line">  : def</span><br></pre></td></tr></table></figure><p>如果默认值是函数类型，但是它期望的类型不是<code>Function</code>类型，说明这是数组或者对象的默认值，需要对默认的函数进行求值获取返回的值。</p><p>如果默认值是函数类型，而它要求的类型也是<code>Funtion</code>类型，说明这个<code>prop</code>的类型就是函数函数，不需要对默认值函数进行求值。</p><p>回到<code>validateProp</code>函数，继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 验证类型，只有在非生产环境进行，且跳过 WEEX 环境的某种判断</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// skip validation for weex recycle-list child component props</span></span><br><span class="line">  !(__WEEX__ &amp;&amp; isObject(value) &amp;&amp; <span class="string">'@binding'</span> <span class="keyword">in</span> value)</span><br><span class="line">) &#123;</span><br><span class="line">  assertProp(prop, key, value, vm, absent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>如果在非生产环境中且在<code>WEEX</code>的某种环境中，使用<code>assertProp</code>函数验证<code>prop</code>的类型。</p><p>这里才是真正开始校验<code>prop</code>的类型。前面的代码都不算验证类型，只是在<code>prop</code>是布尔类型时，设置合理的布尔值以及获取<code>prop</code>的默认值。</p><h3 id="assertProp"><a href="#assertProp" class="headerlink" title="assertProp"></a><code>assertProp</code></h3><p>下面看下<code>assertProp</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertProp</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prop: PropOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  value: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: ?Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  absent: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看下函数的五个参数。</p><ol><li><code>prop</code>：定义<code>prop</code>的属性。</li><li><code>name</code>：遍历合并选项后的<code>props</code>选项的<code>key</code>，就是<code>prop</code>的名称。</li><li><code>value</code>：外界传入的值，也就是<code>prop</code>的值。</li><li><code>vm</code>：实例对象。</li><li><code>absent</code>：外界是否传入值，为<code>true</code>表示没有传入值。</li></ol><p>下面看下函数体的代码，<strong>注意</strong><code>assertProp</code>函数是验证<code>prop</code>类型的函数，只有在非生产环境中才会执行，验证类型如果不通过会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 有 required 时必须传数据，否则报错</span></span><br><span class="line"><span class="keyword">if</span> (prop.required &amp;&amp; absent) &#123;</span><br><span class="line">  warn(<span class="string">'Missing required prop: "'</span> + name + <span class="string">'"'</span>, vm)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>如果定义的属性中设置了<code>required</code>为<code>true</code>，但是外界没有传入值，会报错，提示没有要求的<code>prop</code>值。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 非必需传数据且值为 null 或者 undefined 时，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; !prop.required) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义的属性中没有设置<code>require</code>的值（这时<code>required</code>的值是<code>undefined</code>），而且外界传入的值是<code>null</code>或者<code>undefined</code>时，直接返回，不需要验证。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 判断类型是否与期望相符</span></span><br><span class="line"><span class="keyword">let</span> type = prop.type <span class="comment">// ! 获取类型</span></span><br><span class="line"><span class="keyword">let</span> valid = !type || type === <span class="literal">true</span> <span class="comment">// ! 没有设置类型或者类型的值为 true 时，不需要校验，直接判定为 true</span></span><br><span class="line"><span class="keyword">const</span> expectedTypes = [] <span class="comment">// ! 期望类型的集合</span></span><br><span class="line"><span class="keyword">if</span> (type) &#123;</span><br><span class="line">  <span class="comment">// ! 数组类型</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(type)) &#123;</span><br><span class="line">    type = [type]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 遍历数组的所有类型，并验证每一种类型, 当出现一种类型验证失败后 即 !valid 时，循环结束</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; type.length &amp;&amp; !valid; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> assertedType = assertType(value, type[i]) <span class="comment">// ! 类型验证的返回值</span></span><br><span class="line">    expectedTypes.push(assertedType.expectedType || <span class="string">''</span>) <span class="comment">// ! 把返回放入到数组中，后面统一处理</span></span><br><span class="line">    valid = assertedType.valid <span class="comment">// ! 本次循环验证的结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断外界传入的值的类型是否和用户定义（期望）的类型相同。</p><p>定义变量<code>type</code>存储用户定义的类型。定义变量<code>valid</code>，它是一个布尔值，当用户没有定义类型或者定义的类型的值是<code>true</code>时，遍历<code>valid</code>的值为<code>ture</code>，这同时也是它的初始值。定义常量<code>expectedTypes</code>存储类型验证的结果组成集合，初始值为空数组。</p><p>先判断是否存在定义的类型，如果存在，继续下面的逻辑。判断定义的类型是不是一个数组，如果不是数组，把它包装成一个数组。如果已经是一个数组了，遍历这个数组，验证数组中的每一种类型，如果出现验证任意一种类型失败的情况，循环结束。</p><p>声明常量<code>assertedType</code>存储通过调用<code>assertType</code>函数验证<code>prop</code>类型的返回值。这里先不管<code>assertType</code>函数是怎么验证类型的，继续看下面的逻辑。把验证后的返回值<code>assertedType</code>的<code>expectedType</code>属性放入到<code>expectedTypes</code>数组中，如果<code>expectedTypes</code>属性没有值，返回空字符串。</p><p>最后设置变量<code>valid</code>的值，它的值是每次循环时，验证的返回值<code>assertedType</code>的<code>valid</code>属性，这个属性表示本次循环时验证是否成功，如果验证成功则继续循环，进行下一轮验证；如果验证失败，即<code>valid</code>的值为<code>false</code>时，结束循环。</p><p>到了这里大概可以猜出验证函数的返回值<code>assertedType</code>是什么样子了，它应该是一个对象，至少有两个属性，分别是<code>expectedType</code>和<code>valid</code>。<code>expectedType</code>的值应该就是期望的类型，比如<code>String</code>、<code>Boolean</code>等，它是值是函数类型；而<code>valid</code>的值应该是个布尔值。</p><h3 id="assertType"><a href="#assertType" class="headerlink" title="assertType"></a><code>assertType</code></h3><p>下面就看下<code>assertType</code>函数的代码，这个函数是具体验证类型的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertType</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  value: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  valid: boolean,</span><br><span class="line">  expectedType: string</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下它的两个参数，分别是<code>prop</code>传入的值<code>value</code>，和我们定义的类型<code>type</code>，<code>type</code>是一个函数。</p><p>下面看下函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> valid</span><br><span class="line"><span class="keyword">const</span> expectedType = getType(type) <span class="comment">// ! 获取期待的类型</span></span><br></pre></td></tr></table></figure><p>声明变量<code>valid</code>，它是一个布尔值，也是函数的一个返回值，表示本次验证类型是否通过。</p><p>声明常量<code>expectedType</code>存储字符串类型的<code>type</code>。因为我们传入的参数<code>type</code>的值是一个函数类型的值，需要把它的值转换成函数名，也就是字符串类型，理由在前面已经讲过了。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type1 = <span class="built_in">String</span> <span class="comment">// String 是函数类型</span></span><br><span class="line">getType(type1) <span class="comment">// 'String' 是字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> type2 = <span class="built_in">Boolean</span> <span class="comment">// Boolean 是函数类型</span></span><br><span class="line">getType(type2) <span class="comment">// 'Boolean' 是字符串类型</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 可通过 typeof 来验证的数据类型</span></span><br><span class="line"><span class="keyword">if</span> (simpleCheckRE.test(expectedType)) &#123;</span><br><span class="line">  <span class="keyword">const</span> t = <span class="keyword">typeof</span> value <span class="comment">// ! t 的值是字符串小写</span></span><br><span class="line">  valid = t === expectedType.toLowerCase() <span class="comment">// ! 验证类型</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断正则表达式<code>simpleCheckRE</code>是否和期望的类型<code>expectedType</code>匹配，如果匹配，继续下面的逻辑。</p><p>先看下正则表达式<code>simpleCheckRE</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 可通过 typeof 来验证的数据类型正则</span></span><br><span class="line"><span class="keyword">const</span> simpleCheckRE = <span class="regexp">/^(String|Number|Boolean|Function|Symbol)$/</span></span><br></pre></td></tr></table></figure><p>上面这些都是可以通过<code>typeof</code>来判断的类型，比如<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Function</code>、<code>Symbol</code>。</p><p>声明变量<code>t</code>存储通过<code>typeof</code>获取的外界传入的数据<code>value</code>的类型。然后比较<code>t</code>和期望的类型<code>expectedType</code>是否相同。因为这里的<code>expectedType</code>是首字母大写的，在比较前需要把它转换成小写的，然后把比较结果赋值给变量<code>valid</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">'value'</span> <span class="comment">// 'string'</span></span><br><span class="line">expectedType = <span class="string">'String'</span></span><br><span class="line">expectedType.toLowerCase() <span class="comment">// 'string'</span></span><br><span class="line">valid = <span class="string">'value'</span> ==== type.toLowerCase()</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for primitive wrapper objects</span></span><br><span class="line"><span class="comment">// ! 包装类型的验证，验证原型，比如 const str = new String('123')，str 是 String 的实例对象</span></span><br><span class="line"><span class="keyword">if</span> (!valid &amp;&amp; t === <span class="string">'object'</span>) &#123;</span><br><span class="line">  valid = value <span class="keyword">instanceof</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的比较结果是<code>false</code>，即不相同，再判断<code>t</code>的值是不是<code>object</code>，如果是的话，说明传入的值<code>value</code>是一个包装类型的值，需要判断这个值的原型，调用<code>instanceof</code>判断<code>value</code>的原型是不是<code>type</code>，最后把比较结果赋值给<code>valid</code>变量。</p><p>什么是包装类型？看下面的示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'1'</span> <span class="comment">// 原始类型</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>) <span class="comment">// 包装类型</span></span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// 'object'</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expectedType === <span class="string">'Object'</span>) &#123;</span><br><span class="line">  valid = isPlainObject(value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 数组验证</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expectedType === <span class="string">'Array'</span>) &#123;</span><br><span class="line">  valid = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当期望的类型是对象<code>Object</code>时，使用<code>isPlainObject</code>方法验证传入的值<code>value</code>的类型，并把验证结果赋值给变量<code>valid</code>。</p><p>当期望的类型是数组<code>Array</code>时，使用<code>Array.isArray</code>方法验证传入的值<code>value</code>的类型，并把验证结果赋值给变量<code>valid</code>。</p><p>继续看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 其他验证 =&gt; 自定义类型 (原型验证)</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  valid = value <span class="keyword">instanceof</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果期望类型即不是可以通过<code>typeof</code>判断的类型，也不是数组对象，那么这个值可能是一个自定义的类型，使用<code>instanceof</code>判断传入的值<code>vlaue</code>的原型是不是自定义的类型<code>type</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.nane = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'Hale'</span>, <span class="number">18</span>)</span><br><span class="line">p <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>最后函数返回的一个对象，这个对象包含两个属性。</p><ul><li><code>valid</code>：验证的结果，是一个布尔值。</li><li><code>expectedType</code>：定义（期望）的类型，是一个字符串。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 返回验证结果和期望的类型</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  valid,</span><br><span class="line">  expectedType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解<code>assertType</code>函数的代码后，我们知道了类型是怎么验证的。</p><p>再次回到<code>assertProp</code>函数中，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 当验证失败时报错</span></span><br><span class="line"><span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">  warn(getInvalidTypeMessage(name, value, expectedTypes), vm)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类型验证失败后，也就是<code>valid</code>的值是<code>false</code>时，会报错。</p><p>继续看<code>assertProp</code>函数剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 自定义验证</span></span><br><span class="line"><span class="keyword">const</span> validator = prop.validator <span class="comment">// ! 获取用户自定义的验证器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 把 value 作为参数传入并执行自定义验证器，</span></span><br><span class="line"><span class="comment">// ! 当它返回值为 false 时，验证失败，报错</span></span><br><span class="line"><span class="keyword">if</span> (validator) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!validator(value)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Invalid prop: custom validator check failed for prop "'</span> + name + <span class="string">'".'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了提高验证<code>JavaScript</code>的内置类型和自定义类型，<code>props</code>还提供了自定义验证。它不是验证值的类型，而是验证代码逻辑，即用户自定义的逻辑。</p><p>自定义验证让用户声明一个函数，然后把外界传入的值作为参数传入到函数中进行验证。</p><p>声明常量<code>validator</code>存储获取到的用户自定义的验证器，先判断自定义验证器是否存在，如果存在，把外界传入的值<code>value</code>作为参数传入到验证器函数中执行，如果验证器函数返回值是<code>true</code>，说明验证成功，不用进行其他操作；如果返回值是<code>false</code>，说明验证失败，然后报错。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">propsData: &#123;</span><br><span class="line">  list: [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">  list: &#123;</span><br><span class="line">    validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value.includes(<span class="string">'apple'</span>) <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，<code>props</code>选项的验证的代码就全部讲解完成，<code>props</code>选项的初始化也讲解完成。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面章节通过初始化&lt;code&gt;data&lt;/code&gt;选项的&lt;code&gt;initData&lt;/code&gt;函数讲解了 Vue 的响应式系统。&lt;/p&gt;
&lt;p&gt;下面继续讲解&lt;code&gt;props&lt;/code&gt;选项的初始化。&lt;/p&gt;
&lt;h2 id=&quot;props的初始化&quot;&gt;&lt;a href=&quot;#props的初始化&quot; class=&quot;headerlink&quot; title=&quot;props的初始化&quot;&gt;&lt;/a&gt;&lt;code&gt;props&lt;/code&gt;的初始化&lt;/h2&gt;&lt;p&gt;回到&lt;code&gt;initState&lt;/code&gt;函数，查看初始化&lt;code&gt;props&lt;/code&gt;选项的代码，在&lt;code&gt;core/instance/state.js&lt;/code&gt;文件中&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.props) initProps(vm, opts.props)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通过调用&lt;code&gt;initProps&lt;/code&gt;函数初始化&lt;code&gt;props&lt;/code&gt;选项，还需要传入实例对象&lt;code&gt;vm&lt;/code&gt;和合并选项后的&lt;code&gt;props&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;下面看下&lt;code&gt;initProps&lt;/code&gt;函数的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initProps&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;vm: Component, propsOptions: Object&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; propsData = vm.$options.propsData || &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// ! 获取 props 数据来源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; props = (vm._props = &amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// cache prop keys so that future props updates can iterate using Array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// instead of dynamic object key enumeration.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; keys = (vm.$options._propKeys = [])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; isRoot = !vm.$parent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;声明常量&lt;code&gt;propsData&lt;/code&gt;存储&lt;code&gt;vm.$options.propsData&lt;/code&gt;属性，这是外界传进来的&lt;code&gt;props&lt;/code&gt;数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之计算属性</title>
    <link href="https://haledeng.com/blog/20190926-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>https://haledeng.com/blog/20190926-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</id>
    <published>2019-09-26T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:21.325Z</updated>
    
    <content type="html"><![CDATA[<p>下面看下 Vue 的计算属性的实现，计算属性收集依赖和触发依赖的方式和普通的响应式数据是不一样的。</p><p>回到<code>initState</code>函数中，在<code>core/instance/state.js</code>文件中，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br></pre></td></tr></table></figure><p>如果设置了<code>computed</code>选项，就调用<code>initComputed</code>初始化选项。</p><h2 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a><code>initComputed</code></h2><p>看下<code>initComputed</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 初始化计算属性选项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = (vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)) <span class="comment">// ! 维护一个常量存储计算属性</span></span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明一个常量<code>watchers</code>存储<code>vm._computedWatchers</code>属性，默认值是空对象，<code>vm._computedWatchers</code>属性存储实例对象的计算属性观察者。</p><a id="more"></a><p>声明常量<code>isSSR</code>存储<code>isServerRendering</code>函数的执行结果，即判断当前的环境是不是服务端渲染。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 遍历计算属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">  <span class="keyword">const</span> userDef = computed[key] <span class="comment">// ! 获取每个计算属性的函数或者对象</span></span><br><span class="line">  <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get <span class="comment">// ! 获取 getter</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 计算属性没有 getter 发出警告</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">    warn(<span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>, vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历计算属性选项<code>computed</code>，声明常量<code>userDef</code>存储每一个计算属性。</p><p>声明常量<code>getter</code>存储计算属性的<code>getter</code>，首先判断<code>userDef</code>是不是函数类型，如果是的话，直接赋值；如果不是的话，把它的<code>get</code>属性赋值给<code>getter</code>。</p><p>如果获取到的<code>getter</code>不存在，在非生产环境中会报错，警告计算属性缺少<code>getter</code>值。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">  <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">  <span class="comment">// ! 创建计算属性的观察者</span></span><br><span class="line">  watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    getter || noop,</span><br><span class="line">    noop,</span><br><span class="line">    computedWatcherOptions <span class="comment">// ! 计算属性选项 &#123; lazy: true &#125;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是服务端渲染，创建计算属性的观察者，并把它存储到<code>watchers</code>中，观察者对应的名称就是<code>key</code>。</p><p>其中传入上面获取的<code>getter</code>作为第二个参数<code>expOrFn</code>传入，如果没有<code>getter</code>就传入一个空函数。</p><p>第四个参数<code>options</code>传入的是常量<code>computedWatcherOptions</code>，它的值是<code>{ lazy: true }</code>。</p><p>继续看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">  defineComputed(vm, key, userDef) <span class="comment">// ! 实现计算属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 如果计算属性名称在 data 和 props 被使用了，发出警告</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">    warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">    warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断计算属性的<code>key</code>是否存在组件实例中，如果不存在，使用<code>defineComputed</code>函数把计算属性代理到实例中，并且把它变成响应式数据。</p><p>另外，判断计算属性的<code>key</code>是否存在于<code>data</code>或者<code>props</code>选项中，如果存在，在非生产环境中会报错，提示计算属性的<code>key</code>值已经被占用了。</p><h2 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a><code>defineComputed</code></h2><p>下面看下<code>defineComputed</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 实现计算属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering() <span class="comment">// ! 是否为服务端渲染，服务端渲染不需要缓存</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量<code>shouldCache</code>，它表示是否是需要缓存，它的值和服务端渲染互斥，因为服务端渲染不需要缓存。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 计算属性是函数时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">  sharedPropertyDefinition.get = shouldCache</span><br><span class="line">    ? createComputedGetter(key) <span class="comment">// ! 创建计算属性的 getter</span></span><br><span class="line">    : createGetterInvoker(userDef)</span><br><span class="line">  sharedPropertyDefinition.set = noop <span class="comment">// ! setter 为空函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取的计算属性<code>userDef</code>是函数时，调用<code>createComputedGetter</code>函数创建计算属性的<code>gettter</code>，否则调用<code>createGetterInvoker</code>函数创建计算属性的<code>gettter</code>，这两个方法创建的<code>getter</code>是不一样的，最后把<code>getter</code>赋值给<code>sharedPropertyDefinition</code>的<code>get</code>属性。</p><p>因为用户定义的计算属性是函数时是没有<code>setter</code>的，所以<code>sharedPropertyDefinition</code>对象的<code>set</code>为空函数。</p><p>看下<code>sharedPropertyDefinition</code>对象的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个对象，用来设置<code>Object.defineProperty</code>中的属性描述符，<code>get</code>和<code>set</code>初始值是空函数，需要后面进行重写。</p><p>下面看下<code>createComputedGetter</code>函数和<code>createGetterInvoker</code>函数是怎么创建<code>getter</code>函数的。</p><h3 id="createComputedGetter"><a href="#createComputedGetter" class="headerlink" title="createComputedGetter"></a><code>createComputedGetter</code></h3><p>先看<code>createComputedGetter</code>函数的代码，这里传入的参数是<code>key</code>，它是字符串类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 创建计算属性 getter 的函数，需要根据 dirty 更新值和收集依赖</span></span><br><span class="line"><span class="comment">// ! 返回一个新的 computedGetter 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key] <span class="comment">// ! 获取计算属性观察者</span></span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// ! 如果 dirty 为 true 时，表示计算属性观察者可以执行更新</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate() <span class="comment">// ! 调用 evaluate 更新计算属性的值</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>getter</code>是一个函数，所以这里也返回一个函数。</p><p>先尝试通过<code>key</code>值在<code>vm._computedWatchers</code>中获取到我们定义的计算属性观察者，如果能获取到，判断观察者对象的<code>dirty</code>属性是不是<code>true</code>，如果是的话，说明这个计算属性观察者可以执行更新，然后调用观察者的<code>evaluate</code>方法更新计算属性的值。</p><p>看下<code>evaluate</code>方法的代码，在<code>core/observer/watcher.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evaluate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// ! 获取计算属性的新值，并触发它所依赖的响应式对象收集这个计算属性观察者</span></span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span> <span class="comment">// ! 更新计算属性的值后重新设置为 false，这时再次访问计算属性时，它就不会再求值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>get</code>方法获取新值，因为<code>get</code>方法中会调用<code>this.getter</code>的方法，也就是我们创建观察者时传入的第二个参数，这样就会重新求值，在求值的过程中会访问到计算属性依赖的那个响应式数据，并触发这个数据收集当前的计算属性观察者作为依赖。</p><p>最后重新将<code>dirty</code>设置为<code>false</code>，这时候，如果再次访问计算属性，就不会再调用<code>evaluate</code>更新计算属性的值。因为计算属性依赖的响应式数据没有更新值，重新求值也还是和以前的值一样，浪费性能。只有在计算属性观察者所依赖的响应性数据更新时，才会触发计算属性观察者的<code>update</code>方法，把<code>dirty</code>重新设置为<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>createComputedGetter</code>函数下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  watcher.depend() <span class="comment">// ! 计算属性收集依赖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> watcher.value</span><br></pre></td></tr></table></figure><p>判断<code>Dep.target</code>是否有值，如果有值，计算属性观察者收集依赖，这里才是计算属性本身收集依赖，是通过它的观察者来收集依赖的。最后返回观察者对象的<code>value</code>值，即上面<code>evaluate</code>获取的值。</p><h3 id="createGetterInvoker"><a href="#createGetterInvoker" class="headerlink" title="createGetterInvoker"></a><code>createGetterInvoker</code></h3><p>下面看下<code>createGetterInvoker</code>函数的代码，它是创建服务器渲染时的<code>getter</code>。</p><p>它的参数是一个函数，如果<code>userDef</code>是函数，直接传入它。如果<code>userDef</code>是对象，传入的是<code>userDef.get</code>属性，也就是<code>getter</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 创建计算属性调用钩子函数，自己调用函数，用于服务端渲染中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetterInvoker</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端渲染中创建的<code>getter</code>，也是返回一个函数。但是这里不用收集依赖和处理<code>dirty</code>属性，而是直接调用传入的<code>getter</code>函数。</p><p>下面看下<code>defineComputed</code>是如何处理计算属性是对象类型的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 计算属性是对象时</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  sharedPropertyDefinition.get = userDef.get</span><br><span class="line">    ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef.get)</span><br><span class="line">  : noop</span><br><span class="line">  sharedPropertyDefinition.set = userDef.set || noop <span class="comment">// ! setter 为 set 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断<code>userDef</code>是否存在<code>get</code>属性，如果不存在，<code>sharedPropertyDefinition.get</code>为空函数。如果存在，再判断<code>shouldCache</code>是否为真且用户没有定义过<code>cache</code>属性为假时，调用<code>createComputedGetter</code>函数创建<code>getter</code>，否则调用<code>createGetterInvoker</code>函数创建<code>getter</code>，这里传入的参数是<code>userDef.get</code>。</p><p>这两个函数在前面已经讲解过了，这里就不在赘述了。</p><p>因为<code>userDef</code>是对象，里面一般是有<code>set</code>属性的，如果有<code>set</code>属性，直接赋值给<code>sharedPropertyDefinition.set</code>的属性，否则赋值为空函数。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">  sharedPropertyDefinition.set === noop</span><br><span class="line">) &#123;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition) <span class="comment">// ! 把计算属性代理到实例对象中</span></span><br></pre></td></tr></table></figure><p>在非生产环境中，如果<code>sharedPropertyDefinition.set</code>的值经过上面的逻辑之后还是一个空函数，也就是说用户没有设置<code>setter</code>。这时会把<code>sharedPropertyDefinition.set</code>赋值成一个警告函数，当你修改计算属性的值时，会提醒你这个计算属性没有设置<code>setter</code>，不能修改它的值。</p><p>最后使用<code>Object.defineProperty</code>定义<code>target</code>的<code>key</code>，而它的属性描述符就是上面代码中的定义的<code>sharedPropertyDefinition</code>对象，这里的<code>target</code>就是 Vue 的实例对象，把计算属性代理到实例对象中。</p><p>使用计算属性示例代码，这里使用官方文档的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性是函数，这个函数必须有返回值，是一个 getter</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性是对象，这个对象里面一般是 getter 和 setter</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算属性和普通属性的差异"><a href="#计算属性和普通属性的差异" class="headerlink" title="计算属性和普通属性的差异"></a>计算属性和普通属性的差异</h2><p>这里比较一下<strong>计算属性和普通属性的差异</strong></p><h3 id="普通属性收集依赖"><a href="#普通属性收集依赖" class="headerlink" title="普通属性收集依赖"></a>普通属性收集依赖</h3><p>普通属性是在创建观察者实例对象时收集依赖的。在创建观察者的过程中，会执行观察者的构造函数方法，构造函数方法的最后会调用<code>get</code>方法获取观察目标的值，获取值的同时会触发观察目标的<code>getter</code>，<code>getter</code>就会把观察者收集到<code>dep</code>中。</p><h3 id="计算属性收集依赖"><a href="#计算属性收集依赖" class="headerlink" title="计算属性收集依赖"></a>计算属性收集依赖</h3><p>计算属性不是在创建观察者实例的过程中收集依赖。</p><p>在创建计算属性观察者时，会传入一个选项<code>options</code>，它的值是<code>{ lazy: true }</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  getter || noop,</span><br><span class="line">  noop,</span><br><span class="line">  computedWatcherOptions <span class="comment">// ! 计算属性选项 &#123; lazy: true &#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后在观察者的构造函数的最后一行代码中，会判断<code>this.lazy</code>的值是否为<code>true</code>，如果为<code>true</code>，不会调用<code>get</code>函数获取值和收集依赖，而是返回一个<code>undefined</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</span><br></pre></td></tr></table></figure><p>那计算属性什么时候收集依赖呢？其实是在访问计算属性的时候收集依赖的。</p><p>看下它在非服务端渲染时是怎么创建<code>getter</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key] <span class="comment">// ! 获取计算属性观察者</span></span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// ! 如果 dirty 为 true 时，表示计算属性的依赖已经更新，现在可以更新计算属性的值</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate() <span class="comment">// ! 调用 evaluate 更新计算属性的值</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend() <span class="comment">// ! 计算属性收集依赖</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value <span class="comment">// ! 返回计算属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取到计算属性的观察者，然后判断观察者的<code>dirty</code>属性的值是否为真，如果为真，说明计算属性的所依赖的响应式数据已经更新，然后调用观察者的<code>evaluate</code>方法更新观察者的值，也就是更新计算属性的值。然后判断<code>Dep.target</code>是否有值，如果有值的话，调用观察者的<code>depend</code>收集依赖。</p><h3 id="计算属性的值的更新"><a href="#计算属性的值的更新" class="headerlink" title="计算属性的值的更新"></a>计算属性的值的更新</h3><p>我们看下<code>evaluate</code>是如何更新计算属性的值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evaluate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// ! 获取计算属性的新值，并触发它所依赖的响应式对象收集这个计算属性观察者</span></span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span> <span class="comment">// ! 更新计算属性的值后重新设置为 false，这时再次访问计算属性时，它就不会再求值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是调用观察者的<code>get</code>方法来更新值，更新后重新把<code>this.dirty</code>设置为<code>false</code>。之后，再访问计算属性后，就不会执行<code>evaluate</code>求值了，因为它的值还是一样的。</p><p>只有在它所依赖的响应式对象发现变化时，触发计算属性观察者的<code>update</code>函数，把<code>dirty</code>设置为<code>true</code>。这时候再访问计算属性，它就会调用<code>evaluate</code>方法重新求值。</p><p><strong>小结</strong>：计算属性不但是收集依赖是在访问属性的时候，更新值也是在访问属性的时候。</p><h2 id="计算属性的更新流程"><a href="#计算属性的更新流程" class="headerlink" title="计算属性的更新流程"></a>计算属性的更新流程</h2><p>在初始化<code>computed</code>选项的时候，创建计算属性的观察者，并传入选项<code>options</code>，它的值为<code>{ lazy: true }</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  getter || noop,</span><br><span class="line">  noop,</span><br><span class="line">  computedWatcherOptions <span class="comment">// ! 计算属性选项 &#123; lazy: true &#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在创建过程中会执行观察者的构造函数的代码，在代码最后一行是下面这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</span><br></pre></td></tr></table></figure><p>所以计算属性创建之后没有求值，它的值是<code>undefiend</code>。</p><p>只有在我们访问计算属性的时候，触发它的<code>getter</code>，它才会求值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key] <span class="comment">// ! 获取观察者</span></span><br><span class="line">  <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">    <span class="comment">// ! 如果 dirty 为 true 时，表示计算属性观察者可以更新</span></span><br><span class="line">    <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">      watcher.evaluate() <span class="comment">// ! 调用 evaluate 更新计算属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      watcher.depend() <span class="comment">// ! 计算属性收集依赖</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watcher.value <span class="comment">// ! 返回计算属性的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求值也有条件的，这也是计算属性性能好的地方。</p><p>什么条件？就是计算属性观察者的<code>ditry</code>属性必须为<code>true</code>。</p><p>在我们创建计算属性观察者的时候，<code>dirty</code>属性的值和传进来的<code>lazy</code>值相同的，它的值为<code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line"><span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br></pre></td></tr></table></figure><p>所以初始化<code>computed</code>选项后，里面的计算属性都有一次求值机会，看下<code>evaluate</code>函数代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evaluate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// ! 获取计算属性的新值，并触发它所依赖的响应式对象收集这个计算属性观察者</span></span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span> <span class="comment">// ! 更新计算属性的值后重新设置为 false，这时再次访问计算属性时，它就不会再求值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>get</code>方法更新计算属性的值，同时会触发它所依赖的响应式对象收集这个计算属性观察者。更新计算属性的值之后，会重新把<code>dirty</code>属性设置为<code>false</code>。之后，我们再次访问计算属性时，因为<code>dirty</code>的值为<code>false</code>就不会通过观察者函数的<code>evaluate</code>方法重写求值。</p><p>因为计算属性的更新值是在访问它的时候，不可能每次访问都去求值，这会非常影响性能。所以每次访问的时候，如果它所依赖的响应性数据没有更新，计算属性就一直是那个值。</p><p>那什么时候计算属性的值会更新呢？只在它所依赖的响应性对象发现变化后才会更新。这又是什么原理呢？</p><p>因为计算属性观察者已经是计算属性所依赖的响应式数据的依赖，当这个数据发生更新时，会触发<code>setter</code>，执行所有的依赖更新，这包括了这个计算属性观察者的更新，观察者更新是会调用<code>update</code>方法的，而<code>update</code>方法前面的代码会把<code>dirty</code>属性重新设置为<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update() &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="comment">// ! 如果启动懒惰模式  =&gt; 更新 dirty 为 true，说明可以更新计算属性的值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为计算属性观察者的<code>lazy</code>属性是<code>true</code>，所以这里设置<code>dirty</code>为<code>true</code>。</p><p>然后，你再访问计算属性时，触发它的<code>getter</code>，此时<code>dirty</code>的值为<code>true</code>，就会调用<code>evaluate</code>函数更新计算属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// ! 如果 dirty 为 true 时，表示计算属性观察者可以更新</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate() <span class="comment">// ! 调用 evaluate 更新计算属性的值</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> watcher.value <span class="comment">// ! 返回计算属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evaluate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面看下 Vue 的计算属性的实现，计算属性收集依赖和触发依赖的方式和普通的响应式数据是不一样的。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;initState&lt;/code&gt;函数中，在&lt;code&gt;core/instance/state.js&lt;/code&gt;文件中，看下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.computed) initComputed(vm, opts.computed)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果设置了&lt;code&gt;computed&lt;/code&gt;选项，就调用&lt;code&gt;initComputed&lt;/code&gt;初始化选项。&lt;/p&gt;
&lt;h2 id=&quot;initComputed&quot;&gt;&lt;a href=&quot;#initComputed&quot; class=&quot;headerlink&quot; title=&quot;initComputed&quot;&gt;&lt;/a&gt;&lt;code&gt;initComputed&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;看下&lt;code&gt;initComputed&lt;/code&gt;函数的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ! 初始化计算属性选项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initComputed&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;vm: Component, computed: Object&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// $flow-disable-line&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; watchers = (vm._computedWatchers = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// ! 维护一个常量存储计算属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// computed properties are just getters during SSR&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; isSSR = isServerRendering()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先声明一个常量&lt;code&gt;watchers&lt;/code&gt;存储&lt;code&gt;vm._computedWatchers&lt;/code&gt;属性，默认值是空对象，&lt;code&gt;vm._computedWatchers&lt;/code&gt;属性存储实例对象的计算属性观察者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之侦听器</title>
    <link href="https://haledeng.com/blog/20190925-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <id>https://haledeng.com/blog/20190925-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BE%A6%E5%90%AC%E5%99%A8/</id>
    <published>2019-09-25T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:16.767Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 给我们提供了侦听器方法<code>vm.$watch</code>和选项<code>watch</code>，用来观察 Vue 实例变化，然后执行一些操作。</p><p>下面看下它们是怎么实现的，其实它们都是基于观察者<code>watcher</code>的封装。</p><h2 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a><code>vm.$watch</code></h2><p>先看<code>Vue.prototype.$watch</code>方法的代码，在<code>core/instance/state.js</code>文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看下<code>$watch</code>方法的参数，有三个参数，分别是<code>expOrFn</code>、<code>cb</code>和<code>options</code>，我们发现这三个参数对应着<code>Watcher</code>构造函数的第二个到第四个参数。</p><a id="more"></a><p>继续看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! cb 是对象，调用 createWatcher 方法</span></span><br><span class="line"><span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">  <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>声明常量<code>vm</code>存储当前的实例对象，即<code>this</code>。然后判断<code>cb</code>是不是一个普通对象，如果是的话，调用<code>createWatcher</code>函数，传入<code>vm</code>以及<code>$watch</code>原来的三个参数。</p><h3 id="createWatcher"><a href="#createWatcher" class="headerlink" title="createWatcher"></a><code>createWatcher</code></h3><p>先看下<code>createWatcher</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 创建 watcher 的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 传入的 handler 是对象时</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler <span class="comment">// ! 获取对象里的 handler 方法作为 cb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 传入的 handler 是字符串时  =&gt; watch: &#123; name: 'cbName' &#125;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler] <span class="comment">// ! 获取相同名字的函数作为 cb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options) <span class="comment">// ! 最后调用实例的 $watch 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要处理在<code>$watch</code>方法中传入的<code>cb</code>参数不是函数的情况，它的第三个参数<code>handler</code>对应<code>$watch</code>的第三个参数<code>cb</code>。</p><p>这里再次判断<code>handler</code>是不是一个普通对象，如果是的话，函数的第四个参数<code>options</code>缓存第三个参数<code>handler</code>的值，而第三个参数<code>handler</code>的值为它的<code>handler</code>属性，即回调函数。</p><p>然后判断<code>handler</code>是不是字符串，如果是的话，<code>handler</code>的值为实例对象的<code>handler</code>属性，即去实例对象获取名为<code>handler</code>的方法作为回调函数。</p><p>最后再次调用<code>vm.$watch</code>方法，并把<code>handler</code>作为函数的第二个参数即回调函数<code>cb</code>传入。</p><p><strong>小结</strong>，<code>createWatcher</code>函数就是通过不是函数类型的<code>cb</code>得到函数类型的<code>handler</code>，然后再次调用<code>vm.$watch</code>方法。经过这个方法处理后，<code>vm.$watch</code>方法的第三个参数<code>cb</code>就一定是函数。</p><p>然后又回到<code>wm.$watch</code>方法中，继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">options = options || &#123;&#125;</span><br><span class="line">options.user = <span class="literal">true</span> <span class="comment">// ! 设置 user 为 true，说明是用户自定义的观察者</span></span><br><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options) <span class="comment">// ! 创建观察者实例，并传入设置的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 如果设置了 immediate</span></span><br><span class="line"><span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    cb.call(vm, watcher.value) <span class="comment">// ! 先立即执行一次回调函数</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    handleError(</span><br><span class="line">      error,</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">`callback for immediate watcher "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  watcher.teardown() <span class="comment">// ! 移除 watcher</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新定义<code>options</code>为传入的<code>options</code>参数或者是一个空对象（没传入参数）。</p><p>设置<code>options.user</code>属性为<code>true</code>，说明下面创建的观察者对象是用户定义的观察者，然后通过<code>new</code>创建一个观察者实例对象，把当前的组件实例<code>vm</code>和<code>$mount</code>方法的三个参数依次传入。</p><p>判断<code>options</code>选项中<code>immediate</code>属性中是否为真，如果是的话，立即执行一次回调函数<code>cb</code>，使用<code>call</code>执行，函数指向当前的实例对象，并传入参数<code>watcher.value</code>，即观察者的新值。</p><p><code>$watch</code>方法最后返回一个函数，这个函数是用来取消观察，删除观察者的。函数调用观察者的<code>teardown</code>方法。</p><p>看下<code>teardown</code>方法的代码，在<code>core/observer/watcher.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">teardown() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">    <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">    <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">      remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">false</span> <span class="comment">// ! 设置观察者实例是非激活状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>active</code>是否为真，即判断观察者是否是激活状态，如果是的话，再判断观察者所属实例对象是否已被销毁，如果没有销毁的话，把这个观察者从实例对象中的<code>_watchers</code>属性中删除，即销毁它。</p><p>然后通过递减观察者<code>deps</code>的长度的方式遍历<code>deps</code>，在<code>deps</code>里面存在观察者的<code>dep</code>里删除观察者，最后把观察者的<code>actice</code>属性设为<code>false</code>，表示观察者是非激活状态，这样观察者的回调函数就不会执行了。</p><p>示例对象的<code>$watch</code>方法示例代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 是函数时</span></span><br><span class="line">vm.$watch(</span><br><span class="line">  <span class="string">'name'</span>,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'change'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cb 是对象时</span></span><br><span class="line">vm.$watch(<span class="string">'name'</span>, &#123;</span><br><span class="line">  handler: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'change'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a><code>watch</code></h2><p>我们可以使用<code>vm.$watch</code>观察 Vue 实例变化，也可以使用<code>watch</code>选项做相同的事情。<code>watch</code>选项是一个对象，对象的键是需要观察的数据，值是对应的回调函数或者处理器对象，也可以是已经声明的方法的名称。</p><p>在 Vue 的实例对象初始化时，通过遍历<code>watch</code>选项中，然后创建观察者。</p><p>查看<code>initWatch</code>函数的代码，在<code>core/instance/state.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 初始化 watch 选项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span>(<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 遍历 watch</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key] <span class="comment">// ! 获取 handler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 如果 handler 是数组（多个观察者），遍历数组后分别创建 Watcher 实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历<code>watch</code>选项，通过<code>key</code>获取到它的值<code>handler</code>。</p><p>然后判断<code>handler</code>是不是数组，如果是数组的话，再遍历一次，在每次循环的过程中，调用<code>createWatcher</code>函数创建观察者；如果不是数组的话，直接调用<code>createWatcher</code>函数创建观察者。</p><p>通过<code>createWatcher</code>函数处理各种类型的<code>handler</code>，包括函数、对象、字符串，最后创建观察者。</p><p>组件中<code>watch</code>选项的示例代码，这里使用官方文档的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    d: <span class="number">4</span>,</span><br><span class="line">    e: &#123;</span><br><span class="line">      f: &#123;</span><br><span class="line">        g: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    b: <span class="string">'someMethod'</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    c: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    d: &#123;</span><br><span class="line">      handler: <span class="string">'someMethod'</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 多个 watcher</span></span><br><span class="line">    e: [</span><br><span class="line">      <span class="string">'handle1'</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span> <span class="title">handle3</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">          <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// watch vm.e.f's value: &#123;g: 5&#125;</span></span><br><span class="line">    <span class="string">'e.f'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="number">2</span> <span class="comment">// =&gt; new: 2, old: 1</span></span><br></pre></td></tr></table></figure><h2 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h2><p>在观察者的<code>get</code>方法中，如果<code>this.deep</code>的值为<code>true</code>会进行深度监听，深度监听的目标是对象或者数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ! 如果是深度观察 =&gt; 用于 watch 选项</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value) <span class="comment">// ! 递归去访问 value，触发它所有子项的 getter</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>traverse</code>函数去递归访问<code>value</code>的值，触发它所有子项的<code>getter</code>。</p><p>看下<code>traverse</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// ! 存储 id 值的集合</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">val: any</span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects)</span><br><span class="line">  seenObjects.clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>_traverse</code>方法，把<code>val</code>和<code>seenObjects</code>集合传入，最后调用<code>seenObjects</code>对象的<code>clear</code>方法清空<code>seenObjects</code>集合的元素。</p><p>再看下<code>_traverse</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span>(<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!isA &amp;&amp; !isObject(val)) ||</span><br><span class="line">    <span class="built_in">Object</span>.isFrozen(val) ||</span><br><span class="line">    val <span class="keyword">instanceof</span> VNode</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明变量<code>i</code>和<code>keys</code>；再声明常量<code>isA</code>，<code>isA</code>是用来判断传入的参数<code>val</code>是否是数组。</p><p>判断<code>val</code>的值的类型，如果<code>val</code>是非数组非对象类型，或者是不可扩展的，或者是一个<code>VNode</code>，直接返回。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">  <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 已经遍历的对象，不会再遍历，避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  seen.add(depId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>val</code>是否存在<code>__ob__</code>属性，即它是一个响应式对象，如果是的话，声明常量<code>depId</code>存储从<code>val.__ob__</code>属性获取到的<code>dep</code>的<code>id</code>，这个<code>id</code>是<code>dep</code>的唯一标识。</p><p>判断集合<code>seen</code>中是否存在<code>depId</code>，如果存在，直接返回，这说明<code>dep</code>已经收集过依赖，不需要再重复收集。</p><p>如果<code>seen</code>中不存在<code>depId</code>，把<code>depId</code>添加到集合<code>seen</code>中。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 数组</span></span><br><span class="line"><span class="keyword">if</span> (isA) &#123;</span><br><span class="line">  i = val.length</span><br><span class="line">  <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">  i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度观测的对象只能是对象或者数组，不管是哪种类型都是遍历它，然后访问它的每一个子项，触发子项的<code>getter</code>，收集依赖。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 给我们提供了侦听器方法&lt;code&gt;vm.$watch&lt;/code&gt;和选项&lt;code&gt;watch&lt;/code&gt;，用来观察 Vue 实例变化，然后执行一些操作。&lt;/p&gt;
&lt;p&gt;下面看下它们是怎么实现的，其实它们都是基于观察者&lt;code&gt;watcher&lt;/code&gt;的封装。&lt;/p&gt;
&lt;h2 id=&quot;vm-watch&quot;&gt;&lt;a href=&quot;#vm-watch&quot; class=&quot;headerlink&quot; title=&quot;vm.$watch&quot;&gt;&lt;/a&gt;&lt;code&gt;vm.$watch&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;先看&lt;code&gt;Vue.prototype.$watch&lt;/code&gt;方法的代码，在&lt;code&gt;core/instance/state.js&lt;/code&gt;文件中。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Vue.prototype.$watch = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  expOrFn: string | Function,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  cb: any,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  options?: Object&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;Function&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先看下&lt;code&gt;$watch&lt;/code&gt;方法的参数，有三个参数，分别是&lt;code&gt;expOrFn&lt;/code&gt;、&lt;code&gt;cb&lt;/code&gt;和&lt;code&gt;options&lt;/code&gt;，我们发现这三个参数对应着&lt;code&gt;Watcher&lt;/code&gt;构造函数的第二个到第四个参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之观察者的执行</title>
    <link href="https://haledeng.com/blog/20190923-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://haledeng.com/blog/20190923-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2019-09-23T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:11.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h2><h3 id="单个观察者同步执行"><a href="#单个观察者同步执行" class="headerlink" title="单个观察者同步执行"></a>单个观察者同步执行</h3><p>先看下同步执行的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 同步执行，不需要调用 nextTick 执行观察者 =&gt; 用于 watch 自定义的观察者</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">  <span class="keyword">this</span>.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了观察者的<code>sync</code>属性为<code>true</code>的话，会执行了观察者的<code>run</code>方法，执行同步更新。</p><a id="more"></a><p>怎么设置<code>sync</code>属性呢？看下面的示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    someWatch: &#123;</span><br><span class="line">      handler() &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      sync: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在我们设置<code>watch</code>选项时，设置一个对象而不是函数，然后设置<code>sync</code>的值。</p><p>看下<code>run</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get() <span class="comment">// ! 获取值 =&gt; 执行 getter，如果执行的是 updateComponent，返回 undefined</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value <span class="comment">// ! 缓存旧值</span></span><br><span class="line">      <span class="keyword">this</span>.value = value <span class="comment">// ! 旧值更新为新值</span></span><br><span class="line">      <span class="comment">// ! 处理用户定义的观察者，比如 watch $watch</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue) <span class="comment">// ! 传入新旧值，执行回调函数更新视图</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>this.active</code>是否为<code>true</code>，如果为<code>true</code>，说明当前观察者是激活状态，可以执行更新。在我们删除观察者的时候，这个值会为<code>false</code>，表示观察者是非激活状态，不会执行更新。</p><p>首先，声明变量<code>value</code>存储调用<code>this.get</code>方法获取到新值，再判断新值和旧值是否不相同，新值是不是一个非<code>null</code>的对象，以及<code>this.deep</code>的值是否为<code>true</code>。如果满足其中的一个条件就会进行下面的逻辑。</p><p>声明常量<code>oldValue</code>存储旧值，然后把<code>this.value</code>更新为新值<code>value</code>。然后判断<code>this.user</code>的值是否为<code>ture</code>，如果为<code>true</code>说明这个观察者是用户定义的。再调用<code>this.cb</code>函数去更新视图，调用时使用<code>call</code>方法，函数指向观察者所属的实例对象，并传入新值和旧值。</p><p>因为由用户定义的观察者，可能会出错，所以这里使用<code>try...catch</code>语句来执行回调函数<code>cb</code>，这样可以更好捕获可能出现的错误。在<code>catch</code>代码块中使用了<code>this.expression</code>正是前面定义的<code>expOrFn</code>函数的字符串转换值，为了更好的显示错误信息。</p><p>如果<code>this.user</code>为<code>false</code>，说明是这个观察者是 Vue 内部定义的，不过还是使用和用户定义的观察一样的方法调用它，只是少了捕获错误的代码。</p><p><strong>注意</strong>，这里说的观察者执行，指的是观察者的<strong>回调函数</strong>的调用。观察者是一个实例对象，它是不能执行调用的。</p><h3 id="全局观察者同步执行"><a href="#全局观察者同步执行" class="headerlink" title="全局观察者同步执行"></a>全局观察者同步执行</h3><p>上面讲解了单个观察者（的回调函数）同步执行过程，其实 Vue 还提供了一个全局配置属性<code>Vue.config.async</code>，默认是<code>true</code>，即默认 Vue 的所有观察者的回调函数都是异步执行的。</p><p>设置这个属性的代码在<code>core/config.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Perform updates asynchronously. Intended to be used by Vue Test Utils</span></span><br><span class="line"><span class="comment">   * This will significantly reduce performance if set to false.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在项目的入口文件把<code>Vue.config.async</code>的值设置为<code>false</code>，那么 Vue 的所有的观察者都是同步执行。</p><p>Vue 的观察者默认是异步执行的，异步执行的代码在<code>core/observer/scheduler.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ! 同步执行，主要用于非生产环境中测试代码</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      flushSchedulerQueue() <span class="comment">// ! 直接执行</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    nextTick(flushSchedulerQueue) <span class="comment">// ! 使用 nextTick 执行队列的回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把观察者放入的一个队列中，然后异步执行队列。</p><p>如果设置了所有观察者都是同步执行的，那么它是怎么同步执行的呢？答案是按照<code>id</code>的顺序执行的。</p><p>看下队列中观察者是怎么执行的，查看<code>flushSchedulerQueue</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id) <span class="comment">// 队列中元素升序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看下订阅器<code>dep</code>是怎么触发依赖，即怎么通知观察者的。</p><p>查看<code>notify</code>方法的代码，在<code>core/observer/dep.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 同步执行观察者，不是异步队列全部入队后一起执行</span></span><br><span class="line">    <span class="comment">// ! 需要按照顺序来执行，主要用于非生产环境中测试代码</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id) <span class="comment">// ! id 升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>发现这里也是按照<code>id</code>的排序来通知观察者的。排序主要是为了保证观察者按照它创建时的顺序执行，避免错误。</p><h2 id="异步队列更新"><a href="#异步队列更新" class="headerlink" title="异步队列更新"></a>异步队列更新</h2><p>如果没有设置观察者的执行模式，默认是异步执行的。</p><p>下面看下异步执行的代码，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 异步执行，需要调用 nextTick 执行观察者 =&gt; 用于执行自动收集的依赖</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  queueWatcher(<span class="keyword">this</span>) <span class="comment">// ! 使用异步队列更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>queueWatcher</code>函数，并把当前的观察者作为参数传入。</p><p>下面看下<code>queueWatcher</code>函数的代码，在<code>core/observer/scheduler.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span> <span class="comment">// ! 等待标识</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span> <span class="comment">// ! 队列是否正在执行更新</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher) <span class="comment">// ! 队尾入队</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher) <span class="comment">// ! 从后面开始查找，插入到第一个比它 id 小的元素后面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义常量<code>id</code>存储观察者的<code>id</code>，然后判断<code>has</code>对象中是否存在<code>key</code>值和这个<code>id</code>相同，<code>has</code>是一个普通的对象。如果不存在，把<code>id</code>作为<code>key</code>存入到<code>has</code>对象中，<code>id</code>对应的值是<code>true</code>。</p><p>再判断<code>flushing</code>的值是否为<code>false</code>，如果为<code>false</code>，说明队列中的观察者没有在执行，这时候把观察者放入队列尾部。如果<code>flushing</code>的值为<code>true</code>，说明队列中有观察者正在执行，这时候就不能放在队列尾部，而是从队列的后面开始查找观察者，然后把当前观察者插入到第一个比它 id 小的元素后面，也就是按照<code>id</code>的顺序把当前观察者插入到队列的合适的位置中。</p><p><strong>什么时候观察者在队列执行时还要入队呢</strong>？答案是计算属性观察者，因为计算属性更新值的时机和普通的响应性数据是不一样的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue the flush</span></span><br><span class="line"><span class="comment">// ! waiting 标识，保证只执行一次</span></span><br><span class="line"><span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">  waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 同步执行，主要用于非生产环境中测试代码</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">    flushSchedulerQueue() <span class="comment">// ! 直接执行</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  nextTick(flushSchedulerQueue) <span class="comment">// ! 使用 nextTick 执行队列的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>waiting</code>是一个开关，表示是否需要等待，它的默认值<code>false</code>，表示不需要等待。</p><p>当<code>waiting</code>为<code>false</code>时，先设置它为<code>true</code>，这样在执行<code>if</code>代码的过程中，如果函数里面再去调用<code>queueWatcher</code>函数就不会再去执行这个函数的<code>if</code>代码。因为无论递归执行多少次<code>queueWatcher</code>函数，函数里面的<code>if</code>代码只会执行一次。</p><p>在非生产环境中，如果设置了全局同步执行，直接调用<code>flushSchedulerQueue</code>函数同步执行队列的观察者。</p><p>注意，到这里还是同步执行。先不管<code>flushSchedulerQueue</code>是如何执行队列观察者的。</p><p>否则使用<code>nextTick</code>函数异步执行<code>flushSchedulerQueue</code>函数，只有到了这里才是真正的异步执行。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h2><p>在 Vue 的官方文档中，提供<code>Vue.nextTick</code>或者<code>vm.$nextTick</code>这两个 API 供我们异步执行函数。</p><p>它们都来自同一个<code>nextTick</code>函数，作用是：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p><code>nextTick</code>函数把同步执行的函数变成异步执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextTick(fn)</span><br></pre></td></tr></table></figure><p>它的原理和定时器<code>setTimeout</code>是一样的。它在里面也封装了<code>setTimeout</code>函数。</p><p>在 Vue 2.6 以前的版本中，<code>nextTick</code>还会明显的区分宏任务和微任务中是怎么处理异步。但是从 2.6 版本开始就只是根据异步接口执行的优先级，按照顺序来尝试执行异步函数。</p><p>查看下面的代码，在<code>core/util/next-tick.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 回调函数，明面上不分 microtasks 和 (macro)tasks 了，按照下面的优先级来实现</span></span><br><span class="line"><span class="comment">// ! 优先级（性能高低） Promise =&gt; MutationObserver =&gt; setImmediate =&gt; setTimeout</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! Promise</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// ! setImmediate</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明变量<code>timerFunc</code>，用来存储异步执行函数的包装函数，包装异步执行的<code>flushCallbacks</code>函数。</p><p>按照异步函数的执行的优先级，先尝试使用<code>Promsie.resolve</code>。如果不支持，再尝试使用<code>MutationObserver</code>。如果还是不支持，继续尝试使用<code>setImmediate</code>。最后使用<code>setTimeout</code>，这个异步接口基本所有的浏览器都会支持。通过这些异步接口，使<code>flushCallbacks</code>函数异步执行。</p><p>其中<code>Primise.resolve</code>接口的性能是最好的，使用它包装的异步函数在执行时会放在浏览器的微任务列表中，这个列表中的异步函数等待时间最短，执行最快。而<code>setTimeout</code>接口的性能是最差的。</p><p>看下<code>flushCallbacks</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = [] <span class="comment">// ! 回调函数组成的数组</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span> <span class="comment">// ! 队列是否等待执行，false 表示队列为空，不用等待</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 执行 callbacks 的所有的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span> <span class="comment">// ! 重置 pending</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>) <span class="comment">// ! 拷贝副本</span></span><br><span class="line">  callbacks.length = <span class="number">0</span> <span class="comment">// ! 清空 callbacks</span></span><br><span class="line">  <span class="comment">// ! 执行拷贝副本的所有回调函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flushCallbacks</code>的作用就是按照顺序执行<code>callbacks</code>数组中的所有的回调函数（观察者）。</p><p>下面看下导出的<code>nextTick</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 把 cb 包装成一个函数，并放入 callbacks 数组中</span></span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 判断数组是否等待执行</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc() <span class="comment">// ! 执行异步函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="comment">// ! nextTick 没有传入回调函数时，提供一个 Promise 化的调用</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受两个参数，第一个参数是回调函数<code>cb</code>，第二个参数是函数调用时的上下文环境。</p><p>声明变量<code>_resolve</code>，在用户使用<code>nextTick</code>时如果没有传入回调函数<code>cb</code>，在可以使用<code>Promise</code>时的环境时，会把变量<code>_resolve</code>赋值为<code>Promise</code>的<code>resolve</code>函数。</p><p>如果有回调函数<code>cb</code>，使用<code>try...catch</code>语句包装并执行这个函数，这样不但很好捕获错误，而且在<code>cb</code>没有值时还调用<code>_resolve</code>函数。另外，把这个包装的函数放入到数组<code>callbacks</code>中。</p><p>判断队列<code>callbacks</code>是否等待执行，如果<code>pending</code>为<code>false</code>时，说明数组中没有回调函数在等待执行，先设置<code>pending</code>为``true<code>，表示数组中已经有回调函数，不用等待了，可以执行，然后调用</code>timerFunc<code>函数，也就是异步执行</code>flushCallbacks`中的回调函数。</p><p>然后我们会发现在执行<code>flushCallbacks</code>函数时，一开始是把<code>pending</code>重置为<code>false</code>，因为函数接下来就会执行完所有的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span> <span class="comment">// ! 重置 pending</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在一般情况下， Vue 的所有观察者都是异步执行的，只有在测试环境或者其他的特殊场景才让观察者同步执行。另外同步执行时，在队列中都会根据观察者的<code>id</code>进行排序，然后按照顺序执行观察者的回调函数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同步执行&quot;&gt;&lt;a href=&quot;#同步执行&quot; class=&quot;headerlink&quot; title=&quot;同步执行&quot;&gt;&lt;/a&gt;同步执行&lt;/h2&gt;&lt;h3 id=&quot;单个观察者同步执行&quot;&gt;&lt;a href=&quot;#单个观察者同步执行&quot; class=&quot;headerlink&quot; title=&quot;单个观察者同步执行&quot;&gt;&lt;/a&gt;单个观察者同步执行&lt;/h3&gt;&lt;p&gt;先看下同步执行的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ! 同步执行，不需要调用 nextTick 执行观察者 =&amp;gt; 用于 watch 自定义的观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sync) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.run()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果设置了观察者的&lt;code&gt;sync&lt;/code&gt;属性为&lt;code&gt;true&lt;/code&gt;的话，会执行了观察者的&lt;code&gt;run&lt;/code&gt;方法，执行同步更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之观察者</title>
    <link href="https://haledeng.com/blog/20190921-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    <id>https://haledeng.com/blog/20190921-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85/</id>
    <published>2019-09-21T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:07.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Watcher-观察者"><a href="#Watcher-观察者" class="headerlink" title="Watcher 观察者"></a><code>Watcher</code> 观察者</h2><p>下面看下观察者<code>Watcher</code>的代码，这个类比较复杂，里面创建了很多属性和方法。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addDep(dep: Dep) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cleanupDeps() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAndInvoke(cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  evaluate() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  teardown() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下类的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数有五个参数，分别是：</p><ol><li>Vue 的实例对象<code>vm</code>。</li><li>要监听的目标<code>expOrFn</code>，即可以是字符串，也可以是一个返回目标的函数。</li><li>监听目标变化时的回调函数<code>cb</code>。</li><li>传递给当前观察者对象的选项<code>options</code>。</li><li>是不是渲染函数观察者<code>isRenderWatcher</code>。</li></ol><p>现在重新回头查看<code>mountComponent</code>函数中生成<code>Watcher</code>实例对象的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 生成观察者实例</span></span><br><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent, <span class="comment">// ! 更新组件的函数，执行时 =&gt; 执行 vm.$options.render =&gt; getter =&gt; 收集依赖</span></span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>) <span class="comment">// ! 传入 beforeUpdate 生命周期钩子函数，在更新前组件前调用</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个参数<code>vm</code>是当前需要挂载的实例对象。第二个参数<code>updateComponent</code>是监听的目标，它是一个生成真实元素的函数。第三个参数<code>noop</code>是一个空函数；第四个参数<code>options</code>是选项对象，这里传入了一个<code>before</code>函数，这个函数调用了<code>beforeUpdate</code>生命周期钩子函数。第五个参数<code>isRenderWatcher</code>是一个布尔值<code>true</code>，说明这是一个渲染函数的观察者。</p><p>其中，第二个参数<code>expOrFn</code>会把它变成一个<code>getter</code>。而第三个参数<code>cb</code>是一个空函数，什么也没做。因为这是一个渲染函数的观察者，它只执行<code>getter</code>收集依赖，不用去触发依赖。</p><p>下面继续看构造函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.vm = vm</span><br><span class="line"><span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">  vm._watcher = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">vm._watchers.push(<span class="keyword">this</span>) <span class="comment">// ! 把自己添加进去</span></span><br></pre></td></tr></table></figure><p>把需要挂载的实例对象<code>vm</code>存储到观察者的<code>vm</code>属性中，这样每个观察者的<code>vm</code>都存储着它所属的实例对象，这表明了这个观察者的归属。</p><p>判断传入的第五个参数<code>isRenderWatcher</code>是否为<code>true</code>，如果是的话，就把当前观察者存储到实例对象的<code>_watcher</code>属性中。</p><p>把观察者放入到实例对象的<code>_watchers</code>属性中，这个属性存储所有的观察者实例，不管是渲染函数观察者还是其他的观察者。</p><p>注意实例对象中的<code>_watcher</code>属性在初始化时通过<code>initLifecycle</code>函数定义过，它的初始值是<code>null</code>。而<code>_watchers</code>属性是通过<code>initState</code>函数定义过，它的初始值是空数组。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line">  <span class="keyword">this</span>.deep = !!options.deep <span class="comment">// ! 是否深度监听</span></span><br><span class="line">  <span class="keyword">this</span>.user = !!options.user <span class="comment">// ! 是否是开发者定义的，主要指 watch $watch 中自定义的函数</span></span><br><span class="line">  <span class="keyword">this</span>.lazy = !!options.lazy <span class="comment">// ! 是否开启懒惰模式，专为计算属性设置</span></span><br><span class="line">  <span class="keyword">this</span>.sync = !!options.sync <span class="comment">// ! 是否同步求值</span></span><br><span class="line">  <span class="keyword">this</span>.before = options.before <span class="comment">// ! 更新之前调用的钩子函数，比如调用 beforeUpdate 钩子函数</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span> <span class="comment">// ! 默认值为 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过传入的第四个参数<code>options</code>选项来初始化观察者的一些属性，其中<code>deep</code>、<code>user</code>、<code>lazy</code>和<code>sync</code>属性的值是布尔类型，如果没有传入值，它们的值默认为<code>undefined</code>，然后通过双重取反变成布尔值<code>false</code>。</p><p>下面来分析这些属性：</p><ul><li><code>deep</code>：用来告诉观察者当前的监听对象是否执行深度监听。</li><li><code>user</code>：用来告诉观察者当前的对象是用户定义的还是内部定义的。除了内部定义的观察者，比如渲染函数观察者、计算属性观察者，其他的观察者一般都是用户定义的。</li><li><code>lazy</code>：用来告诉观察者当前的监听对象是不是计算属性。</li><li><code>sync</code>：用来告诉观察者当前的监听的对象变化时是否进行同步求值。</li><li><code>before</code>：这是在监听的对象变化之前调用的生命周期钩子函数，即<code>beforeUpdare</code>钩子函数。</li></ul><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.cb = cb</span><br><span class="line"><span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line"><span class="keyword">this</span>.active = <span class="literal">true</span> <span class="comment">// ! 观察者默认是激活状态</span></span><br><span class="line"><span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br></pre></td></tr></table></figure><p>定义<code>this.cb</code>属性，它的值是传入的第三个参数<code>cb</code>，即回调函数。</p><p>定义<code>this.id</code>属性，它是观察者的唯一标识，初始值为<code>0</code>，然后后面创建的观察者的 id 是递增的。</p><p>定义<code>this.active</code>属性，它表示观察者是否是激活状态，默认值是<code>true</code>。</p><p>定义<code>this.dirty</code>属性，它的值和<code>this.lazy</code>相同，也是用于计算属性。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.deps = [] <span class="comment">// ! 上一次添加的 Dep 实例数组</span></span><br><span class="line"><span class="keyword">this</span>.newDeps = [] <span class="comment">// ! 当前添加的 Dep 实例数组</span></span><br><span class="line"><span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// ! 上一次添加到 Dep 实例的 id 的集合，不能重复</span></span><br><span class="line"><span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// ! 当前添加到 Dep 实例的 id 的集合，不能重复</span></span><br></pre></td></tr></table></figure><p>上面定义的四个订阅器相关的属性是用来避免重复收集依赖和移除无用依赖的。这些属性分成两组，其中<code>deps</code>和<code>depIds</code>是一组，用于上一次收集的依赖。<code>newDeps</code>和<code>newDepIds</code>是一组，用于当前收集的依赖。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.expression =</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> ? expOrFn.toString() : <span class="string">''</span></span><br></pre></td></tr></table></figure><p>定义<code>this.expression</code>属性，在非生产环境时，它的值是第二个参数的字符串转换值，而在生成环境时，它的值是空字符串，说明这个属性是在非生产环境中使用的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parse expression for getter</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.getter = parsePath(expOrFn) <span class="comment">// ! 字符串转函数</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getter = noop</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断传入的第二个参数<code>expOrFn</code>的类型，如果它是函数类型，把它赋值给观察者的<code>getter</code>属性。如果不是函数类型，应该是一个字符串类型，调用<code>parsePath</code>函数把它转换成一个函数并赋值给<code>getter</code>。如果转换成函数失败，观察者的<code>getter</code>属性赋值为一个空函数，在非生产环境中报错，提示<code>Watcher</code>只接受简单的点分割路径，如果想要完整监听，需要使用函数。</p><p>看下<code>parsePath</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> unicodeRegExp = <span class="regexp">/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`[^<span class="subst">$&#123;unicodeRegExp.source&#125;</span>.$_\\d]`</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数之前声明一个正则表达式<code>bailRE</code>，这个正则表达式的含义是：</p><ul><li>不能是<code>unicodeRegExp.source</code>。</li><li>不能是<code>.</code>符或者<code>$</code>符或者<code>_</code>符。</li><li>不能是<code>\d</code>，即不能是数字。</li></ul><p>看这个函数前面的<code>if</code>语句，如果传入的参数<code>path</code>匹配到了上面的正则表达式，就直接返回。</p><p>也就是说如果需要继续后面的逻辑，就必须不能满足上面的正则表达式，也就是和上面的条件相反。即传入的<code>path</code>必须要是<code>unicodeRegExp.source</code>，或者是数字，或者有<code>.</code>符，或者有<code>$</code>符，或者有<code>_</code>符，只要满足其中的一项条件即可。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">    obj = obj[segments[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>.</code>符来分割<code>path</code>，把分割后的数组存储在变量<code>segments</code>中。</p><p>然后返回一个函数，返回的函数里面遍历<code>segments</code>，并且访问传入的实例对象<code>obj</code>中存在于<code>segments</code>中的<code>path</code>对应的值，这相当于一个触发了访问的值的<code>getter</code>函数。</p><p>继续看构造函数最后的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 实例化最后，调用 get 获取值，并收集依赖</span></span><br><span class="line"><span class="comment">// ! 注意计算属性采用不同的处理方法</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</span><br></pre></td></tr></table></figure><p>定义<code>this.value</code>属性，即获取的值。非计算属性观察者会调用<code>this.get</code>方法获取值。而计算属性观察者的值为<code>undefined</code>，也就是没有收集依赖，因为计算属性获取值的时机不一样，后面会讲解。</p><h2 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h2><p>下面看下<code>Watcher</code>下面的<code>get</code>方法，这个方法的作用是获取观察对象的值和收集依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>) <span class="comment">// ! Dep.target 赋值为观察者实例 ，并放入维护的 targetStack 中</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数的前面先调用了<code>pushTarget</code>函数把观察者放入到收集依赖的栈中，然后后面又调用了<code>popTarget</code>函数把她从收集的栈中删除。</p><p>先看下这个两个函数的代码，在<code>core/observer/dep.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span> <span class="comment">// ! 初始化为 null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 把 target 放入栈中，并赋值 Dep.target</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 把 target 移出栈中，Dep.target 变成栈的最后一个元素 或者 undefined</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pushTarget</code>函数会把传入的观察者赋值给了订阅器的<code>Dep.target</code>属性中，并且存入一个<code>targetStack</code>数组类型的栈中。</p><p><code>popTarget</code>函数会把前面加入栈的观察者对象移出栈，并把<code>Dep.target</code>的值变成现在栈中的最后一个元素。</p><p>再看<code>get</code>中的其他代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ! 执行 getter 获取值</span></span><br><span class="line">  <span class="comment">// ! 相当于执行 updateComponent 函数 =&gt; 即执行 vm._update(vm._render(), hydrating)</span></span><br><span class="line">  <span class="comment">// ! 而执行 vm._render =&gt; 对 vm 上的数据访问 =&gt; 触发 getter =&gt; 收集依赖</span></span><br><span class="line">  value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">  <span class="comment">// dependencies for deep watching</span></span><br><span class="line">  <span class="comment">// ! 如果是深度观察 =&gt; 用于 watch 选项</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">    traverse(value) <span class="comment">// ! 递归去访问 value，触发它所有子项的 getter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 把 Dep.target 恢复成上一个状态</span></span><br><span class="line">  <span class="comment">// ! 当前 vm 的数据依赖收集已经完成，那么对应的渲染 Dep.target 也需要改变</span></span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps() <span class="comment">// ! 每次求值后清空当前的依赖，避免重复收集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value <span class="comment">// ! 渲染函数观察者的返回值永远都是 undefined</span></span><br></pre></td></tr></table></figure><p>声明变量<code>value</code>，这个遍历用来存储调用<code>getter</code>函数获取到的值，也是最后的返回值，声明常量<code>vm</code>存储<code>this.vm</code>，也就是观察者所属的实例对象。</p><p>调用<code>try...catch...finally</code>语句执行<code>getter</code>函数，是为了更好的捕获错误。</p><p>先看<code>try</code>代码块的代码，执行<code>this.getter</code>函数，并把函数返回的值赋值给了变量<code>value</code>。再获取值的过程中，会触发值的<code>getter</code>属性，<code>getter</code>是在<code>defineReactive</code>函数中通过<code>Object.defineProperty</code>定义的<code>get</code>属性，然后<code>getter</code>会收集依赖。</p><p>这里分析下<strong>依赖收集的过程</strong>：</p><p>首先，通过 <code>new Watcher</code>生成一个观察者实例对象，需要传入实例对象、观察的目标<code>expOrFn</code>以及回调函数<code>cb</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(&#123; vm, expOrFn, cb &#125;)</span><br></pre></td></tr></table></figure><p>在生成观察者实例对象的过程中，会执行类<code>Watcher</code>的构造函数的代码，构造函数的最后代码会调用<code>Watcher</code>的<code>get</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(/* ... */) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 获取值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>方法中会执行<code>getter</code>方法，而这个<code>getter</code>方法一般就是传入的第二个参数<code>expOrFn</code>，即观察目标的表达式。在执行<code>getter</code>方法之前，会调用<code>pushTarget</code>函数把<code>Dep.target</code>赋值为这个观察者，并键入到收集依赖的栈中，然后就是执行<code>getter</code>方法，这时会访问到<code>expOrFn</code>执行后的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">pushTarget(<span class="keyword">this</span>) <span class="comment">// 赋值为 Dep.target 入栈</span></span><br><span class="line">value = <span class="keyword">this</span>.getter.call(vm, vm) <span class="comment">// 访问值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pushTarget</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问到<code>expOrFn</code>执行后的值时，会触发这个值的<code>getter</code>函数，<code>getter</code>函数会先判断<code>Dep.target</code>是否有值。因为前面已经赋值，所以会执行<code>Dep</code>实例对象的<code>depend</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend() <span class="comment">// ! 添加进订阅器，依赖收集</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Dep</code>实例对象的<code>depend</code>方法中，又会调用<code>Dep.target</code>属性的<code>addDep</code>方法，也就是调用观察者的<code>addDep</code>方法，把<code>Dep</code>实例对象自身加入到观察者的<code>dep</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dep</span></span><br><span class="line">depend() &#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看观察者的<code>addDep</code>方法，先判断<code>newDepIds</code>中是否存在这个<code>dep</code>，如果没有，会把<code>dep</code>添加到观察者的<code>newDeps</code>集合中去，这样可以避免重复收集依赖。</p><p>然后判断集合<code>depIds</code>中是否有这个<code>dep</code>的<code>id</code>，如果没有的话，说明观察者还没有加入到<code>dep</code>中，调用<code>dep</code>的<code>addSub</code>方法把观察者加入到<code>dep</code>中，到这一步，依赖收集就已经完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watcher</span></span><br><span class="line">addDep(dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="comment">// ! 需要先判定 new 中是否已经收集，如果没有收集才收集，避免重复收集依赖</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep) <span class="comment">// 放入到当前的 Dep 数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>) <span class="comment">// 观察者对象放入到 subs 中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep</span></span><br><span class="line">addSub(sub: Watcher) &#123;</span><br><span class="line">  <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下<code>catch</code>代码块的代码，这里主要是捕获可能出现的错误。</p><p>最后看下<code>finally</code>代码块的代码，如果设置了<code>this.deep</code>为<code>true</code>，说明设置了深度监听。这时需要调用<code>traverse</code>函数递归去访问 <code>value</code>，触发它所有子项的<code>getter</code>，收集观察目标的所有依赖。</p><p>依赖收集完毕，还需要调用<code>this.cleanupDeps</code>清空当前的依赖，避免重复收集依赖。这里清空的是<code>newDeps</code>和<code>newDepIds</code>中的数据，它们表示当前收集到的<code>Dep</code>实例对象的集合。</p><p>最后返回获取到的值<code>value</code>。</p><p>下面看下观察者的<code>cleanupDeps</code>方法，这个方法是清空当前收集到的<code>Dep</code>实例对象的集合，用来防止重复收集依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cleanupDeps() &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="keyword">this</span>) <span class="comment">// ! 删除旧的观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds <span class="comment">// ! 交换 ids</span></span><br><span class="line">  <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDepIds.clear() <span class="comment">// ! 清空 newDepIds</span></span><br><span class="line">  tmp = <span class="keyword">this</span>.deps</span><br><span class="line">  <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps <span class="comment">// ! 交换 deps</span></span><br><span class="line">  <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDeps.length = <span class="number">0</span> <span class="comment">// ! 清空 newDeps</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始是对<code>deps</code>进行遍历，即对上一次求值所收集到的<code>dep</code>进行遍历，在循环的过程中，检查上一次求值所收集到的 <code>dep</code>是否存在于当前收集到的 <code>deps</code> 中，如果不存在，说明该 <code>dep</code> 已经和观察者不存在依赖关系，这时调用 <code>dep.removeSub</code> 方法将观察者从 <code>dep</code>都<code>subs</code>中移除。</p><p><code>dep</code>的<code>removeSub</code>方法的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">removeSub(sub: Watcher) &#123;</span><br><span class="line">  remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每次收集依赖后，会清空当前收集到的<code>dep</code> 对象，即清空<code>newDepIds</code>和<code>newDeps</code>中的值，在清空之前先把它们的值赋值给<code>depIds</code>和<code>deps</code>。</p><p>这样，<code>newDepIds</code> 和 <code>newDeps</code> 所存储的值总是当前收集到的 <code>dep</code>，而<code>depIds</code>和<code>deps</code>存储的值总是上一次收集到的 <code>dep</code> 。</p><h2 id="触发依赖"><a href="#触发依赖" class="headerlink" title="触发依赖"></a>触发依赖</h2><p>在我们修改响应式数据时，会执行它的<code>setter</code>，我们看下<code>defineReactive</code>函数的定义的<code>setter</code>是如何触发依赖的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  dep.notify() <span class="comment">// ! 通知观察者, 触发依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>setter</code>中最后会调用<code>dep</code>的<code>notify</code>方法通知所有观察者（依赖）。</p><p>看下<code>notify</code>方法的代码，在<code>Dep</code>类中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">notify() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了所有观察者的<code>update</code>方法，这个方法是用来更新值，更新视图的。</p><p>看下<code>update</code>方法的代码，在<code>Watcher</code>类中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">update() &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="comment">// ! 如果启动懒惰模式  =&gt; 更新 dirty 为 true，说明可以更新计算属性的值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 同步执行，不需要调用 nextTick 执行观察者 =&gt; 用于 watch 自定义的观察者</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 异步执行，需要调用 nextTick 执行观察者 =&gt; 用于执行自动收集的依赖</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>) <span class="comment">// ! 使用异步队列更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断<code>this.lazy</code>属性是否为真，如果为真，设置<code>this.dirty</code>属性为<code>true</code>。这样使观察者开启懒惰模式，也说明这个观察者是计算属性观察者。</p><p>把<code>this.dirty</code>设置为<code>true</code>，表示它的值发生了变化，观察者可以更新它的值。这个属性用来设置计算属性观察者是否可以执行更新。计算属性观察者的更新以及如何收集依赖在后面讲解计算属性时再讲解。</p><p>下面就是观察者同步执行和异步执行的代码。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Watcher-观察者&quot;&gt;&lt;a href=&quot;#Watcher-观察者&quot; class=&quot;headerlink&quot; title=&quot;Watcher 观察者&quot;&gt;&lt;/a&gt;&lt;code&gt;Watcher&lt;/code&gt; 观察者&lt;/h2&gt;&lt;p&gt;下面看下观察者&lt;code&gt;Watcher&lt;/code&gt;的代码，这个类比较复杂，里面创建了很多属性和方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之组件的挂载</title>
    <link href="https://haledeng.com/blog/20190919-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD/"/>
    <id>https://haledeng.com/blog/20190919-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD/</id>
    <published>2019-09-19T12:00:00.000Z</published>
    <updated>2020-05-07T08:58:02.138Z</updated>
    
    <content type="html"><![CDATA[<p>前面章节主要通过<code>initData</code>函数在初始化<code>data</code>选项的过程来讲解 Vue 的响应式系统。</p><p>主要讲了响应式系统中的工厂函数<code>observe</code>和监听器<code>Observer</code>以及如何定义响应式属性的<code>defineReactive</code>函数。因为响应式的原理是使用<code>Object.defineProperty</code>来定义对象数据的，所以还需要对数组类型的数据进行特殊处理，重写数组的一些常用方法，使得数组中的元素也和对象里面的数据一样，可以收集依赖和触发依赖。</p><a id="more"></a><p>现在来看看 Vue 的观察者以及响应式数据是如何收集和触发依赖的。</p><p>在完成所有选项的初始化之后，这时候就需要挂载组件了。查看<code>Vue.prototype._init</code>函数最后几行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 如果设置了 el，就把实例对象挂载在该元素上</span></span><br><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a><code>$mount</code></h2><p>现在我们去查看 Vue 实例对象的 <code>$mount</code>方法的代码，因为挂载组件的<code>$mount</code>和平台涉及相关，这里只讲解 Web 平台的代码。另外，<code>$mount</code>方法还和版本相关，Runtime 版本中的<code>$mount</code>方法不涉及编译器代码，只有完成版本中的<code>$mount</code>方法才涉及到编译器代码。</p><p>先查看 Runtime 版本中的<code>$mount</code>函数，在<code>platforms/web/runtime/index.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 安装 web 平台的挂载方法 $mount （这里是 runtime 版本）</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating) <span class="comment">// ! 挂载组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先重写设置<code>el</code>的值，先判断是否传入<code>el</code>参数，如果传入的话，再判断当前的宿主环境是否是浏览器环境。如果在浏览器环境中，使用<code>query</code>函数并传入<code>el</code>，否则<code>el</code>为<code>undefiend</code>。</p><p>看下<code>query</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">el: string | Element</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">    <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        warn(<span class="string">'Cannot find element: '</span> + el)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>el</code>的类型可以是字符串也可以是<code>Element</code>，如果<code>el</code>是字符串的话，说明<code>el</code>应该是一个<code>CSS</code>选择器，调用原生的<code>document.querySelector</code>方法获取 DOM，如果找不到 DOM ，在非生产环境中会报错。</p><p>如果<code>el</code>是一个<code>Element</code>，则直接返回它。最后输出到的<code>el</code>一定是<code>Element</code>类型。</p><p><code>$mount</code>函数最后再调用<code>mountComponent</code>函数，并传入三个参数，分别是 Vue 的实例对象<code>this</code>、获取到的元素<code>el</code>以及布尔值<code>hydrating</code>。</p><p>先不去管<code>mountComponent</code>函数，现在查看完整版本的<code>$mount</code>方法，在<code>platforms/web/entry-runtime-with-compiler.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount <span class="comment">// ! 缓存 runtime 版本的 $mount 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 重写 $mount 方法 with compiler</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating) <span class="comment">// ! 调用 runtime mount 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件中先声明常量<code>mount</code>缓存 Runtime 版本的<code>$mount</code>，然后重写了<code>Vue.prototype.$mount</code>方法，看下重写方法的第一行代码，还是通过<code>query</code>获取 <code>DOM</code> 。再看最后一行的代码，调用 Runtime 版本的<code>$mount</code>，并传入相同的参数。</p><p>现在看下重写方法中间的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 不能挂载在 body 和 html 标签上</span></span><br><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断获取的元素是不是<code>document.body</code>或者<code>document.documentElement</code>，如果是的话在非生产环境中会报错。因为 Vue 的实例对象挂载在元素上是会替换掉这个元素的，这样的话就会把<code>body</code>和<code>html</code>标签元素替换掉，而这两个元素是不应该被替换掉的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line"><span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line"><span class="comment">// ! 如果没有渲染函数，使用 template 或者 el 构建渲染函数</span></span><br><span class="line"><span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量<code>option</code>存储合并后的选项<code>vm.$options</code>，然后判断渲染函数<code>options.render</code>是否存在，如果不存在，则使用<code>template</code>或者<code>el</code>选项构建渲染函数。</p><p>这里先提前说下后面代码的主要逻辑，先判断是否存在<code>template</code>选项，如果存在，则使用<code>template</code>选项的值获取<code>template</code>；如果不存在，判断是否存在<code>el</code>选项，如果存在<code>el</code>选项则使用<code>el</code>选项获取<code>template</code>的值。总之一定要获取到<code>template</code>，而且它都值必须是<code>Element</code>类型，这样才能挂载组件。</p><p>现在看下如何使用<code>template</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = options.template</span><br><span class="line"><span class="comment">// ! 获取 template 的值</span></span><br><span class="line"><span class="comment">// ! 优先从 template 选项中获取</span></span><br><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// ! id 选择器</span></span><br><span class="line">    <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">      template = idToTemplate(template)</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明变量<code>options</code>存储<code>options.template</code>的值。</p><p>然后判断<code>template</code>是不是一个字符串，如果是的话，再判断它是不是以<code>#</code>开头，如果是的话，就可以确定<code>template</code>应该是一个<code>CSS</code>的<code>id</code>选择器，调用<code>idToTemplate</code>函数通过这个选择器获取元素。</p><p>看下<code>idToTemplate</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 通过 id 获取元素的 innerHTML</span></span><br><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id)</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个函数通过<code>id</code>选择器来获取元素，并返回元素的<code>innerHTML</code>。</p><p>如果获取不到元素的<code>innerHTML</code>作为<code>template</code>的值，在非生产环境中会报错，提示找不到模板元素或者模板元素是空的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 元素类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">  template = template.innerHTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>template</code>有<code>nodeType</code>属性，说明它是一个元素，直接获取它的<code>innerHtml</code>的值。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 其他无效的 template 报错</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续分析<code>template</code>的其他情况，即无效的<code>template</code>。此时如果在非生产环境中会报错，提示<code>template</code>选项是无效的。</p><p>下面看使用<code>el</code>的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ! 其次从 el 选项获取</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">  template = getOuterHTML(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>templatetemplate</code>无法获取有效的元素时，如果有<code>el</code>选项，通过调用<code>getOuterHTML</code>函数获取元素。</p><p><strong>注意这里的<code>el</code>是<code>Element</code>类型</strong>，为什么不是字符串类型的呢？如果在 Runtime 版本时，<code>el</code>可以是字符串类型，即它是一个<code>CSS</code>选择器，然后通过选择器可以获取元素。</p><p>但是在完整版本中，这里需要一个<code>Element</code>类型的<code>template</code>，在前面的逻辑中没有通过<code>template</code>选项获取到<code>template</code>的值，所以这里必须是一个<code>Element</code>类型的值。</p><p>看下<code>getOuterHTML</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span>(<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>el</code>元素是否有<code>outerHTML</code>，如果有的话，直接返回它的<code>outerHTML</code>。如果没有的话，创建一个<code>div</code>容器，然后把<code>el</code>元素的克隆值放入容器中，最后返回容器的<code>innerHTML</code>，也就是返回<code>el</code>元素。</p><p>为什么不直接创建一个元素再返回它呢？因为有的元素可能没有<code>innerHTML</code>或者<code>outerHTML</code>属性，比如<code>SVG</code>标签元素在 <code>IE 9-11</code>时就没有<code>innerHTML</code>和<code>outerHTML</code>属性。此时，如果<code>el</code>选项是<code>SVG</code>标签元素就会出错。如果先创建一个<code>div</code>容器元素，然后把一个克隆元素放进去，再返回容器元素的<code>innerHTML</code>就不会有问题，因为这个容器元素的<code>innerHTML</code>是一定存在的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// ! 测试编译性能之开始</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">'compile'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// ! 测试编译性能之结束</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">'compile end'</span>)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取到<code>template</code>元素后，执行下面的编译操作。</p><p>这里在非生产环境中测试<code>compile</code>的性能。</p><p>再看下性能测试的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 生成渲染函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">  template,</span><br><span class="line">  &#123;</span><br><span class="line">    outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">    shouldDecodeNewlines,</span><br><span class="line">    shouldDecodeNewlinesForHref,</span><br><span class="line">    delimiters: options.delimiters, <span class="comment">// ! 分隔符配置，是个数组，默认是 ["&#123;&#123;", "&#125;&#125;"]</span></span><br><span class="line">    comments: options.comments <span class="comment">// ! 评论配置</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">this</span></span><br><span class="line">)</span><br><span class="line">options.render = render</span><br><span class="line">options.staticRenderFns = staticRenderFns</span><br></pre></td></tr></table></figure><p>通过调用<code>compileToFunctions</code>函数生成了渲染函数<code>render</code>和静态渲染函数<code>staticRenderFns</code>。然后把它们存储在<code>options</code>中，即存储在<code>vm.$options</code>中。</p><p><strong>小结</strong>，完整版本的<code>$mount</code>方法继承了 Runtime 版本的方法，然后把模板字符串编译成渲染函数，并把渲染方法存储在<code>vm.$options</code>中。</p><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a><code>mountComponent</code></h2><p>下面我们来看下<code>mountComponentmountComponent</code>函数，<code>$mount</code>方法最终都会调用的这个函数，它才是真正挂载组件的方法，这个函数在<code>core/instance/lifecycle.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 挂载组件的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el <span class="comment">// ! 更新 $el 属性</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用传进来的参数<code>el</code>更新<code>vm.$el</code>的值。<strong>注意</strong>，这里<code>vm.$el</code>的值也不是最后真正挂载的元素，后面再讲解。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">  vm.$options.render = createEmptyVNode <span class="comment">// ! render 会生成一个空的 VNode</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">      vm.$options.el ||</span><br><span class="line">      el</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 Vue 的实例对象中是否存在渲染函数<code>render</code>，如果不存在，渲染函数会被赋值为一个生成一个空的<code>VNode</code>（虚拟节点）的函数，然后在非生产环境中，判断<code>template</code>是否以<code>#</code>开头或者存在<code>el</code>，如果是的话，会警告在 Runtime 环境中无法编译元素；如果不是的话，会警告<code>template</code>或者渲染函数未定义。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeMount'</span>) <span class="comment">// ! 挂载组件之前，调用 beforeMount 钩子函数</span></span><br></pre></td></tr></table></figure><p>在挂载组件之前，执行<code>beforeMount</code>生命周期钩子函数。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 更新组件的函数</span></span><br><span class="line"><span class="keyword">let</span> updateComponent</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = vm._name</span><br><span class="line">    <span class="keyword">const</span> id = vm._uid</span><br><span class="line">    <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    mark(startTag) <span class="comment">// ! 开始统计 _render 函数性能</span></span><br><span class="line">    <span class="keyword">const</span> vnode = vm._render() <span class="comment">// ! 生成 VNode</span></span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">    mark(startTag) <span class="comment">// ! 开始统计 _update 函数性能</span></span><br><span class="line">    vm._update(vnode, hydrating) <span class="comment">// ! 将 VNode 渲染到真实 `DOM` 中</span></span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明一个公共的变量<code>updateComponent</code>用来存储函数，在生产环境和非生产环境中这个函数有一点不一样，因为在非生产环境中需要测量函数里面的<code>vm._render</code>方法和<code>vm._update</code>方法的性能。</p><p>这两个方法的作用分别是：</p><ul><li><code>vm._render</code>：调用 <code>vm.$options.render</code> 函数并返回生成的虚拟节点(<code>vnode</code>)。</li><li><code>vm._update</code>：把 <code>vm._render</code> 函数生成的虚拟节点渲染成真正的元素。</li></ul><p>先看下生产环境的中<code>updateComponent</code>函数的代码，只有一行代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating) <span class="comment">// ! 把 _render 生成的 VNode 渲染成真实的 `DOM`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，调用<code>vm._update</code>方法把<code>vm._render</code>方法生成的<code>VNode</code>渲染成真实的元素。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 生成观察者实例</span></span><br><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent, <span class="comment">// ! 更新组件的函数，执行时 -&gt; 执行 vm.$options.render -&gt; getter -&gt; 收集依赖</span></span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>) <span class="comment">// ! 传入 beforeUpdate 生命周期钩子函数，在更新前组件前调用</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过<code>new</code>操作符生成一个观察者<code>Watcher</code>实例对象。</p><p>到这里，响应式系统的观察者也终于露出水面了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面章节主要通过&lt;code&gt;initData&lt;/code&gt;函数在初始化&lt;code&gt;data&lt;/code&gt;选项的过程来讲解 Vue 的响应式系统。&lt;/p&gt;
&lt;p&gt;主要讲了响应式系统中的工厂函数&lt;code&gt;observe&lt;/code&gt;和监听器&lt;code&gt;Observer&lt;/code&gt;以及如何定义响应式属性的&lt;code&gt;defineReactive&lt;/code&gt;函数。因为响应式的原理是使用&lt;code&gt;Object.defineProperty&lt;/code&gt;来定义对象数据的，所以还需要对数组类型的数据进行特殊处理，重写数组的一些常用方法，使得数组中的元素也和对象里面的数据一样，可以收集依赖和触发依赖。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之Set和Del</title>
    <link href="https://haledeng.com/blog/20190917-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BSet%E5%92%8CDel/"/>
    <id>https://haledeng.com/blog/20190917-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BSet%E5%92%8CDel/</id>
    <published>2019-09-17T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:57.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="set-函数"><a href="#set-函数" class="headerlink" title="set 函数"></a><code>set</code> 函数</h2><p>下面看下<code>set</code>函数，我们在扩展 Vue 的构造函数的原型对象时创建<code>Vue.prototype.$set</code>方法，然后在扩展 Vue 的构造函数的静态方法时创建<code>Vue.set</code>方法，这两个方法所赋值的函数都是<code>set</code>函数。</p><p>在 Vue 的官方文档中，提供了这两个 API 供用户使用，用来向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性。另外，注意设置的对象不能是 Vue 实例或者 Vue 实例的根数据对象。</p><a id="more"></a><p>下面查看<code>set</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在非生产环境中，判断<code>taregt</code>的类型是不是未定义的值或者是一个原始类型的值，如果满足其中之一的话会报错，并提示不能设置<code>null</code>、<code>undefined</code>或者原始类型中的响应式属性。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! target 是数组且 key 有效时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">  target.length = <span class="built_in">Math</span>.max(target.length, key) <span class="comment">// ! 修改数组长度 key, 否则大于原数组长度时 splice 无效</span></span><br><span class="line">  target.splice(key, <span class="number">1</span>, val) <span class="comment">// ! 使用重写的 splice 增加或者替换元素，并触发响应</span></span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义的响应式对象是数组时且它里面的<code>key</code>值是有效值时，先获取数组长度和<code>key</code>的中最大值，把它设置为<code>taregt</code>的长度。为什么要这样做呢？因为如果设置的<code>key</code>大于原来<code>taregt</code>的长度，使用<code>splice</code>是插入元素时，插入后的元素在数组中的位置会不正确，即索引不正确。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// length = 3</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="number">5</span></span><br><span class="line">arr.splice(key, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>上面代码中 key 是<code>5</code>，它比数组<code>arr</code>的长度<code>3</code>要大，把数字<code>4</code>传入到<code>key</code>的位置后，它的位置是错误的。</p><p>如果修改了<code>target</code>的长度为<code>key</code>和原来长度的最大值后，插入后的位置是不一样的。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> key = <span class="number">5</span></span><br><span class="line">arr.length = <span class="built_in">Math</span>.max(arr.length, key)</span><br><span class="line">arr.splice(key, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, 3, &lt;2 empty items&gt;, 4 ]</span></span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! key 已经存在对象 target 且不在它的原型中时</span></span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">  target[key] = val <span class="comment">// ! 直接修改原来的值，会自动触发 setter</span></span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的<code>key</code>已经存在于响应式对象中但不在它的原型对象上时，直接赋值即可，会自动触发<code>setter</code>，最后返回设置的新值。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 获取原对象的 __ob__ 属性</span></span><br><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"><span class="comment">// ! 不允许设置 Vue 实例 和 根实例数据对象（根 data 不是响应式的）的属性</span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +</span><br><span class="line">        <span class="string">'at runtime - declare it upfront in the data option.'</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量<code>ob</code>存储<code>target</code>的<code>__ob__</code>属性，判断<code>target</code>是否有<code>_isVue</code>属性或者<code>ob.vmCount</code>的值是否大于零。如果同时满足其中的一个条件且在非生产环境中会报错，提示不能设置 Vue 实例对象的属性或者根组件的<code>data</code>选项的值，最后返回设置的值<code>val</code>。</p><p>继续看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 原对象不是响应式对象，新属性直接赋值并返回</span></span><br><span class="line"><span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">  target[key] = val</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line">defineReactive(ob.value, key, val) <span class="comment">// ! 新属性变成响应式</span></span><br><span class="line">ob.dep.notify() <span class="comment">// ! 手动触发依赖</span></span><br><span class="line"><span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><p>判断<code>ob</code>是否存在，即判断<code>taregt</code>是否是一个响应式对象，如果不是的话，直接给它的<code>key</code>赋值为<code>val</code>，并返回<code>val</code>。</p><p>如果<code>taregt</code>是一个响应式对象，把它新增的值也变成响应式数据，然后手动触发依赖，并返回设置的值<code>val</code>。</p><p><strong>小结</strong>，虽然 Vue 的官方文档中说明只能是为响应式数据设置值，但是它的代码中也可以为非响应式的对象设置值，不过我们在实际开发中没有必要这样，因为可以直接在这个对象上操作，而不需要额外使用这个 API。</p><h2 id="del"><a href="#del" class="headerlink" title="del"></a><code>del</code></h2><p>下面看下<code>del</code>函数，我们在扩展 Vue 的构造函数的原型对象时创建<code>Vue.prototype.$delete</code>方法，然后在扩展 Vue 的构造函数的静态方法时创建<code>Vue.delete</code>方法，这两个方法所赋值的函数都是<code>del</code>函数。</p><p>在 Vue 的文档中，提供了这两个 API 供用户使用，用来删除对象的属性。如果对象是响应式对象，确保删除值能触发依赖，更新视图。如果不是响应式对象，直接删除它即可。</p><p>这个方法是为了避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p><p>下面查看<code>del</code>函数的代码，它的结构和<code>set</code>函数很相似，下面结合<code>set</code>来对比讲解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">target: Array&lt;any&gt; | Object, key: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Cannot delete reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先和<code>set</code>函数一样，判断<code>taregt</code>的类型是不是未定义的值或者是一个原始类型的值，如果满足其中之一的话会报错，并提示不能删除<code>null</code>、<code>undefined</code>或者原始类型中的响应式属性。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">  target.splice(key, <span class="number">1</span>) <span class="comment">// ! splice 删除元素，并触发响应</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>taregt</code>的类型是不是数组且它的索引是否有效的，如果都满足条件的话，直接调用<code>splice</code>删除索引<code>key</code>位置的值即可。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 不能删除 Vue 实例 和 根实例数据对象（根 data 不是响应式的）的属性</span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Avoid deleting properties on a Vue instance or its root $data '</span> +</span><br><span class="line">        <span class="string">'- just set it to null.'</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>set</code>函数中逻辑的一样，声明常量<code>ob</code>存储<code>target</code>的<code>__ob__</code>属性，判断<code>target</code>是否有<code>_isVue</code>属性或者<code>ob.vmCount</code>的值是否大于零。如果同时满足其中的一个条件且在开发中会报错，提示不能删除 Vue 实例对象的属性或者根组件的<code>data</code>选项的值，最后直接返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 没有要删除的属性</span></span><br><span class="line"><span class="keyword">if</span> (!hasOwn(target, key)) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> target[key] <span class="comment">// ! 删除目标的字段</span></span><br></pre></td></tr></table></figure><p>如果<code>target</code>对象上没有要删除的<code>key</code>值，直接返回。如果有的话，调用<code>delete</code>运算符删除<code>target</code>中的<code>key</code>字段或者索引。</p><p>继续看剩下最后的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 目标不是响应式，不处理</span></span><br><span class="line"><span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ob.dep.notify() <span class="comment">// ! 手动触发依赖</span></span><br></pre></td></tr></table></figure><p>如果<code>ob</code>不存在，即<code>taregt</code>不是响应式对象，那么直接返回，不做处理。如果是响应式对象，手动触发依赖，更新视图。</p><p>注意<code>del</code>不需要返回值，也不需要返回一个布尔值来表示删除属性是否成功，这也从侧面说明这个函数关联的<code>Vue.delete</code>和<code>vm.$delete</code> 的 API 使用的场景非常少。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;set-函数&quot;&gt;&lt;a href=&quot;#set-函数&quot; class=&quot;headerlink&quot; title=&quot;set 函数&quot;&gt;&lt;/a&gt;&lt;code&gt;set&lt;/code&gt; 函数&lt;/h2&gt;&lt;p&gt;下面看下&lt;code&gt;set&lt;/code&gt;函数，我们在扩展 Vue 的构造函数的原型对象时创建&lt;code&gt;Vue.prototype.$set&lt;/code&gt;方法，然后在扩展 Vue 的构造函数的静态方法时创建&lt;code&gt;Vue.set&lt;/code&gt;方法，这两个方法所赋值的函数都是&lt;code&gt;set&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;在 Vue 的官方文档中，提供了这两个 API 供用户使用，用来向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性。另外，注意设置的对象不能是 Vue 实例或者 Vue 实例的根数据对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之数组的响应性</title>
    <link href="https://haledeng.com/blog/20190915-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <id>https://haledeng.com/blog/20190915-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/</id>
    <published>2019-09-15T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:52.260Z</updated>
    
    <content type="html"><![CDATA[<p>讲解完对象的响应式定义后，再看下数组的响应式定义，回到<code>Observer</code>的构造函数中，看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="comment">// ! 判断当前环境的对象中是否有 __proto__ 属性 （是否支持使用 __proto__）</span></span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    protoAugment(value, arrayMethods)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.observeArray(value) <span class="comment">// ! 再次监听数组，监听一些嵌套的数组</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>代码块中定义了数组响应式，首先判断宿主环境中是否存在<code>__proto__</code>属性，这个属性是对象的隐式原型对象，只有在 IE 11 以上的浏览器才会支持。</p><p>如果宿主环境支持<code>__proto__</code>，调用<code>protoAugment</code>函数并传入数组类型的<code>value</code>和<code>arrayMethods</code>这两个值作为参数。</p><a id="more"></a><h2 id="arrayMethods"><a href="#arrayMethods" class="headerlink" title="arrayMethods"></a><code>arrayMethods</code></h2><p>先不急着看<code>protoAugment</code>函数，先看下第二个参数<code>arrayMethods</code>是什么，在<code>core/observer/array.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype <span class="comment">// ! 数组原型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto) <span class="comment">// ! 通过数组原型创建的对象</span></span><br></pre></td></tr></table></figure><p><code>arrayMethods</code>是根据数组的原型对象创建传来的对象。但是还没完？继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] <span class="comment">// ! 原生方法</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args) <span class="comment">// ! 原生方法调用生成的值，也是返回值</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted <span class="comment">// ! 数组新增的值, 数组类型</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>) <span class="comment">// ! 获取传入参数的第三个参数以后的值所有值，即新增的值</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted) <span class="comment">// ! 监听新增的值，使其成为响应式</span></span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify() <span class="comment">// ! 手动触发依赖通知</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>methodsToPatch</code>是一些数组常用方法名（字符串类型）组成的数组，通过这些方法可以操作数组中元素的增加、删除或者移位。</p><p>再看下面的代码，遍历<code>methodsToPatch</code>，然后重写<code>arrayMethods</code>对象中的某些方法，这些方法就是在<code>methodsToPatch</code>里面的方法。</p><p>先看遍历函数中的第一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = arrayProto[method] <span class="comment">// ! 原生方法</span></span><br></pre></td></tr></table></figure><p>声明常量<code>original</code>存储数组原型的原生方法。</p><p>继续往下看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用<code>def</code>函数重写<code>arrayMethods</code>对象中的方法。</p><p>看下<code>def</code>的第三个参数<code>val</code>，它现在是一个函数，看这个函数第一行和最后一行的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args) <span class="comment">// ! 调用原生方法生成值，也是返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>传入参数并使用原生方法生成值，然后在最后返回这个值，这样就相当于继承了原生方法。</p><p>然后在中间处理了一些事情，现在看中间的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__ <span class="comment">// ! this 指向数组本身</span></span><br><span class="line"><span class="keyword">let</span> inserted <span class="comment">// ! 数组新增的值, 数组类型</span></span><br><span class="line"><span class="keyword">switch</span> (method) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">    inserted = args</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">    inserted = args.slice(<span class="number">2</span>) <span class="comment">// ! 获取传入参数的第三个参数以后的值所有值，即新增的值</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inserted) ob.observeArray(inserted) <span class="comment">// ! 监听新增的值，使其成为响应式</span></span><br><span class="line"><span class="comment">// notify change</span></span><br><span class="line">ob.dep.notify() <span class="comment">// ! 手动触发依赖通知</span></span><br></pre></td></tr></table></figure><p>首先声明常量<code>ob</code>存储<code>this.__ob__</code>的值，<code>this</code>指向数组本身。我们都知道在初始化<code>data</code>选项时，会使用<code>observe</code>函数监听<code>data</code>选项，然后在<code>data</code>里面添加一个<code>__ob__</code>属性，这个属性存储了<code>Observer</code>实例本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>继续看下面的代码，声明了一个<code>inserted</code>变量，这个变量存储着数组新增的值，它是一个数组。</p><p>再使用<code>switch</code>函数匹配不同方法增加的值，比如<code>push</code>和<code>unshift</code>增加的值，就是传入的参数，可以是一个参数，也可以是多个参数，这时直接赋值。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">arr.push(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">arr.unshift(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 5, 1, 2 ]</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 5, 4, 5, 6, 1, 2 ]</span></span><br></pre></td></tr></table></figure><p>但是<code>splice</code>方法比较特殊，通过这个方法新增的值是从第三个参数开始的。所以使用<code>slice</code>方法从第三个参数开始截取参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inserted = args.slice(<span class="number">2</span>) <span class="comment">// ! 获取传入参数的第三个参数以后的所有值，即新增的值</span></span><br></pre></td></tr></table></figure><p>所以<code>inserted</code>设置成一个数组是比较合理的，因为数组增加元素时，有可能一下子增加好几个元素。</p><p>新增元素后，还需要把增加的元素变成响应式数据，因为增加元素的是数组，不能自动使用<code>Object.defineProperty</code>定义元素，需要使用<code>observeArray</code>方法把它们变成响应式数据。</p><p>看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inserted) ob.observeArray(inserted) <span class="comment">// ! 监听新增的值，使其成为响应式</span></span><br></pre></td></tr></table></figure><p>调用<code>ob</code>中的<code>observeArray</code>把他们变成响应式的。<code>ob</code>是<code>Observer</code>的实例对象，在前面我们知道类<code>Observer</code>有两个方法，前面已经讲解了<code>walk</code>方法，现在讲解另外一个方法，就是刚才调用的``observeArray`方法，下面看这个方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observeArray(items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，就是遍历传入的数组，然后通过<code>observe</code>函数监听数组中的每一个元素，使它们都成为响应式数据。</p><p>当然，最后还需要手动触发依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.dep.notify() <span class="comment">// ! 手动通知，触发依赖</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>这里不只是新增加值需要手动触发依赖，其他的操作比如删除元素、移动元素也是需要手动触发依赖的。因为数组类型的数据没法使用<code>Object.defineProperty</code>这个 API 来监听数据的变化，自动触发依赖。</p><h2 id="protoAugment"><a href="#protoAugment" class="headerlink" title="protoAugment"></a><code>protoAugment</code></h2><p>继续回到类<code>Observer</code>的构造函数中，如果宿主环境支持<code>__proto__</code>时，调用<code>protoAugment</code>方法并把``value<code>和</code>arrayMethods`作为参数传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">  protoAugment(value, arrayMethods)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.observeArray(value) <span class="comment">// ! 再次监听数组，监听一些嵌套的数组</span></span><br></pre></td></tr></table></figure><p>了解第二个参数<code>arrayMethods</code>对象后，现在可以参看<code>protoAugment</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收两个参数<code>target</code>和<code>src</code>，也就是上面传入的<code>value</code>和<code>arrayMethods</code>，然后用<code>__proto__</code>把它们连接起来。</p><p>使用<code>protoAugment</code>函数把<code>value</code>和<code>arrayMethods</code>通过原型连接起来，这样数组类型的监听对象<code>value</code>也继承了<code>arrayMethods</code>对象的变异方法（重写的方法），在数组增加元素的时候也可以使增加的元素变成响应式数据，还能触发<code>value</code>中依赖的更新。</p><h2 id="copyAugment"><a href="#copyAugment" class="headerlink" title="copyAugment"></a><code>copyAugment</code></h2><p>接下来看下在不支持<code>__proto__</code>的宿主环境中，是如何处理数组类型的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyAugment(value, arrayMethods, arrayKeys)</span><br></pre></td></tr></table></figure><p>使用了<code>copyAugment</code>函数，这个函数比<code>protoAugment</code>多传入了一个参数，现在看下多出来的第三个参数<code>arrayKeys</code>是什么样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods)</span><br></pre></td></tr></table></figure><p>原来是获取<code>arrayMethods</code>对象中所有属于自身的属性名，即<code>key</code>值（不是原型链上的方法）。</p><p>它应该是下面这个样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayMethods = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>现在看下<code>copyAugment</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span>(<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不能使用隐式原型对象<code>__proto__</code>连接<code>target</code>和<code>src</code>。</p><p>这里重定义的方法，遍历<code>keyskeys</code>，在每次循环时，获取到<code>key</code>值，就是那些常用的数组方法。然后使用<code>def</code>函数重写<code>target</code>中的这些方法，让它们变成<code>src</code>对象，也就是传入的<code>arrayMethods</code>对象的变异方法。</p><p>这样就和上面的原型继承达到相同的目的，即数组类型的数据在修改数据时，也能触发依赖，然后数据更新，并且会把数组中新增的元素变成响应式数据。</p><p>接下来看最后一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.observeArray(value) <span class="comment">// ! 再次监听数组，监听一些嵌套的数组</span></span><br></pre></td></tr></table></figure><p>使用<code>observeArray</code>方法监听<code>value</code>值，主要是防止数组类型数据里面还存在着数组，也就是嵌套数组，把嵌套数组里面的元素也变成响应式数据。</p><h2 id="dependArray"><a href="#dependArray" class="headerlink" title="dependArray"></a><code>dependArray</code></h2><p>把数组类型的数据变成响应式数据过程我们已经了解了，现在看下数组类型的数据是怎么收集依赖的。</p><p>在<code>defineReactive</code>函数定义<code>getter</code>的时候，有以下代码，在<code>core/observer/index.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  dep.depend() <span class="comment">// ! 添加进订阅器，依赖收集</span></span><br><span class="line">  <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">    childOb.dep.depend() <span class="comment">// ! 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      dependArray(value) <span class="comment">// ! 数组手动收集依赖</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断下<code>value</code>的值是否是数组，如果是数组，调用<code>dependArray</code>函数收集依赖。</p><p>先看下<code>dependArray</code>函数的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span>(<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() <span class="comment">// ! 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e) <span class="comment">// ！递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的逻辑很简单，遍历数组的值，然后调用它的<code>ob</code>进行依赖收集，如果这个值还是一个数组，递归调用这个函数。</p><p>因为数组的结构和对象不同，<strong><code>Object.defineProperty</code>这个属性有局限性，它只能定义对象<code>key</code>的值，而无法定义数组索引的值</strong>，也就是说无法给数组里面的元素添加<code>getter</code>属性。当读取数组中的值时，也就不会触发<code>getter</code>函数自动取收集依赖，所以需要<strong>手动收集依赖</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>首先虽然我们可以给数组中添加<code>__ob__</code>属性，不能使用<code>Object.defineProperty</code>来定义数组中是索引值，因为<code>Object.defineProperty</code>的<strong>局限性</strong>，它只支持对象而不支持数组。Vue 3.0 中使用<code>Proxy</code>就不会发生这种情况。</p><p>也就是说数组里面的元素，没有属性描述符，也没有<code>getter</code>和<code>setter</code>，即不能自动收集依赖和触发依赖。既然不能自动，那就手动呗。</p><p>在<code>gettter</code>中，使用<code>dependArray</code>函数手动收集数组的依赖。</p><p>然后把数组类型的属性通过原型链连接<code>arrayMethods</code>来继承<code>arrayMethods</code>重写的一些变异方法；或者通过重新定义的方法，把数组类型的属性一些方法替换成<code>arrayMethods</code>的变异方法。</p><p>这样数组使用这些方法时，就会执行变异方法中我们设置的逻辑，这相当于对象类型的<code>key</code>触发<code>setter</code>一样，数组中的元素也能触发依赖，更新视图，然后对于数组新增的元素，也会把它们变成响应式数据。</p><h2 id="vmCount"><a href="#vmCount" class="headerlink" title="vmCount"></a><code>vmCount</code></h2><p>到这样已经完全讲解了<code>Observer</code>构造函数，然后我们再次回到<code>observer</code>函数中，这个函数还剩下最后一点代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 对象是根实例数据对象时， vmCount++</span></span><br><span class="line"><span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">  ob.vmCount++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure><p>还记得<code>initData</code>在初始化<code>data</code>选项时的最后一行代码嘛</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observe data</span></span><br><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) <span class="comment">// ! 把 data 上的属性变成响应式的</span></span><br></pre></td></tr></table></figure><p>使用<code>observe</code>函数时传入了第二个参数<code>asRootData</code>，它的值为<code>true</code>，说明最开始初始化的<code>data</code>是根组件的数据。</p><p>然后我们发现在后面监听数据时，一般都不会传入第二个参数，它的值就是默认值<code>undefined</code>，转换成布尔值就是<code>false</code>，说明监听的数据不是根组件数据。</p><p>回到下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">  ob.vmCount++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure><p>只有在根组件且监听根组件数据时，<code>ob.vmCount</code>的值是递增的，而<code>ob.vmCount</code>在类<code>Observer</code>的构造函数中声明的初始值是<code>0</code>，所以根组件的数据<code>ob.vmCount</code>的值永远是大于<code>0</code>的，<code>observe</code>函数最后返回<code>ob</code>实例。</p><p>那么是不是可以这样理解，只要是根组件数据，那么它的<code>__ob__</code>中的<code>vmCount</code>就大于<code>0</code>。这样的话，就可以通过判断<code>ob.vmCount</code>的值是否大于<code>0</code>来确定组件是不是根组件，或者监听的数据是不是根组件数据了。</p><p><strong>为什么要专门区分根组件数据和非根组件数据呢</strong>？它们之间有什么区别吗？</p><p>因为一开始在初始化根数据之前，根数据<code>data</code>是非响应式的，这时候如果使用<code>Vue.set</code>或者<code>vm.$set</code>为<code>data</code>选项里面的对象添加值是不可能成功的，因为<code>Vue.set</code>或者<code>vm.$set</code>只能为响应式对象添加属性。</p><p>只有当<code>data</code>数据被观察者依赖时，才能收集依赖到订阅器中，这样之后才能使用<code>Vue.set</code>或者<code>vm.$set</code>为<code>data</code>添加属性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解完对象的响应式定义后，再看下数组的响应式定义，回到&lt;code&gt;Observer&lt;/code&gt;的构造函数中，看下面的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.isArray(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ! 判断当前环境的对象中是否有 __proto__ 属性 （是否支持使用 __proto__）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hasProto) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    protoAugment(value, arrayMethods)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    copyAugment(value, arrayMethods, arrayKeys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.observeArray(value) &lt;span class=&quot;comment&quot;&gt;// ! 再次监听数组，监听一些嵌套的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;代码块中定义了数组响应式，首先判断宿主环境中是否存在&lt;code&gt;__proto__&lt;/code&gt;属性，这个属性是对象的隐式原型对象，只有在 IE 11 以上的浏览器才会支持。&lt;/p&gt;
&lt;p&gt;如果宿主环境支持&lt;code&gt;__proto__&lt;/code&gt;，调用&lt;code&gt;protoAugment&lt;/code&gt;函数并传入数组类型的&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;arrayMethods&lt;/code&gt;这两个值作为参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之响应式定义</title>
    <link href="https://haledeng.com/blog/20190912-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9A%E4%B9%89/"/>
    <id>https://haledeng.com/blog/20190912-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9A%E4%B9%89/</id>
    <published>2019-09-12T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:46.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defineReactive定义响应式的方法"><a href="#defineReactive定义响应式的方法" class="headerlink" title="defineReactive定义响应式的方法"></a><code>defineReactive</code>定义响应式的方法</h2><p><code>defineReactive</code>函数从名字上看应该是一个定义响应式属性的函数。</p><p>下面看它的代码，在<code>core/observer/index.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在前面调用<code>initRender</code>函数中定义<code>vm.$attrs</code>和<code>vm.$listeners</code>属性的时候就已经使用过<code>defineReactive</code>函数。</p><p>先看这个函数的参数，有五个参数。前面三个参数分别是定义的对象<code>obj</code>以及它的<code>key</code>值和<code>val</code>值，这些参数是定义响应式属性时会用到的属性。其中第一个参数<code>obj</code>和第二个参数<code>key</code>是一定要传入的，第三个参数<code>val</code>可以在函数中通过<code>val[key]</code>来获取。</p><a id="more"></a><p>第四个参数<code>customSetter</code>，是一个自定义的<code>setting</code>函数。在非生产环境中，可以设置一个用来提醒或者报错的函数。</p><p>第五个参数<code>shallow</code>是个布尔值，表示是否开启深度监听，当它的值为<code>false</code>时开启深度监听，这个参数一般是不会传入的，也就是说它的值默认是<code>undefined</code>，然后在使用它的时候可以取反，即<code>!shallow</code>的值为<code>true</code>，这样就会开启深度监听。</p><p>下面看函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() <span class="comment">// ! 实例化一个订阅器</span></span><br><span class="line"><span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key) <span class="comment">// ! 获取对象的 key 属性描述符</span></span><br><span class="line"><span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>先看第一行代码，实例化一个订阅器对象<code>dep</code>，用来收集观察者依赖。然后尝试获取对象<code>obj</code>中<code>key</code>的属性描述符。</p><p>什么是属性描述符呢？就是对象中<code>key</code>的属性描述，它也是一个对象。如下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>然后判断获取到属性描述符且它的<code>configurable</code>的值是否为<code>false</code>，即确认一下这个<code>key</code>的属性是否可以配置（能否被改变），如果<code>configurable</code>的值为<code>false</code>，也就是说<code>key</code>是不可配置的，那么直接返回。</p><p>再看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line"><span class="comment">// ! 缓存对象原先定义的 getter/setters</span></span><br><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line"><span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"><span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性描述符既然是<code>key</code>的属性描述，那么它里面可能会有<code>getter</code>和<code>setter</code>属性，尝试去获取它们的值。</p><p>然后是一个条件语句，判断是否只能获取<code>setter</code> 或者没有<code>getter</code>，并且函数的参数只有两个，即只传入前面的<code>obj</code>和<code>key</code>这两个参数，当满足条件时，获取<code>val</code>的值。</p><p>为什么这里要获取<code>val</code>的值呢？因为在<code>walk</code>方法中调用<code>defineReactive</code>时只传了前面两个参数，并没有传第三个参数<code>val</code>，所以应该需要获取<code>val</code>的值，这也满足条件语句的第二个条件。</p><p>然后再看第一个条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!getter || setter</span><br></pre></td></tr></table></figure><p>需要满足没有<code>getter</code>或者有<code>setter</code>这两个条件中的一个才行。这个要怎么理解呢？</p><p>先看下条件语句之后的这行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// ! 当 val 不为 undefined 深度监听</span></span><br></pre></td></tr></table></figure><p>如果不满足上面条件语句中的两个条件的话，在深度监听的时候，<code>val</code>的值就是<code>undefined</code>，<code>observe(val)</code>就不会被有效的执行，所以也就不会生成实例对象<code>childOb</code>，也就是这时候深度监听是失败的。</p><p>也就是说如果不满足上面的条件，就获取不到<code>val</code>，也就不会对<code>val</code>执行深度监听。</p><p>看下满足条件<code>!getter || setter</code>的三种情况</p><ol><li>有<code>getter</code>也有<code>setting</code>（假真）：在属性被<code>observe</code>监听后会满足这种情况。</li><li>没有<code>getter</code>也没有<code>setting</code>（真假）：在属性变成响应式数据前会满足这种情况。</li><li>没有<code>getter</code>有<code>setting</code>（真真）：这种情况比较少见。</li></ol><p>再看下不满条件的情况也就是（假假），即有<code>getting</code>而没有<code>setting</code>，我们可以举个例子，看下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const data = &#123;a: &#123; b: 1 &#125;&#125; 对比一般的字面量声明对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line"><span class="comment">// 使用 Object.defineProperty 只定义 getter</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'a.b'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'监听到a.b'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.vm = vm</span><br></pre></td></tr></table></figure><p>在控制台上输入<code>vm._data</code>，输出下面结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  __ob__: &#123;</span><br><span class="line">    value: &#123;<span class="comment">/* */</span>&#125;,</span><br><span class="line">    dep: &#123;<span class="comment">/* */</span>&#125;,</span><br><span class="line">    vmCount: someNumber</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>data</code>选项里面的对象<code>a</code>中并没有<code>__ob__</code>这个属性，说明数据<code>a</code>并没有被深度监听，此时如果修改对象<code>a</code>里面的<code>b</code>属性，是不会被<code>watch</code>选项里面的监听函数监听到的。<br>但是我们在字面量定义<code>data</code>选项的数据时，对象<code>a</code>里面是有<code>__ob__</code>属性的，因为深度监听是默认开启的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>，一般情况下<code>val</code>都是会去尝试获取值并且对它执行深度监听。只有在特殊场景下才不会去获取值，具体是什么特特殊场景，后面遇到再讲。</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a><code>getter</code></h3><p>接下来看下<code>defineReactive</code>函数中是怎么定义<code>getter</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.call(obj) : val <span class="comment">// ! 获取值</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      dep.depend() <span class="comment">// ! 添加进订阅器，依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          dependArray(value) <span class="comment">// ! 数组手动收集依赖</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment">// ! 返回值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function reactiveSetter(newVal) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明常量<code>value</code>存储获取到<code>val</code>的值，同时也作为<code>getter</code>的返回值。</p><p>怎么获取<code>val</code>的值？判断该数据原是否已经定义过<code>getter</code>，如果已经定义过就直接调用原先的<code>getter</code>进行求值，否则返回上面获取的<code>val</code>值。</p><p>为什么要调用原先定义的<code>getter</code>来返回值呢？因为不能去重复定义<code>getter</code>，这样会把以前的定义的<code>getter</code>覆盖掉。</p><p>然后判断<code>Dep.target</code>是否有值（观察者），如果有值的话，使用订阅器对象<code>dep</code>收集观察者依赖。如果有<code>childOb</code>，也就是说当前的<code>value</code>应该是一个对象，同样让<code>childOb.dep</code>收集观察者依赖，这个<code>childOb</code>就是对象<code>value</code>里面的<code>__ob__</code>属性。</p><p><strong>注意</strong>，这两个<code>dep</code>收集到的依赖是<strong>一样</strong>的，<strong>但是它们触发依赖的时机不一样</strong>，我们在修改<code>value</code>的值后，会执行它的<code>setter</code>，会触发<code>obj</code>中的<code>ob</code>的依赖执行。</p><p>但是如果<code>value</code>也是一个对象类型时，当为这个对象添加或者删除属性时，这时是不会触发<code>obj</code>的<code>ob</code>的依赖执行的。因为新增的属性或者删除的属性中里面并没有<code>setter</code>，但是<code>value</code>确实被修改了。这时会触发<code>value</code>里面的<code>ob</code>（也就是<code>childOB</code>）中的依赖执行。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user: &#123;</span><br><span class="line">  name: <span class="string">'hale'</span>,</span><br><span class="line">  info: &#123;</span><br><span class="line">age: <span class="number">18</span>,</span><br><span class="line">    score: <span class="number">99</span>,</span><br><span class="line">    __ob__: &#123;<span class="comment">/* */</span>&#125; <span class="comment">// childOb</span></span><br><span class="line">  &#125;,</span><br><span class="line">  __ob__: &#123;<span class="comment">/* */</span>&#125; <span class="comment">// ob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们修改<code>user</code>数据下面的<code>name</code>时，比如把<code>hale</code>修改为<code>bill</code>，这时会触发<code>ob</code>中依赖的更新。或者修改<code>info</code>的值为<code>null</code>时，也会触发<code>ob</code>中依赖的更新。但是当我们修改<code>info</code>里面的值时，比如为它添加一个新的属性<code>gender</code>，它的值为<code>man</code>，这时候就不会触发<code>ob</code>中依赖的更新，而是会触发<code>childOb</code>中依赖的更新。另外，<code>ob</code>和<code>childOB</code>里面的依赖是一样的。</p><p>有<code>childOb</code>说明是深度监听，说明监听对象<code>obj</code>里面的<code>value</code>也是一个对象类型。这时再判断<code>value</code>是不是一个数组，如果是数组，调用<code>dependArray</code>手动收集依赖，因为数组里面的索引值是不会自动收集依赖的。后面讲解数组的响应式时再详细讲解它是如何收集依赖的。</p><p><strong>总结</strong>，<code>getter</code>函数有两个作用，一个是返回正确的值，另一个就是收集依赖。</p><h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a><code>setter</code></h3><p>下面看下<code>setter</code>的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val <span class="comment">// ! 获取值 (旧值)</span></span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="comment">// !                    NaN === NaN false</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">    customSetter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal) <span class="comment">// ! 执行原来的 setter, 设置新值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal <span class="comment">// ! 设置新值</span></span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal) <span class="comment">// ! 深度监听新值（对象或者数组）</span></span><br><span class="line">  dep.notify() <span class="comment">// ! 通知观察者, 触发依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明常量<code>value</code>存储获取到<code>val</code>的值。怎么获取<code>val</code>的值？判断属性原先是否已经定义过<code>getter</code>，如果已经定义过就直接调用原先的<code>getter</code>进行求值，否则返回上面获取的<code>val</code>值。</p><p><strong>注意这里获取的值是修改前的值</strong>，也就是旧值。而<strong>修改后的值就是新值</strong>是通过参数<code>newVal</code>传进来的。</p><p>然后比较新值和旧值是否全等，如果全等，直接返回，不需要进行下面的操作。</p><p>这里有个判断条件非常古怪，即新值的本身不等于新增，旧值的本身不等于旧值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newVal !== newVal &amp;&amp; value !== value</span><br></pre></td></tr></table></figure><p>请问可能存在这种奇怪的现象吗？答案是肯定的。JavaScript 中就存在一个特殊的值<code>NaN</code>，它不等于它自身，也就是说如果新值或者旧值是<code>NaN</code>的时候，也是直接返回。</p><p>继续看下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">  customSetter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>customSetter</code>是<code>defineReactive</code>函数的第四个参数，是一个自定义的<code>setter</code>函数，如果这个参数有值的话且在非生产环境时，会在这里执行，这个函数都是一个警告或者提示的函数。</p><p>比如在<code>initRender</code>函数初始化实例对象的<code>$attrs</code>和<code>$listeners</code>属性时传入的函数，看它的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">  !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个函数是在不是更新子组件时修改<code>$attrs</code>属性的时候，会提示<code>$attrs</code>是可读的。</p><p>继续看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line"><span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> (setter) &#123;</span><br><span class="line">  setter.call(obj, newVal) <span class="comment">// ! 执行原来的 setter, 设置新值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = newVal <span class="comment">// ! 设置新值</span></span><br><span class="line">&#125;</span><br><span class="line">childOb = !shallow &amp;&amp; observe(newVal) <span class="comment">// ! 深度监听新值（对象或者数组）</span></span><br><span class="line">dep.notify() <span class="comment">// ! 触发依赖，通知观察者</span></span><br></pre></td></tr></table></figure><p>判断原来的属性描述符中是否只有<code>getter</code>而没有<code>setter</code>，如果是的话，直接返回。因为这个属性既然原来只设置了<code>getter</code>而没有设置<code>setter</code>，这里也不用画蛇添足的去设置<code>setter</code>。</p><p>判断原来是否有<code>setter</code>，如果有的话，调用原来的<code>setter</code>并传入新值；如果没有的话，直接把新值赋值给旧值。这里和<code>getter</code>中原因是一样的，原先的属性已经定义过<code>setter</code>，就不需要再重新定义<code>setter</code>，而是直接调用它。</p><p>然后深度监听这个设置的新值。因为设置的新值可能也是一个对象类型的值，这时需要进行深度监听。</p><p><code>setter</code>函数在最后会触发依赖，通知观察者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.notify() <span class="comment">// ! 触发依赖，通知观察者</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong>，<code>setter</code>函数有两个作用，一个是正确修改值，另一个就是触发依赖。</p><h3 id="childOb"><a href="#childOb" class="headerlink" title="childOb"></a><code>childOb</code></h3><p>经过<code>Object.defineProperty</code>定义过的数据，在修改数据的值时，会触发其中的<code>setting</code>的执行，触发依赖的执行，更新视图。这里触发的依赖是和这个数据平级的<code>__ob__</code>属性中<code>dep</code>收集的依赖。</p><p>如果这个数据是一个对象类型的值，当它在新增或者删除属性时，也相对于改变了值，但是它改变的是数据里面的值，但是也需要去触发依赖，更新视图的。不过实际上它并不会触发和属性平级的<code>__ob__</code>属性里面的<code>dep</code>收集的依赖执行的。</p><p>这时候就需要使用到<code>childOb</code>，使用它的<code>dep</code>收集的依赖来触发依赖。<code>childOb</code>就是在数据里面的<code>__ob__</code>属性。在我们使用<code>Vue.set/Vue.delete</code>或者<code>vm.$set/vm.$delete</code>更新数据时，执行的依赖都是<code>childOb</code>中的依赖。</p><p>比如现在有一个<code>data</code>选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  c: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data</code>选项是响应式的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    __ob__: &#123; value, dep, vmCount &#125; <span class="comment">// childOb</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">  __ob__: &#123; value, dep, vmCount &#125; <span class="comment">// ob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们修改对象<code>a</code>的值，必须把它变成<code>a:1</code>，这时会触发<code>ob1</code>中<code>dep</code>收集的依赖，即执行<code>a.__ob__.dep.notify</code>代码。修改<code>c</code>的值也是一样的。</p><p>但是如果我们修改的是<code>a</code>里面的值，比如新增一个属性，比如给对象<code>a</code>新值属性<code>bb</code>，它的值为 2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(a, <span class="string">'bb'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>或者直接修改<code>b</code>的值，这时候还是会触发对象<code>a</code>依赖执行的，不过现在触发的不是<code>ob1</code>下面的<code>dep</code>收集的依赖，而是<code>ob</code>里面的<code>dep</code>收集的依赖，即执行<code>a.b.__ob__.dep.notify()</code>代码，也就是<code>childOb</code>里面的代码。</p><p>在我们使用<code>Vue.delete</code>或者<code>vm.$delete</code>修改值也是一样的情况。</p><p>至于如何执行<code>childOb</code>的代码，触发依赖，在我们学习到<code>set</code>和<code>delete</code>函数时会详细分析。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;defineReactive定义响应式的方法&quot;&gt;&lt;a href=&quot;#defineReactive定义响应式的方法&quot; class=&quot;headerlink&quot; title=&quot;defineReactive定义响应式的方法&quot;&gt;&lt;/a&gt;&lt;code&gt;defineReactive&lt;/code&gt;定义响应式的方法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;defineReactive&lt;/code&gt;函数从名字上看应该是一个定义响应式属性的函数。&lt;/p&gt;
&lt;p&gt;下面看它的代码，在&lt;code&gt;core/observer/index.js&lt;/code&gt;文件中&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;defineReactive&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  obj: Object,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  key: string,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  val: any,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  customSetter?: ?Function,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;  shallow?: boolean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其实在前面调用&lt;code&gt;initRender&lt;/code&gt;函数中定义&lt;code&gt;vm.$attrs&lt;/code&gt;和&lt;code&gt;vm.$listeners&lt;/code&gt;属性的时候就已经使用过&lt;code&gt;defineReactive&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;先看这个函数的参数，有五个参数。前面三个参数分别是定义的对象&lt;code&gt;obj&lt;/code&gt;以及它的&lt;code&gt;key&lt;/code&gt;值和&lt;code&gt;val&lt;/code&gt;值，这些参数是定义响应式属性时会用到的属性。其中第一个参数&lt;code&gt;obj&lt;/code&gt;和第二个参数&lt;code&gt;key&lt;/code&gt;是一定要传入的，第三个参数&lt;code&gt;val&lt;/code&gt;可以在函数中通过&lt;code&gt;val[key]&lt;/code&gt;来获取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之监听器</title>
    <link href="https://haledeng.com/blog/20190910-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://haledeng.com/blog/20190910-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2019-09-10T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最核心的地方就是它的响应式系统，这是它最核心的精华，也是明显区别于其他的框架像<code>React</code>、<code>Angular</code>的地方。</p><p>在上一章初始化实例属性的时候，讲解了<code>initState</code>函数，这个函数里面调用了一系列初始化选项的函数，为实例对象<code>vm</code>初始化了很多属性，这些属性大都是和响应式系统相关的。本章主要围绕<code>initData</code>函数来进行，因为初始化<code>data</code>选项几乎涉及到了响应式系统的全部内容。</p><p>先看下<code>initData</code>函数在<code>initState</code>函数中的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">  initData(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>opts</code>中是否有<code>data</code>属性，如果有的话，调用<code>initData</code>函数初始化<code>data</code>选项。</p><p>如果没有的话，把实例对象的私有属性<code>_data</code>设置空对象，并调用<code>observe</code>函数监听这个空对象。</p><p>其实，Vue 还对外提供了<code>$data</code> 属性让我们获取<code>data</code>的值，而<code>$data</code>代理的就是<code>_data</code>的值。</p><a id="more"></a><h2 id="initData"><a href="#initData" class="headerlink" title="initData"></a><code>initData</code></h2><p>下面来看下<code>initData</code>函数的代码，这是初始化<code>data</code>选项的函数。</p><p>先看前面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> ? getData(data, vm) : data || &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明变量<code>data</code>存储<code>vm.$options.data</code>的值，然后判断<code>data</code>的是不是函数，如果是函数，调用<code>getData</code>函数获取<code>data</code>的值；如果不是函数，则<code>data</code>应该是一个对象，返回它或者一个空对象。</p><p>现在看下<code>getData</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data: Function, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>try...catch...finally</code>语句来执行函数，以及捕获可能出现的错误，在<code>try</code>代码块中使用<code>call</code>方法调用<code>data</code>函数。这里传入了两个<code>vm</code>参数，第一个参数表示<code>this</code>指向实例对象<code>vm</code>，第二个参数表示传入实例对象作为函数的参数。</p><p>再看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">  data = &#123;&#125;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">        <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>data</code>是不是普通对象，如果不是，会把<code>data</code>设置成一个空对象，然后在非生产环境中报错，提示<code>data</code>的值必须是一个普通对象。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line"><span class="keyword">const</span> props = vm.$options.props</span><br><span class="line"><span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line"><span class="keyword">let</span> i = keys.length</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">      warn(<span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>, vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">          <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    proxy(vm, <span class="string">`_data`</span>, key) <span class="comment">// ! 代理 data 上的属性 vm.xxx = vm._data.xxx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取<code>data</code>选项的<code>keys</code>的值，再分别获取<code>props</code>和<code>methods</code>的值。然后通过递减<code>keys</code>值的长度来循环<code>keys</code>的值。在非生产环境中，如果<code>methods</code>选项的方法名也含有相同的<code>key</code>值会报错，提示<code>data</code>中已经定义过<code>key</code>的值。如果<code>props</code>选项中也含有相同名称的<code>key</code>时也会报错，提示<code>props</code>中已经定义过<code>key</code>的值。</p><p>再判断<code>key</code>是不是 Vue 中的保留属性，Vue 中的保留属性就是以<code>$</code>或者<code>_</code>开头的属性，也就是说<code>data</code>选项中的数据的名称不能以<code>$</code>或者<code>_</code>开头。如果不是 Vue 的保留属性，会使用<code>proxy</code>函数来代理<code>data</code>上的属性。</p><p>下面看下<code>proxy</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function proxy(target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数使得实例对象<code>vm</code>可以代理<code>data</code>选项的数据。比如，在我们访问<code>this.xxx</code>数据时，其实访问的是<code>this.data.xxx</code>数据。</p><p><code>vm</code>除了会代理<code>data</code>选项的数据，还有代理<code>props</code>、<code>methods</code>和<code>computed</code>等选项中的值，所以这些选项里面的属性（方法）名不能重名。通过代理选项中属性，我们会更方便的使用这些选项上的属性（方法）。</p><p>这里<strong>注意</strong>一下函数中的警告信息，在属性命名的优先等级上，Vue 认为<code>props</code>中的属性优先级应该比<code>data</code>高，而<code>data</code>的属性优先级应该比<code>methods</code>高。</p><p>再看最后一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observe data</span></span><br><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br></pre></td></tr></table></figure><p>使用<code>observe</code>函数监听<code>data</code>选项，把<code>data</code>选项的数据变成成响应式数据。这里传入第二个参数为<code>true</code>，作为根组件的<code>data</code>选项。</p><p>其实，这句代码才是响应式系统的开始。</p><h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a><code>observe</code></h2><p>下面查看<code>observe</code>函数的代码，这是用于监听数据的函数。</p><p>先看下前面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ! 非虚拟节点的对象</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看函数的参数，只有两个参数。第一个参数是需要监听的对象，第二个参数是一个布尔值，用来判断监听的对象是否是根组件数据。</p><p>函数第一行代码判断语句定义了监听数据<code>value</code>的类型，只有是对象类型且不是虚拟节点才符合要求监听的要求，如果不能同时满足这两个条件，直接返回。</p><p>再看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 已经是监听对象了，获取 __ob__，不需要重复监听</span></span><br><span class="line"><span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">  ob = value.__ob__</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp; <span class="comment">// ! 这个属性可以自由的控制对象是否监听</span></span><br><span class="line">  !isServerRendering() &amp;&amp;</span><br><span class="line">  (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">  <span class="built_in">Object</span>.isExtensible(value) &amp;&amp; <span class="comment">// ! 对象可扩展，没有被 freeze</span></span><br><span class="line">  !value._isVue <span class="comment">// ! 不是 Vue 实例</span></span><br><span class="line">) &#123;</span><br><span class="line">  ob = <span class="keyword">new</span> Observer(value) <span class="comment">// ! 实例化一个监听对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明变量<code>ob</code>，它的类型是<code>Observer</code>或者<code>void</code>。</p><p>然后判断<code>value</code>对象中是否有<code>__ob__</code>属性且<code>__ob__</code>必须是<code>Observer</code>类型的，如果满足这两个条件，说明<code>value</code>已经是一个监听的对象，不需要再重复监听，把<code>value.__ob__</code>属性赋值给<code>ob</code>即可；如果<code>value</code>不是监听对象，还必须要符合下面的五个条件，才能去监听<code>value</code>对象。</p><p>我们先看下这五个条件，对象<code>value</code>必须全部满足这五个条件才能被监听。</p><ol><li><strong><code>shouldObserve</code></strong>：这是一个开关，默认为<code>true</code>。在某些特殊场景时，它的值会变成<code>false</code>，这里必须是<code>true</code>，可以通过<code>toggleObserving</code>函数来切换<code>shouldObserve</code>的值，这样我们就可以非常方便的控制哪些对象是否执行监听，这个条件很重要。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * In some cases we may want to disable observation inside a component's</span></span><br><span class="line"><span class="comment"> * update computation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldObserve: boolean = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span>(<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong><code>!isServerRendering()</code></strong>：调用<code>isServerRendering</code>函数可以判断当前是否处于服务端渲染的环境中。如果值为<code>true</code>，说明当前宿主环境不是浏览器环境，不符合监听条件，它的值必须是<code>false</code>才行。</p></li><li><p><strong><code>(Array.isArray(value) || isPlainObject(value))</code></strong>：监听的<code>value</code>必须是数组或者普通对象。</p></li><li><p><strong><code>Object.isExtensible(value)</code></strong>：监听的对象必须是一个可扩展的值。使一个对象变成不可扩展，有以下方法：<code>Object.preventExtensions()</code>、<code>Object.freeze()</code> 以及 <code>Object.seal()</code>，监听的对象必须没有使用过这些方法。</p></li><li><p><strong><code>!value._isVue</code></strong>：监听的对象不能是 Vue 的实例对象。在我们初始化 Vue 的实例对象时会添加一个<code>_isVue</code>属性，这个属性是一个标识，说明该对象是 Vue 的实例对象。</p></li></ol><p>只有同时满足了上面的五个条件，才会调用<code>new</code>方法创建监听器对象，创建的时候需要把监听的对象<code>value</code>传入，并赋值给变量<code>ob</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob = <span class="keyword">new</span> Observer(value) <span class="comment">// ! 实例化一个监听对象</span></span><br></pre></td></tr></table></figure><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><code>Observer</code></h2><p>下面看下<code>Observer</code>监听器的代码，这是一个类，用来创建监听器实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any</span><br><span class="line">  dep: Dep</span><br><span class="line">  vmCount: number <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  observeArray() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Observer</code>类有三个属性和两个方法，三个属性分别是<code>value</code>、<code>dep</code>和<code>vmCount</code>，两个方法分别是<code>walk</code>和<code>observeArray</code>。</p><p>先看下类的构造函数，看前面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line"> <span class="keyword">this</span>.value = value</span><br><span class="line"><span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先初始化三个属性的值，其中<code>value</code>的值是引用传进来的参数<code>value</code>，也就是需要监听的对象。</p><p><code>dep</code>是订阅器<code>Dep</code>的实例对象，主要是用来收集依赖（观察者）的。<code>vmCount</code>是组件标识，根组件的初始值是 0。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>) <span class="comment">// ! 自身实例添加到监听对象的 __ob__ 属性上 (__ob__监听对象标识)</span></span><br></pre></td></tr></table></figure><p>使用<code>def</code>函数定义监听的对象<code>value</code>的属性<code>__ob__</code>为<code>Observer</code>实例对象本身。这里使用了<strong>循环引用</strong>，监听的对象<code>value</code>中有属性<code>__ob__</code>，它的值是<code>Observer</code>实例对象，而实例对象中也有<code>value</code>属性，它的值就是监听的对象<code>value</code>。这样我们可以很方便的从<code>__ob__</code>属性中获取它监听的对象<code>value</code>的值。</p><p>实例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// __ob__ 是不可枚举的属性</span></span><br><span class="line">  __ob__: &#123;</span><br><span class="line">    value: data, <span class="comment">// value 属性指向 data 数据对象本身，这是一个循环引用</span></span><br><span class="line">    dep: dep实例对象, <span class="comment">// new Dep()</span></span><br><span class="line">    vmCount: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下<code>def</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>def</code>函数其实就是<code>Object.defineProperty</code>的简单封装，它的第四个参数<code>enumerable</code>是一个布尔值，用来设置定义的对象是否可以枚举。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 监听数组时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="comment">// ! 判断当前环境的对象中是否有 __proto__ 属性 （是否支持使用 __proto__）</span></span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    protoAugment(value, arrayMethods)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.observeArray(value) <span class="comment">// ! 再次监听数组，监听一些嵌套的数组</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.walk(value) <span class="comment">// ! 监听对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个<code>if</code>语句，判断监听的对象的类型，如果监听的对象是一个数组，执行<code>if</code>中的代码块，否则执行<code>else</code>代码块。</p><p>先看<code>else</code>代码块，也就是监听的对象是一个对象时，调用类的<code>walk</code>方法，并把监听的对象<code>value</code>作为参数传入，这个函数是用来监听<strong>对象类型</strong>的监听对象，它会把监听的对象中的属性变成响应式属性。</p><p>下面查看类的<code>walk</code>方法的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk(obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取传入的参数对象<code>obj</code>的<code>keys</code>值，这里指监听的对象<code>value</code>。</p><p>然后遍历<code>keys</code>，在每次循环时调用了<code>defineReactive</code>函数，同时把对象<code>obj</code>和它的每一个<code>key</code>值作为参数传入。</p><p><code>defineReactive</code>函数的作用就是把对象<code>obj</code>中的每一个<code>key</code>值都变成响应式属性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最核心的地方就是它的响应式系统，这是它最核心的精华，也是明显区别于其他的框架像&lt;code&gt;React&lt;/code&gt;、&lt;code&gt;Angular&lt;/code&gt;的地方。&lt;/p&gt;
&lt;p&gt;在上一章初始化实例属性的时候，讲解了&lt;code&gt;initState&lt;/code&gt;函数，这个函数里面调用了一系列初始化选项的函数，为实例对象&lt;code&gt;vm&lt;/code&gt;初始化了很多属性，这些属性大都是和响应式系统相关的。本章主要围绕&lt;code&gt;initData&lt;/code&gt;函数来进行，因为初始化&lt;code&gt;data&lt;/code&gt;选项几乎涉及到了响应式系统的全部内容。&lt;/p&gt;
&lt;p&gt;先看下&lt;code&gt;initData&lt;/code&gt;函数在&lt;code&gt;initState&lt;/code&gt;函数中的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  initData(vm)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  observe((vm._data = &amp;#123;&amp;#125;), &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* asRootData */&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;判断&lt;code&gt;opts&lt;/code&gt;中是否有&lt;code&gt;data&lt;/code&gt;属性，如果有的话，调用&lt;code&gt;initData&lt;/code&gt;函数初始化&lt;code&gt;data&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;如果没有的话，把实例对象的私有属性&lt;code&gt;_data&lt;/code&gt;设置空对象，并调用&lt;code&gt;observe&lt;/code&gt;函数监听这个空对象。&lt;/p&gt;
&lt;p&gt;其实，Vue 还对外提供了&lt;code&gt;$data&lt;/code&gt; 属性让我们获取&lt;code&gt;data&lt;/code&gt;的值，而&lt;code&gt;$data&lt;/code&gt;代理的就是&lt;code&gt;_data&lt;/code&gt;的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之实例化</title>
    <link href="https://haledeng.com/blog/20190906-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
    <id>https://haledeng.com/blog/20190906-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96/</id>
    <published>2019-09-06T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:35.665Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们讲解 Vue 的实例化时，单独用了两章讲解 Vue 的选项合并的内容，下面开始真正学习 Vue 的实例化。</p><p>继续看<code>_init</code>函数下面的代码，在文件<code>core/instance/init.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="comment">// ! 初始化代理</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  initProxy(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm._renderProxy = vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面讲解中只是提到在非生产环境和生产环境的代码实现结果必须一致，所以<code>initProxy</code>的函数的作用应该为实例对象<code>vm</code>添加属性<code>_renderProxy</code>为<code>vm</code>。真的是这样吗？</p><a id="more"></a><h2 id="initProxy"><a href="#initProxy" class="headerlink" title="initProxy"></a><code>initProxy</code></h2><p>查看下<code>initProxy</code> 的代码，在<code>core/instance/proxy.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initProxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasProxy) &#123;</span><br><span class="line">      <span class="comment">// determine which proxy handler to use</span></span><br><span class="line">      <span class="keyword">const</span> options = vm.$options</span><br><span class="line">      <span class="keyword">const</span> handlers =</span><br><span class="line">        options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler</span><br><span class="line">      vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers) <span class="comment">// ! 使用代理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm <span class="comment">// ! 和生产环境一样直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里必须是在非生产环境中，先判断宿主环境（这里都指浏览器）是否支持<code>Proxy</code>语法，如果不支持，那么就和生产环境一样，直接赋值<code>_renderProxy</code>为<code>vm</code>。</p><p>如果支持，首先声明变量<code>options</code>存储合并后的选项<code>vm.$options</code>，<strong>现在初始化实例的各类属性方法都和选项<code>options</code>相关</strong>。</p><p>然后声明常量<code>handlers</code>存储代理使用的处理器，最后使用<code>new</code>创建一个<code>Proxy</code>实例对象，用<code>_renderProxy</code>属性来代理实例对象<code>vm</code>，并且传入<code>handlers</code>。</p><p><code>handlers</code>有两个值，分别是<code>getHandler</code> 和<code>hasHandler</code>。需要通过条件判断来获取，而条件语句中的<code>options.render._withStripped</code>只有在测试环境中才会出现。所以<code>handlers</code>一般都是指<code>hasHandler</code>。</p><p>下面看下<code>hasHandler</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasHandler = &#123;</span><br><span class="line">  has(target, key) &#123;</span><br><span class="line">    <span class="keyword">const</span> has = key <span class="keyword">in</span> target</span><br><span class="line">    <span class="keyword">const</span> isAllowed =</span><br><span class="line">      allowedGlobals(key) ||</span><br><span class="line">      (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp;</span><br><span class="line">        key.charAt(<span class="number">0</span>) === <span class="string">'_'</span> &amp;&amp;</span><br><span class="line">        !(key <span class="keyword">in</span> target.$data))</span><br><span class="line">    <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key)</span><br><span class="line">      <span class="keyword">else</span> warnNonPresent(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> has || !isAllowed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasHandler</code>是一个对象，主要拦截了代理对象<code>vm</code>的<code>has</code>相关属性，比如拦截<code>in</code>操作符，还有<code>with</code>函数，先看具体的代码逻辑。</p><p>首先，获取声明常量<code>has</code>存储<code>key in target</code>运行的结果，然后声明变量<code>isAllowed</code>，这个变量是判断属性<code>key</code>是否允许访问。只有<code>key</code>是全局访问 API 时或者是以<code>_</code>开头但不是在<code>data</code>选项中的 Vue 的属性时，<code>isAllowed</code>才为<code>true</code>。</p><p>如果<code>has</code>和<code>isAllowed</code>都不为真，还需要判断<code>key</code>是否是<code>data</code>选项上的属性，如果是的话，会提醒以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 的实例对象代理，因为使用<code>_</code> 或 <code>$</code> 开头的属性可能会和 Vue 的内置属性或者方法的名称冲突。如果不是的话，会提醒在模板中使用了<code>key</code>值，但是在实例对象中并没有定义这个值。</p><p>最后返回 <code>has || !isAllowed</code>，即只有<code>has</code>为假且<code>isAllowed</code>为真时才会输出<code>false</code>，其他情况都输入<code>true</code>。</p><p>举一个<strong>例子</strong>，假如访问一个没有定义在实例对象上(或原型链上)的属性的属性时（满足 <code>!has</code>为 <code>true</code>）。</p><p>此时如果这个属性还是全局属性时（满足<code>!isAllowed</code>为<code>false</code>），就不会报错，不会执行那两个<code>warn</code>函数，但是最后会输出<code>false</code>，即<code>key in target</code>的值为<code>false</code>，说明属性不在<code>taregt</code>上。</p><p>但是如果这个属性不是全局属性就会报错，即满足了<code>!has &amp;&amp; ！isAllowed</code>的条件，最后输出<code>true</code>，即<code>key in target</code>的值为<code>true</code>，说明属性在<code>taregt</code>上。</p><p>说了那么多，<strong>为什么在非生产环境时需要使用代理</strong>呢？而生产环境就不需要呢？它们有什么区别吗？</p><p>先看下在实例的渲染函数<code>__render</code>有这样一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 渲染虚拟 Node， 传入 vm.$createElement 方法</span></span><br><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure><p>在渲染时指向了我们的代理<code>_renderProxy</code>，再看下选项中的渲染函数<code>vm.$options.render</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$options.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// render 函数的 this 指向实例的 _renderProxy</span></span><br><span class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, [_v(_s(a))]) <span class="comment">// 在这里访问 a，相当于访问 vm._renderProxy.a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以发现，显然函数使用 <code>with</code> 语句块指定了内部代码的执行环境为 <code>this</code>，由于 <code>render</code> 函数调用的时候使用 <code>call</code> 指定了其 <code>this</code> 指向为 <code>vm._renderProxy</code>，所以 <code>with</code> 语句块内代码的执行环境就是 <code>vm._renderProxy</code>，所以在 <code>with</code> 语句块内访问<code>a</code>就相当于访问<code>vm._renderProxy</code>的 <code>a</code> 属性，前面我们提到过 <code>with</code> 语句块内访问变量将会被<code>Proxy</code>的<code>has</code>代理所拦截，所以自然就执行了 <code>has</code> 函数内的代码。最终通过<code>warnNonPresent</code>打印警告信息给我们。</p><p>所以使用代理的作用就是<strong>为了在开发阶段给我们一个友好而准确的提示</strong>。</p><h2 id="Initial-Function"><a href="#Initial-Function" class="headerlink" title="Initial Function"></a>Initial Function</h2><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expose real self</span></span><br><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm) <span class="comment">// ! 初始化生命周期相关属性 存储本身实例到父节点 新增属性 $parent $root $children $refs 等</span></span><br><span class="line">initEvents(vm) <span class="comment">// ! 初始化事件相关属性 更新 listeners</span></span><br><span class="line">initRender(vm) <span class="comment">// ! 初始化渲染相关属性, 创建VNode 另新增属性 $attrs 和 $listeners</span></span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// ! 调用 beforeCreate 钩子函数</span></span><br><span class="line">initInjections(vm) <span class="comment">// ! 初始化 injections 选项，必须在初始化状态之前</span></span><br><span class="line">initState(vm) <span class="comment">// ! 初始化状态 按顺序 props =&gt; methods =&gt; data =&gt; computed  =&gt; watch</span></span><br><span class="line">initProvide(vm) <span class="comment">// ! 初始化 Provide resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>) <span class="comment">// ! 调用 created 钩子函数</span></span><br></pre></td></tr></table></figure><p>把实例对象赋值到<code>_self</code>属性中，这个属性和<code>_renderProxy</code>属性有点相似，都是赋值为实例对象。</p><p>但是它们的用途并不相同，而且<code>_renderProxy</code>的值在支持<code>proxy</code>的宿主环境时是一个代理对象。</p><p>然后调用一系列的初始化函数来初始化实例对象，<strong>注意：这些函数在调用时都需要传入实例对象<code>vm</code></strong>。</p><h3 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a><code>initLifecycle</code></h3><p>查看<code>initLifecycle</code>函数的代码，这个函数初始化生命周期相关的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是声明变量<code>options</code>存储合并后的选项<code>vm.$options</code>。</p><p>然后是下面这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// locate first non-abstract parent</span></span><br><span class="line"><span class="keyword">let</span> parent = options.parent</span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">  <span class="comment">// ! 查找第一个非抽象的父组件</span></span><br><span class="line">  <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">    parent = parent.$parent</span><br><span class="line">  &#125;</span><br><span class="line">  parent.$children.push(vm) <span class="comment">// ! 把实例存储到父组件里面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm.$parent = parent <span class="comment">// ! 添加父组件属性 $parent</span></span><br><span class="line">vm.$root = parent ? parent.$root : vm <span class="comment">// ! 新增属性 $root</span></span><br></pre></td></tr></table></figure><p>声明变量<code>parent</code>存储<code>options</code>的父组件<code>parent</code>。然后使用<code>if</code>语句通过循环查找，往组件树上一层层的寻找父组件<code>parent</code>，如果<code>parent</code>的选项中有<code>abstract</code>属性，说明这是一个抽象组件，不满足要求，继续往上找，直到找到选项中没有<code>abstract</code>属性的父组件为止，然后把当前的实例对象存储到父组件的<code>$children</code>属性中，建立父子关系。</p><p>什么是<strong>抽象组件</strong>呢？抽象组件就是不会被渲染成真实 DOM 的组件，比如<code>keep-alive</code>、<code>translation</code>等内置组件，它们是具有特殊作用的组件，不会被渲染成真实 DOM。</p><p>抽象组件还有一个特点就是<strong>不会出现在父子关系的路径中</strong>。比如组件<code>compA</code>有子组件<code>compB</code>，子组件<code>compB</code>又有子组件<code>compC</code>，但是组件<code>compB</code>是一个抽象组件，那么<code>compC</code>的父组件就不是<code>compB</code>，而是<code>compA</code>。</p><p>这里有一个<strong>问题</strong>：就是<code>options.parent</code>是从哪里来的？我们只知道合并后的选项是<code>vm.$options</code> ，那么选项中的<code>parent</code>属性是从哪里来的呢？我们在之前的组件的初始化过程中并没有设置这个<code>parent</code>属性。其实，这是 Vue 设置的，是 Vue <strong>自动给实例对象添加了父组件</strong><code>parent</code>，具体如何实现自动添加父组件，这里暂时不讲解。</p><p>然后把父组件赋值给实例对象的<code>$parent</code>属性，再新增一个属性<code>$root</code>，如果存在父组件就把父组件的<code>$root</code>赋值给这个属性；如果没有的话，就赋值为实例对象本身。这个属性是用来存储根组件。如果实例对象有父组件就存储父组件的根组件，没有父组件说明这个实例对象就是根组件，保存实例对象本身即可。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vm.$children = []</span><br><span class="line">vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">vm._watcher = <span class="literal">null</span></span><br><span class="line">vm._inactive = <span class="literal">null</span></span><br><span class="line">vm._directInactive = <span class="literal">false</span></span><br><span class="line">vm._isMounted = <span class="literal">false</span></span><br><span class="line">vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">vm._isBeingDestroyed = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这里初始化一些实例属性的值，其中有我们熟悉的子组件数组<code>$children</code>，还有引用元素或者组件的集合对象<code>$refs</code>。</p><p><strong>注意</strong>，Vue 的实例对象里<strong>以<code>$</code>开头的属性是暴露给用户使用的，而以<code>_</code>开头的属性是 Vue 的私有属性，不会暴露给用户</strong>，这两类属性都属于 Vue 的内置属性，所以用户自定义的属性不能以<code>$</code>或者<code>_</code>开头，否则不会代理到实例对象中，这样为了防止和 Vue 的内置属性名冲突。</p><h3 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a><code>initEvents</code></h3><p>接下来查看<code>initEvents</code>函数的代码，这个函数初始化事件相关的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先添加了两个实例属性<code>_events</code>和<code>_hasHookEvent</code>，<code>_events</code>初始值一个没有原型对象的空对象，而<code>_hasHookEvent</code>初始值为<code>false</code>。</p><p>然后是声明变量<code>listeners</code>存储<code>vm.$options._parentListeners</code>，再判断这个<code>listeners</code>是否存在，如果存在，调用<code>updateComponentListeners</code>并传入<code>vm</code>和<code>listeners</code>更新组件的<code>linsteners</code>。</p><p>我们现在还不知道<code>_parentListeners</code>是从哪里来的，这里先不管。</p><h3 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a><code>initRender</code></h3><p>接下来查看<code>initRender</code> 函数的代码，这个函数初始化渲染相关的属性。</p><p>先看下函数前面的几行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，添加了两个实例属性<code>_vnode</code> 和<code>_staticTrees</code> ，它们的初始值都是<code>null</code>。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = vm.$options</span><br><span class="line"><span class="keyword">const</span> parentVnode = (vm.$vnode = options._parentVnode) <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line"><span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">vm.$scopedSlots = emptyObject</span><br></pre></td></tr></table></figure><p>还是声明变量<code>options</code>存储合并后的选项<code>vm.$options</code>，然后再次为实例对象添加三个实例属性<code>$vnode</code>、``$slots<code>和</code>$scopedSlots<code>。这里暂时先不去管上面代码中</code>options._parentVnode<code>和</code>options._renderChildren`是怎么来的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>) <span class="comment">// ! 编译器渲染模板的渲染方法</span></span><br><span class="line">vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>) <span class="comment">// ! 用户手写代码的渲染方法</span></span><br></pre></td></tr></table></figure><p>新增两个实例方法<code>_c</code>和<code>$createElement</code>，这两个方法都调用了<code>createElement</code>函数，而且调用这个函数时传入的参数个数也是相同，唯一不同的是传入的第六个参数<code>alwaysNormalize</code>的值不同，<code>_c</code>传入的是<code>false</code>，<code>$createElement</code>传入的<code>true</code>。这里先说明下<code>_c</code>方法是编译器渲染模板的渲染方法，而<code>$createElement</code>是用户手写代码时的渲染方法。</p><p>比如我们手写<code>render</code>函数的时候，编写下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render(createElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果换成<code>$createElement</code>来写的话，是下面这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$createElement(<span class="string">'h1'</span>, <span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看最后剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">'$attrs'</span>,</span><br><span class="line">    (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">'$listeners'</span>,</span><br><span class="line">    options._parentListeners || emptyObject,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>, vm)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">'$attrs'</span>,</span><br><span class="line">    (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">'$listeners'</span>,</span><br><span class="line">    options._parentListeners || emptyObject,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中新增实例对象属性<code>$attrs</code>和<code>$listeners</code>，使用<code>defineReactive</code>函数来定义属性，<code>defineReactive</code>在后面讲响应式系统时会分析，它的作用是使对象的<code>key</code>值变成响应式的属性。</p><p>根据 Node 环境不同，在传入<code>defineReactive</code>函数的第四个参数也不同，这个参数是<code>customSetter</code>，是一个自定义<code>setter</code>函数，是可选的。</p><p>在非生产环境中传入的是下面这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数参数是在非生产环境中传入的，当<code>isUpdatingChildComponent</code>为<code>false</code>时，会提示<code>$attrs</code>属性时可读的。这个函数在你设置<code>$attrs</code>或者<code>$listeners</code>的值的时候会执行。</p><p>先看下<code>isUpdatingChildComponent</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUpdatingChildComponent: boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 更新子组件方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentVnode: MountedComponentVNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderChildren: ?Array&lt;VNode&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    isUpdatingChildComponent = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// update $attrs and $listeners hash</span></span><br><span class="line">  <span class="comment">// these are also reactive so they may trigger child update if the child</span></span><br><span class="line">  <span class="comment">// used them during render</span></span><br><span class="line">  vm.$attrs = parentVnode.data.attrs || emptyObject</span><br><span class="line">  vm.$listeners = listeners || emptyObject</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    isUpdatingChildComponent = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isUpdatingChildComponent</code>默认值是<code>false</code>，当调用<code>updateChildComponent</code>函数时，会先把它的值设置为<code>true</code>，然后执行一段代码后，又把它的值设置为<code>false</code>。</p><p>我们注意到中间代码中有对<code>$attrs</code>和<code>$listeners</code>属性进行赋值的操作，即更新这两个属性，因为在这之前已经设置<code>isUpdatingChildComponent</code>的值为<code>false</code>，所以更新属性时不会提示它们是只读属性。</p><h3 id="callHook"><a href="#callHook" class="headerlink" title="callHook"></a><code>callHook</code></h3><p>执行完<code>initRender</code> 函数后，下面执行的是<code>callHook</code>函数，这是执行生命周期钩子的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// ! 调用 beforeCreate 钩子函数</span></span><br></pre></td></tr></table></figure><p>这里是执行的<code>beforeCreate</code>生命周期钩子函数。</p><p>先看下<code>callHook</code>函数代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span>(<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$options[hook]</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span></span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">'hook:'</span> + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数需要传入两个参数，实例对象<code>vm</code>和生命周期钩子函数的名称<code>hook</code>。</p><p>再看函数体的第一行和最后一行，第一行代码是<code>pushTarget()</code> ，最后一行代码<code>popTarget()</code>，看名字应该是目标入栈和出栈，这里先不管它们的逻辑。</p><p>继续看下面的代码，先从合并后的选项<code>vm.$options</code>中通过钩子名称获取钩子的值<code>handlers</code>。从前面的选项的合并中，我们知道<code>handles</code>的值应该是一个数组，数组里面的元素是都是钩子函数。</p><p>因为不是每个组件都有生命周期钩子函数的，所以需要先判断下是否存在<code>handlers</code>。</p><p>如果存在，则遍历这个钩子函数组成的数组，调用<code>invokeWithErrorHandling</code>函数来执行数组里面的函数。</p><p>看下<code>invokeWithErrorHandling</code>函数的代码，在<code>core/util/error.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeWithErrorHandling</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  handler: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  args: null | any[],</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  info: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? handler.apply(context, args) : handler.call(context)</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123;</span><br><span class="line">      res.catch(<span class="function"><span class="params">e</span> =&gt;</span> handleError(e, vm, info + <span class="string">` (Promise/async)`</span>))</span><br><span class="line">      <span class="comment">// issue #9511</span></span><br><span class="line">      <span class="comment">// avoid catch triggering multiple times when nested calls</span></span><br><span class="line">      res._handled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把钩子函数的执行放到处理错误相关的文件中，主要是为了更好的提示错误。</p><p>首先声明变量<code>res</code>，这也是这个函数的返回值。然后开始就使用了<code>try ... catch</code>语句来执行钩子函数，以及捕获可能出现的错误，如果出现错误调用<code>handleError</code>函数来处理。</p><p>重新定义变量<code>res</code>，用来存储函数调用的值，通过判断是否有参数<code>args</code>，然后在执行<code>handler</code>函数的时候是否传入参数。再判断函数的输出值<code>res</code>是不是一个<code>Promise</code>对象，如果是的话，使用<code>catch</code>来捕获<code>Promsie</code>对象的错误。之后再设置返回值<code>res</code>的属性<code>_handled</code>为<code>ture</code>，表示函数已经被调用过。</p><p>函数最后不管有没有出现错误都会返回<code>res</code>。不过我们在使用生命周期钩子函数时，一般很少用到这个返回值。</p><p>接下来看剩下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">  vm.$emit(<span class="string">'hook:'</span> + hook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vm._hasHookEvent</code>是在<code>initEvent</code>时定义的属性，初始值是<code>false</code>，它是用来判断是否有<strong>生命周期钩子的事件监听器</strong>。当组件检查到有<strong>生命周期钩子的事件监听器</strong>时，会把它的值设为<code>true</code>。</p><p>到底什么是<strong>生命周期钩子的事件监听器</strong>呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:beforeCreate</span>=<span class="string">"handleChildBeforeCreate"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:created</span>=<span class="string">"handleChildCreated"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:mounted</span>=<span class="string">"handleChildMounted"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>@hook:</code> 再加上<code>生命周期的名称</code>来监听组件的生命周期事件。</p><p>当实例对象发现有<strong>生命周期钩子的事件监听器</strong>时，会把<code>_hasHookEvent</code>设置为<code>true</code>，这时就会进入下面的逻辑，实例对象会派发一个名为<code>hook: 生命周期函数名字</code>的事件出去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$emit(<span class="string">'hook:'</span> + hook)</span><br></pre></td></tr></table></figure><p>这里有个问题：实例对象是什么时候设置<code>_hasHookEvent</code>为<code>true</code>的呢？这涉及到 Vue 的事件系统，暂时先不管。</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a><code>initState</code></h3><p>调用完生命周期钩子函数后，接下来是<code>initInjections</code>函数的调用，这个函数是初始化<code>injects</code>选项的函数。这里先不管它，后面和初始化<code>provides</code>的函数一起分析。</p><p>现在看下一个<code>initState</code> 函数的代码，在<code>core/instance/state.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是初始化 Vue 的数据相关的函数。首先增加实例属性<code>vm._watchers</code>，初始值为空数组。声明变量<code>opts</code>存储合并后的选项<code>vm.$options</code>。</p><p>然后判断<code>opts</code>中是否有<code>props</code>属性，如果有的话调用<code>initProps</code>函数初始化<code>props</code>选项。再判断<code>opts</code>中是否有<code>methods</code>属性，如果有的话调用<code>initMethods</code>函数初始化<code>methods</code>选项。再在判断<code>opts</code>中是否有<code>data</code>属性，如果有的话调用<code>initData</code>函数初始化<code>data</code>选项；如果没有的话，调用<code>observe</code>监听一个空对象，并传入第二个参数<code>true</code>，表示观测的对象是根组件的<code>data</code>。</p><p>接下来继续判断<code>opts</code>中是否有<code>computed</code>属性，如果有的话调用<code>initComputed</code>函数初始化<code>computed</code>选项。继续判断<code>opts</code>中是否有<code>watch</code>且它不等于 Firefox 浏览器的<code>watch</code>值，如果满足这两个条件的话，调用<code>initWatch</code>函数初始化<code>watch</code>选项。</p><p><strong>小结</strong>，<code>initState</code> 函数统一初始化了<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>和<code>watch</code>这几个数据相关的选项。</p><p><strong>注意这些选项初始化的顺序</strong>。比如<code>props</code>要比<code>data</code>和<code>computed</code>更早的初始化，这样就可以使用<code>props</code>的数据来初始化<code>data</code>或者<code>computed</code>选项的数据，计算属性<code>computed</code>的初始化放在<code>data</code>后面也是因为它的值可以依赖<code>data</code>选项的值。</p><p>一个很重要的<strong>使用场景</strong>，Vue 使用单向流数据，规定子组件不能修改父组件传过的<code>props</code>数据，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。但是在业务场景中，可能需要改变传过来的<code>props</code>的数据，那我们要怎么办呢？</p><p>我们可以把它转存为<code>data</code>或者<code>computed</code>选项的数据，作为这些数据的初始值，这样就相当于改变了<code>props</code>的值。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>, <span class="string">'size'</span>],</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们讲解 Vue 的实例化时，单独用了两章讲解 Vue 的选项合并的内容，下面开始真正学习 Vue 的实例化。&lt;/p&gt;
&lt;p&gt;继续看&lt;code&gt;_init&lt;/code&gt;函数下面的代码，在文件&lt;code&gt;core/instance/init.js&lt;/code&gt;中&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* istanbul ignore else */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ! 初始化代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  initProxy(vm)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  vm._renderProxy = vm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在前面讲解中只是提到在非生产环境和生产环境的代码实现结果必须一致，所以&lt;code&gt;initProxy&lt;/code&gt;的函数的作用应该为实例对象&lt;code&gt;vm&lt;/code&gt;添加属性&lt;code&gt;_renderProxy&lt;/code&gt;为&lt;code&gt;vm&lt;/code&gt;。真的是这样吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之选项合并的策略</title>
    <link href="https://haledeng.com/blog/20190902-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E7%AD%96%E7%95%A5/"/>
    <id>https://haledeng.com/blog/20190902-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E7%AD%96%E7%95%A5/</id>
    <published>2019-09-02T12:00:00.000Z</published>
    <updated>2020-05-07T08:57:26.879Z</updated>
    
    <content type="html"><![CDATA[<p>上一章的代码规范化了各个选项的值，主要是为了接下来更好的进行合并选项。</p><p>下面开始就是真正进行选项合并的代码。</p><p>具体要怎么合并呢？不同的字段的合并策略是一样的吗？</p><a id="more"></a><h2 id="mergeField"><a href="#mergeField" class="headerlink" title="mergeField"></a><code>mergeField</code></h2><p>继续看最后剩下的代码，这里开始进行真正的选项合并。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 遍历默认配置</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">  mergeField(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 遍历用户配置</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 根据 key 值的不同，使用不同的合并策略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeField</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">  options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure><p>首先声明一个变量<code>options</code>为空对象，最后再返回它，这说明选项合并后的值是对象类型。</p><p>然后遍历 Vue 的默认选项<code>parent</code>，调用<code>mergeField</code>函数并传入<code>key</code>值。</p><p>再遍历用户选项<code>child</code>，还是使用<code>mergeField</code>函数并传入<code>key</code>值，但是和上面不同的是要求<code>key</code>必须是<code>parent</code>中没有的字段。</p><p>为什么要这样设计呢？看<code>mergeField</code>函数就知道了。</p><p>在使用策略函数合并时都会把值传入，所以不需要重复调用。</p><p><code>mergeField</code>函数是合并选项字段的方法，首先根据 <code>key</code> 的值选择它的专用的合并策略，如果没有专用的合并策略就使用默认的合并策略。</p><p>这里的<code>strats</code>是一个合并策略函数组成的对象，对象里面的 <code>key</code> 对应选项字段中的<code>key</code>，而它的<code>value</code> 对应的是字段的合并策略函数。再调用策略函数的时候，需要把<code>parent</code>字段的值、<code>child</code>选项字段的值以及实例对象<code>vm</code>和<code>key</code>作为参数一起传入。然后把调用的结果（即合并后的选项）赋值给一开始声明的<code>options</code>对象中。<code>options</code>对象中的<code>key</code>也对应选项字段的<code>key</code>，它的值就是合并选项后的值。</p><p>这就是合并选项的逻辑，比较简单，就是根据选项中不同的字段选择不同的合并策略。不过难点并不在这里，而是在合并选项的策略函数上。</p><p>下面来看下各个字段的合并策略函数。</p><h2 id="strats"><a href="#strats" class="headerlink" title="strats"></a><code>strats</code></h2><h3 id="defaultStrat"><a href="#defaultStrat" class="headerlink" title="defaultStrat"></a><code>defaultStrat</code></h3><p>先看下默认的合并策略<code>defaultStrat</code>函数的代码。在<code>mergeField</code>函数中，我们知道如果<code>strats</code>中没有找到<code>key</code>的合并策略，就会使用默认的合并策略函数。</p><p>代码在<code>core/util/options.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultStrat = <span class="function"><span class="keyword">function</span>(<span class="params">parentVal: any, childVal: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal === <span class="literal">undefined</span> ? parentVal : childVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的逻辑比较简单，如果没有用户选项<code>childVal</code>，就使用默认选项<code>parentVal</code>，否则使用用户选项<code>childVal</code>。</p><p>使用默认合并策略的字段有<code>el</code>和<code>propsData</code>这些字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  strats.el = strats.propsData = <span class="function"><span class="keyword">function</span>(<span class="params">parent, child, vm, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`option "<span class="subst">$&#123;key&#125;</span>" can only be used during instance `</span> +</span><br><span class="line">          <span class="string">'creation with the `new` keyword.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultStrat(parent, child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认选项</span></span><br><span class="line">el: <span class="string">'#app'</span>,</span><br><span class="line">propsData: &#123;</span><br><span class="line">  name: <span class="string">'Hale'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户选项</span></span><br><span class="line">el: <span class="string">'#root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并后选项</span></span><br><span class="line">el: <span class="string">'#root'</span>,</span><br><span class="line">propsData: &#123;</span><br><span class="line">  name: <span class="string">'Hale'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="data-选项的合并策略"><a href="#data-选项的合并策略" class="headerlink" title="data 选项的合并策略"></a><code>data</code> 选项的合并策略</h3><p>接下来看下<code>data</code>字段的合并策略函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">strats.data = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'The "data" option should be a function '</span> +</span><br><span class="line">            <span class="string">'that returns a per-instance value in component '</span> +</span><br><span class="line">            <span class="string">'definitions.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数逻辑分为两种情况，有实例对象<code>vm</code>和没有<code>vm</code>。</p><p>当我们使用<code>Vue.extend</code>方法生成子类时，这个子类是一个构造函数，当它的<code>options</code>作为用户选项<code>childVal</code>时，它是没有<code>vm</code>的。</p><p>不过不管有没有实例对象，它都是使用<code>mergeDataOrFn</code>函数来进行选项合并的。</p><p>另外，子类组件的<code>data</code>选项如果不是函数类型，在非生产环境时会报错，然后直接返回<code>parentVal</code>选项。</p><h4 id="mergeDataOrFn"><a href="#mergeDataOrFn" class="headerlink" title="mergeDataOrFn"></a><code>mergeDataOrFn</code></h4><p>下面看下<code>mergeDataOrFn</code>函数的代码，这里的逻辑同样分为两种情况，分别为有实例对象<code>vm</code>和没有<code>vm</code>。</p><p>先看下没有实例对象<code>vm</code>的代码，即合并子类的选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> childVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mergeData(</span><br><span class="line">        <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal,</span><br><span class="line">        <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是两个 <code>if</code>语句，先看第一个。如果没有子选项 <code>childVal</code>，就返回父选项<code>parentVal</code>。比如我们在扩展时没有设置<code>data</code>选项的值。像下面这种情况，就会采用这种逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stor = Vue.extend(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>可能有人会问既然子选项 <code>childVal</code>中没有设置<code>data</code>选项，父选项<code>parentVal</code>通常也不会有<code>data</code>的值，都没有<code>data</code>这个字段，也就不存在去调用<code>data</code>的策略函数了。</p><p>为什么还要返回<code>parentVal</code>，<code>parentVal</code>可能存在吗？</p><p>答案是肯定的，如下示例代码中，在使用二次<code>extend</code>时，<code>Child</code> 子类的<code>parentVal</code> 是存在的，就是在创建<code>Parent</code>子类时传入的<code>data</code>的值。但是在创建<code>Child</code>子类时没有传入<code>data</code>的值，所以<code>Child</code>的<code>childVal</code>是没有的。那么对于<code>Child</code>的子类的创建的函数，存在<code>parentVal</code>而不存在<code>childVal</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = Vue.extend(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">test1</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> Child = Parent.entend(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>接下来再看第二个<code>if</code>语句。如果没有<code>parentVal</code>，就返回<code>childVal</code>。其实这种情况在实际开发中应该是<strong>出现最多</strong>的。所以<code>parentVal</code>和<code>childVal</code>必定有其中一个，否则就不会执行<code>data</code>选项合并策略了。</p><p>接下来查看<code>parentVal</code>和<code>childVal</code>都存在的情况的逻辑代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mergeData(</span><br><span class="line">    <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal,</span><br><span class="line">    <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回一个函数<code>mergedDataFn</code>，这个函数调用了<code>mergeData</code>来处理<code>data</code>选项的合并，它需要传入<code>childVal</code> 和<code>parentVal</code> 这两个参数。<strong>注意</strong>参数传入的<strong>顺序</strong>，先子后父。另外传入的两个参数只能是对象类型。</p><p>在 Vue 实例组件中<code>data</code>的值都是函数类型的，它是一个返回普通对象的函数。这时需要调用这个函数，输出对象类型的值。在使用<code>call</code>调用的时候传入了两个 <code>this</code>。第一个<code>this</code>是指向<code>data</code>函数的作用域；而第二个<code>this</code>是<code>data</code>函数的参数，指向生成的实例对象。</p><p>接下来看<code>else</code>代码块的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// instance merge</span></span><br><span class="line">  <span class="keyword">const</span> instanceData =</span><br><span class="line">    <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(vm, vm) : childVal</span><br><span class="line">  <span class="keyword">const</span> defaultData =</span><br><span class="line">    <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(vm, vm) : parentVal</span><br><span class="line">  <span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">    <span class="keyword">return</span> mergeData(instanceData, defaultData)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里表示存在实例对象<code>vm</code>的情况，也就是说上面代码是实例对象初始化时合并选项的代码。</p><p>这样也返回一个叫<code>mergedInstanceDataFn</code>函数。函数中需要先获取一个<code>childVal</code>和<code>parentVal</code>生成的对象类型的值。如果选项是函数，需要调用这个函数获取对象类型的值，在调用时传入的参数是两个<code>vm</code>，即实例对象。第一个<code>vm</code>表示<code>this</code>的指向是实例对象，第二个<code>vm</code>是<code>data</code>函数的参数。</p><p>在组件中，<code>data</code>是一个函数，它其实有很多种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    testData: <span class="keyword">this</span>.propsData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外的写法</span></span><br><span class="line">data(vm) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    testData: vm.propsData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用解构</span></span><br><span class="line">data(&#123; propsData &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    testData: propsData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">  <span class="keyword">return</span> mergeData(instanceData, defaultData)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> defaultData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判端<code>childVal</code>输出的值是否存在，如果存在，就调用<code>mergeData</code>函数把它和<code>parentVal</code>输出的值进行合并，不存在就直接返回<code>parentVal</code>输出的值。</p><p>下面看下<code>mergeData</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeData</span>(<span class="params">to: Object, from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to</span><br><span class="line">  <span class="keyword">let</span> key, toVal, fromVal</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = hasSymbol ? <span class="built_in">Reflect</span>.ownKeys(<span class="keyword">from</span>) : <span class="built_in">Object</span>.keys(<span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    key = keys[i]</span><br><span class="line">    <span class="comment">// in case the object is already observed...</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'__ob__'</span>) <span class="keyword">continue</span></span><br><span class="line">    toVal = to[key]</span><br><span class="line">    fromVal = <span class="keyword">from</span>[key]</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(to, key)) &#123;</span><br><span class="line">      <span class="keyword">set</span>(to, key, fromVal)</span><br><span class="line">    &#125; else if (</span><br><span class="line">      toVal !== fromVal &amp;&amp;</span><br><span class="line">      isPlainObject(toVal) &amp;&amp;</span><br><span class="line">      isPlainObject(fromVal)</span><br><span class="line">    ) &#123;</span><br><span class="line">      mergeData(toVal, fromVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mergeData</code>函数接收两个参数，<code>to</code>和<code>from</code>，从参数名中可以看出是把第二个参数合并到第一个参数中。</p><p>然后再看函数的返回值为<code>to</code>，即返第一个参数合并的值，所以为什么我们在上面调用它的时候传入参数的顺序是先子后父了，即先传入<code>childVal</code>再传入<code>parentVal</code>，<strong>因为是以用户选项<code>childVal</code>为主</strong>。</p><p>看代码第一句<code>if (!from) return to</code>，如果没有第二个参数<code>from</code>，直接返回第一个参数<code>to</code>。</p><p>然后获取第二个参数<code>from</code>的 <code>keys</code>，判断是否支持 ES6 的<code>Promise</code> 的语法，如果支持则使用<code>Reflect.ownKeys(from)</code>，不支持就使用对象的方法<code>Object.keys(from)</code>。</p><p>它们两个有什么<strong>区别</strong>吗？使用<code>Object.keys</code>只会返回可枚举的<code>key</code>值，而<code>Reflect.ownKeys</code>会返回<strong>所有的</strong><code>key</code>值。</p><p>然后去遍历<code>keys</code>，如果<code>key</code>是<code>&#39;__ob__</code> 时，这是侦听对象（后面讲响应式系统时再讲解），跳过这次循环。</p><p>在看下<code>to</code>选项是否有<code>key</code>这个值，如果没有的话，使用<code>set</code>方法把它加入到<code>to</code>中。这里的<code>set</code>和全局 API <code>Vue.set</code>是同一个函数，可以把<code>data</code>选项的属性变成响应式。</p><p>另外，还需要判断，在相同<code>key</code>时，<code>to</code>和<code>from</code>的值是否相同，如果不相同且它们都是普通对象时，递归调用<code>mergeData</code>函数进行深度合并。</p><p><strong>小结</strong>，<code>mergeData</code>合并策略是以<code>to</code>选项为主。对于<code>from</code>选项，只有<code>to</code>选项中不存在的<code>key</code>值，才会被添加到<code>to</code>选项中。如果存在相同的<code>key</code>时，当它的值是原型类型时，选取<code>to</code>的值，即<code>to</code>的值覆盖掉<code>from</code>的值；当它的值是对象类型时，使用递归进行深度合并。</p><p>另外还有一点<strong>非常重要</strong>，那就是合并后的<code>data</code>选项还是一个<strong>函数</strong>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    name: <span class="string">'Hale'</span>,</span><br><span class="line">    friends: &#123;</span><br><span class="line">      Beijing: <span class="string">'xiaoming'</span>,</span><br><span class="line">      Shenzhen: <span class="string">'xiaohong'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    friends: &#123;</span><br><span class="line">      Beijing: <span class="string">'Jack'</span>,</span><br><span class="line">      Shanghai: <span class="string">'Amy'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after merge</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    name: <span class="string">'Hale'</span>,</span><br><span class="line">    friends: &#123;</span><br><span class="line">      Beijing: <span class="string">'Jack'</span>,</span><br><span class="line">      Shanghai: <span class="string">'Amy'</span>,</span><br><span class="line">      Shenzhen: <span class="string">'xiaohong'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mergeHook-生命周期函数的合并策略"><a href="#mergeHook-生命周期函数的合并策略" class="headerlink" title="mergeHook 生命周期函数的合并策略"></a><code>mergeHook</code> 生命周期函数的合并策略</h3><p>下面看下生命周期钩子函数的合并策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Array&lt;Function&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Function | ?Array&lt;Function&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">      ? childVal</span><br><span class="line">      : [childVal]</span><br><span class="line">    : parentVal</span><br><span class="line">  <span class="keyword">return</span> res ? dedupeHooks(res) : res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看函数的参数，<code>parentVal</code>是一个由函数组成的数组，而<code>childVal</code>可能是函数或者是由函数组成的数组，它们都是可选的。</p><p>再看代码，没有使用<code>if</code>语句，而是使用了三组三元操作符。</p><p>首先判断是否有<code>childVal</code>，没有的话就返回<code>parentVal</code>。</p><p>有<code>childVal</code>的话，再判断是否有<code>parentVal</code>，如果有<code>parentVal</code>，就把<code>childVal</code>合并到<code>parentVal</code>中组成新的数组。如果没有<code>parentVal</code>，判断<code>childVal</code>的类型是否是数组，如果是数组，就直接返回它本身；如果不是数组，就把它包装成数组并返回。总之合并后的<code>res</code>一定是个数组。</p><p>最后输出结果是还需要调用<code>dedupeHooks</code>函数去除重复的钩子。函数遍历里数组里面的函数，如果多个函数来自同一个引用地址，则会把其它相同引用的函数排除掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupeHooks</span>(<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(hooks[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      res.push(hooks[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的合并策略中可以得知：在组件实例中，创建的钩子可以是函数，也可以是多个函数组成的数组。</p><p><strong>小结</strong>，<code>mergeHook</code> 合并策略是把同类的所有的钩子都合并放到一个数组中。</p><p>但是官方文档中并没有说明这种情况，但是经过实践，是可以这么做的，如下面的代码，输出按照顺序指向函数的打印结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'created hook fn1'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'created hook fn2'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'created hook fn3'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面代码，使用生命周期函数合并策略的字段那肯定就是生命周期钩子，比如<code>beforeCreate</code>、<code>mounted</code>等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span>,</span><br><span class="line">  <span class="string">'serverPrefetch'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentVal</span></span><br><span class="line">created: [<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;&#125;],</span><br><span class="line"></span><br><span class="line"><span class="comment">// childVal</span></span><br><span class="line">created: <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'f3'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after merge</span></span><br><span class="line">created: [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'f3'</span>)</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="mergeAssets-资源选项的合并策略"><a href="#mergeAssets-资源选项的合并策略" class="headerlink" title="mergeAssets 资源选项的合并策略"></a><code>mergeAssets</code> 资源选项的合并策略</h3><p>在 Vue 的实例选项中，<code>components</code>、<code>directives</code>、<code>filters</code>被认为是资源。</p><p>为什么呢？因为这些选项都是可以作为第三方库来提供的。</p><p>资源选项的合并策略的函数是<code>mergeAssets</code> ，下面看下它的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeAssets</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">if</span> (childVal) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; assertObjectType(key, childVal, vm)</span><br><span class="line">    <span class="keyword">return</span> extend(res, childVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有<code>parentVal</code>则以它作为原型对象创建对象<code>res</code>，没有的话以<code>null</code>为原型对象创建对象<code>res</code>。</p><p>然后判断是否有<code>childVal</code>，如果有的话使用<code>extend</code>把它扩展到<code>res</code>中；如果没有的话，直接返回<code>res</code>。</p><p>另外，有<code>childVal</code>且在非生产环境时，会判断<code>childVal</code>的对象中的值是不是一个普通对象，如果不是会报错。</p><p><strong>小结</strong>，<code>mergeAssets</code> 合并策略先创建以<code>parentVal</code>为原型创建对象<code>res</code>，然后再使用<code>extend</code>函数去扩展<code>childVal</code>，这样如果存在相同的<code>key</code>时，<code>childVal</code>选项就不会覆盖掉<code>parentVal</code>选项的值。因为<code>parentVal</code>的是值保存在<code>res</code>的隐式原型对象 <code>__proto__</code>字段中。</p><p><code>extend</code>函数代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</span><br><span class="line">    to[key] = _from[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用资源选项的合并策略的字段当然就是我们上面提到的资源选项<code>components</code>、<code>directives</code>、<code>filters</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  strats[type + <span class="string">'s'</span>] = mergeAssets</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [<span class="string">'component'</span>, <span class="string">'directive'</span>, <span class="string">'filter'</span>]</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentVal</span></span><br><span class="line">components: &#123;</span><br><span class="line">  CompA,</span><br><span class="line">  CompB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// childVal</span></span><br><span class="line">components: &#123;</span><br><span class="line">  CompC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after merge</span></span><br><span class="line">components: &#123;</span><br><span class="line">  CompC,</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">  CompA,</span><br><span class="line"> CompB,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch-选项的合并策略"><a href="#watch-选项的合并策略" class="headerlink" title="watch 选项的合并策略"></a><code>watch</code> 选项的合并策略</h3><p>下面查看<code>watch</code>选项的合并策略的代码，代码比较长，一段一段分析</p><p>首先看最前面的两行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">strats.watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// work around Firefox's Object.prototype.watch...</span></span><br><span class="line">  <span class="keyword">if</span> (parentVal === nativeWatch) parentVal = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (childVal === nativeWatch) childVal = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断，这两个选项是否全等于<code>nativeWatch</code>，它是个什么呢？看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Firefox has a "watch" function on Object.prototype...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nativeWatch = &#123;&#125;.watch</span><br></pre></td></tr></table></figure><p>通过注释和查阅资料得知，Firefox 浏览器会给每个对象的原型中添加<code>watch</code>属性，这样就和 Vue 里面的<code>watch</code>属性名称产生冲突。所以需要判断一下，当 Vue 的 <code>watch</code>属性和 FireFox 浏览器定义的<code>watch</code>的值相同时，会把<code>watch</code>设置为<code>undefined</code>。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (!childVal) <span class="keyword">return</span> <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assertObjectType(key, childVal, vm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br></pre></td></tr></table></figure><p>如果不存在<code>childVal</code>，则返回以<code>parentVal</code>或者<code>null</code>为原型创建的对象。</p><p>在非生产环境中，还会判断下<code>childVal</code>的值是否是一个普通对象，如果不是会报错。</p><p>如果不存在<code>parentVal</code>，则直接返回<code>childVal</code>。</p><p>如果<code>childVal</code>和<code>parentVal</code>都存在，继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ret = &#123;&#125;</span><br><span class="line">extend(ret, parentVal)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">  <span class="keyword">let</span> parent = ret[key]</span><br><span class="line">  <span class="keyword">const</span> child = childVal[key]</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !<span class="built_in">Array</span>.isArray(parent)) &#123;</span><br><span class="line">    parent = [parent]</span><br><span class="line">  &#125;</span><br><span class="line">  ret[key] = parent</span><br><span class="line">    ? parent.concat(child)</span><br><span class="line">    : <span class="built_in">Array</span>.isArray(child)</span><br><span class="line">    ? child</span><br><span class="line">    : [child]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>先什么一个变量<code>ret</code>存储函数的返回值。然后把<code>parentVal</code>扩展到<code>ret</code>对象中，这样<code>ret</code>就拥有<code>parentVal</code>的全部属性。</p><p>然后遍历<code>childVal</code>对象，声明一个变量<code>parent</code>存储<code>ret[key]</code>的值，<strong>注意</strong>这个值可能不存在。声明变量<code>child</code>存储<code>childVal[key]</code>的值，这个值是一定存在的。</p><p>判断如果<code>parent</code>存在且不是数组时，把<code>parent</code>包装成一个数组。最后开始给<code>ret</code>赋值，它的<code>key</code>就是每次遍历<code>childVal</code>的<code>key</code>。在每次遍历的过程中，如果存在<code>parent</code>就把<code>child</code>合并到<code>parent</code>中组成新的数组。</p><p>如果不存在<code>parent</code>，判断<code>child</code>是不是一个数组，如果是的话，就直接返回它本身；如果不是的话，把它包装成数组并返回。最后返回<code>ret</code>这个对象。</p><p><strong>总结</strong>，<code>watch</code>的合并策略和其他的策略不同，它不会去除相同<code>key</code>的值，而是把它们的值组合在一起。也就是说如果有多个监听同一个值的函数，那么当这个值变化时，所有的监听函数都会生效。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentVal</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test parentVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// childVal</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after merge</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  test: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test parentVal'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test change</span></span><br><span class="line">vm.test = <span class="number">2</span></span><br><span class="line"><span class="comment">// test parentVal</span></span><br><span class="line"><span class="comment">// test childVal</span></span><br></pre></td></tr></table></figure><h3 id="props、methods、inject、computed选项的合并策略"><a href="#props、methods、inject、computed选项的合并策略" class="headerlink" title="props、methods、inject、computed选项的合并策略"></a><code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>选项的合并策略</h3><p>看下面一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">strats.props = strats.methods = strats.inject = strats.computed = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (childVal &amp;&amp; process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assertObjectType(key, childVal, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  extend(ret, parentVal)</span><br><span class="line">  <span class="keyword">if</span> (childVal) extend(ret, childVal)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是对<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>字段的合并选项的策略。</p><p>代码逻辑比较简单。首先当<code>childVal</code>存在且在非生产环境中时，会判断<code>childVal</code>的值是否为普通对象，如果不是会报错。然后判断<code>parentVal</code>是否存在，如果不存在，则返回<code>childVal</code></p><p>再声明一个没有原型的对象<code>ret</code>，使用<code>parentVal</code>扩展它。</p><p>最后判断如果有<code>childVal</code>，也把<code>childVal</code>扩展到<code>ret</code>中；如果没有的话，直接返回<code>ret</code>。</p><p><strong>小结</strong>，这个合并策略就是很简单的扩展，先创建一个没有原型的对象<code>ret</code>，先使用<code>parentVal</code>扩展给它，然后再使用<code>childVal</code>扩展它。如果选项中存在相同的<code>key</code>，后面的值会覆盖掉前面的值。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentVal</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'Hale'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  fn1() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal fn1'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// childVal</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'Amy'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  fn2() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal fn2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after merge</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'Amy'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  fn1() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal fn1'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal fn2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="provide-选项的合并策略"><a href="#provide-选项的合并策略" class="headerlink" title="provide 选项的合并策略"></a><code>provide</code> 选项的合并策略</h3><p>看下<code>provide</code> 选项的合并策略的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strats.provide &#x3D; mergeDataOrFn</span><br></pre></td></tr></table></figure><p><code>provide</code> 选项沿用了<code>data</code>选项的一样的合并策略，这里就不多赘述了。</p><h3 id="extends和mixins的合并策略"><a href="#extends和mixins的合并策略" class="headerlink" title="extends和mixins的合并策略"></a><code>extends</code>和<code>mixins</code>的合并策略</h3><p>看下<code>extends</code>和<code>mixins</code>的合并策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.extends, vm) <span class="comment">// ! 合并 extends</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.mixins[i], vm) <span class="comment">// ! 合并 mixins</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解完成所有的合并策略后，再看<code>extends</code>和<code>mixins</code>的合并策略，这里在前面规范化的时候已经讲解过了。</p><p>我们都知道<code>extends</code>和<code>mixins</code>选项的作用是复用组件代码，那么选项里面的值就可能是上面出现的所有选项字段，所以需要使用递归进行深度合并，然后再次沿用上面的合并策略。</p><h2 id="合并策略总结"><a href="#合并策略总结" class="headerlink" title="合并策略总结"></a>合并策略总结</h2><p>所有的合并策略已经已经讲解完毕，下面进行总结。</p><ul><li>对于 <code>el</code>、<code>propsData</code> 选项使用默认的合并策略 <code>defaultStrat</code>。</li><li>对于 <code>data</code> 选项，使用 <code>mergeDataOrFn</code> 函数进行处理，最终结果是 <code>data</code> 选项将变成一个新的函数，这个函数返回<code>mergeData</code>函数处理的数据，<code>mergeData</code>是真正合并选项的函数。</li><li>对于 <code>生命周期钩子</code> 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行。</li><li>对于 <code>directives</code>、<code>filters</code> 和 <code>components</code> 资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。</li><li>对于 <code>watch</code> 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的字段，把它们合并为数组，这样所有的观察者都将被执行。</li><li>对于 <code>props</code>、<code>methods</code>、<code>inject</code>和<code>computed</code> 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。</li><li>对于 <code>provide</code> 选项，其合并策略使用与 <code>data</code> 选项相同的 <code>mergeDataOrFn</code> 函数。</li><li>最后，以上没有提及到的选项都将使默认选项 <code>defaultStrat</code>，只要子选项不是 <code>undefined</code>就使用子选项，否则使用父选项。</li></ul><h2 id="optionMergeStrategies-自定义合并策略"><a href="#optionMergeStrategies-自定义合并策略" class="headerlink" title="optionMergeStrategies 自定义合并策略"></a><code>optionMergeStrategies</code> 自定义合并策略</h2><p>Vue 在全局配置中还提供了一个可以自定义合并策略的选项<code>optionMergeStrategies</code>，让用户可以为一些非系统选项字段提供自定义的合并策略，而不是使用默认的合并策略。</p><p>比如为自定义字段<code>customOption</code>的提供自定义的合并策略``optionMergeStrategies`。</p><p>示例代码如下，现在在入口文件<code>main.js</code>中配置合并策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies.customOption = <span class="function"><span class="keyword">function</span>(<span class="params">parent, child, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parent ? parent + child : child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在实例组件中使用这个自定义的字段<code>customOption</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  customOption: <span class="number">2</span>,</span><br><span class="line">  extends: &#123;</span><br><span class="line">    customOption: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      a: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption) <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="options-合并后选项的使用"><a href="#options-合并后选项的使用" class="headerlink" title="$options 合并后选项的使用"></a><code>$options</code> 合并后选项的使用</h3><p>使用<code>mergeOptions</code>后会返回一个对象，这个对象就是合并后的选项，在实例化中会把这个对象赋值给实例的<code>$options</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor), <span class="comment">// ! Vue 初始化时的默认选项,比如默认的指令和组件等等</span></span><br><span class="line">  options || &#123;&#125;, <span class="comment">// ! 用户传入的配置</span></span><br><span class="line">  vm <span class="comment">// !  Vue 实例对象本身</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>vm.$options</code>这个属性<strong>非常重要</strong>，在接下来设置其他的实例属性时<strong>至关重要</strong>，因为都会用到它。</p><p>在实例组件中也可以调用这个属性去拿到合并后的选项，包括我们自己输入的选项，这样我们可以更好的编写组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      a: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test method'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.name) <span class="comment">// 'Home'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.methods.test) <span class="comment">// function test() &#123; console.log('test method') &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章的代码规范化了各个选项的值，主要是为了接下来更好的进行合并选项。&lt;/p&gt;
&lt;p&gt;下面开始就是真正进行选项合并的代码。&lt;/p&gt;
&lt;p&gt;具体要怎么合并呢？不同的字段的合并策略是一样的吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之选项合并的规范化</title>
    <link href="https://haledeng.com/blog/20190830-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    <id>https://haledeng.com/blog/20190830-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96/</id>
    <published>2019-08-30T12:00:00.000Z</published>
    <updated>2020-05-07T08:56:14.777Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用<code>new</code>创建 Vue 的实例对象时，必定传入一个参数对象<code>options</code>进去，这个参数对象其实就是 Vue 的选项<code>options</code>。比如在 Vue 项目的入口文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>另外，创建每一个组件时，在<code>script</code>中也会导出一个对象，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 省略模板代码 --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这个对象也是用户输入的<code>options</code>，项目入口文件有<code>options</code>，组件也有<code>options</code>，再加上 Vue 本身也自带<code>options</code>，这么多的<code>options</code>看起来非常乱，所以需要合并选项。</p><p>在初始化实例的方法<code>_init</code>中，使用了<code>mergeOptions</code>方法合并选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">  <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">  <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">  initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ! 合并配置</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor), <span class="comment">// ! Vue 初始化时的默认选项,比如默认的指令和组件等等</span></span><br><span class="line">    options || &#123;&#125;, <span class="comment">// ! 用户传入的配置</span></span><br><span class="line">    vm <span class="comment">// !  Vue 实例对象本身</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>mergeOptions</code>方法传入了三个参数，分别是默认选项、用户选项以及实例对象本身。</p><p>第一个参数是默认选项，通过调用<code>resolveConstructorOptions</code>函数时传入<code>vm.constructor</code>参数来获取的。</p><h2 id="resolveConstructorOptions"><a href="#resolveConstructorOptions" class="headerlink" title="resolveConstructorOptions"></a><code>resolveConstructorOptions</code></h2><p>先看下<code>resolveConstructorOptions</code>函数的代码，从函数名可以看出这个函数的作用应该是解析构造函数的选项的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数传入的参数是<code>vm.constructor</code>，即实例对象的构造函数，也就是<code>Vue</code>。</p><p>先声明变量<code>options</code>存储构造函数的<code>options</code>，然后下面是一个条件语言，如果存在<code>Ctor.super</code>属性，就会执行后面的代码。这个<code>super</code>的属性到底是什么呢？</p><p>如果我们使用了 Vue 的全局方法<code>extend</code>创建一个子类，再通过这个子类创建一个实例对象，那么这个实例对象的<code>constructor</code>就是这个子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = Vue.extend() <span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Sub() <span class="comment">// 子类生成的实例对象</span></span><br></pre></td></tr></table></figure><p>通过<code>extend</code>创建的子类会有一个特性的属性<code>super</code>，它的值一般就是 Vue 的构造函数。</p><p>因为这里是 Vue 的实例初始化的过程，所以传入的参数<code>Ctor</code>就是 Vue 的构造函数，而不是子类，也不可能有<code>super</code>属性，所以函数的<code>if</code>的代码块是不会执行的。</p><p>在实例对象创建的过程中，这个函数就可以简化为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数最后返回<code>Ctor.options</code>，即<code>Vue</code>的默认选项<code>options</code>。它现在应该是下面这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">KeepAlive</span><br><span class="line">Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">&#125;,</span><br><span class="line">directives:&#123;</span><br><span class="line">    model,</span><br><span class="line">        show</span><br><span class="line">&#125;,</span><br><span class="line">filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">_base: Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些选项都是在扩展 Vue 的构造函数和平台化包装时添加到 Vue 的构造函数的<code>options</code>属性中的。</p><p><code>mergeOptions</code>函数传入的第二个参数<code>options</code>是用户输入的，在 Vue 项目的入口文件中，使用<code>new</code>创建 Vue 的实例并传入选项配置，传入的选项可能是下面这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mergeOptions</code>函数传入的最后一个参数<code>vm</code>，这是实例对象本身。</p><h2 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a><code>mergeOptions</code></h2><h3 id="checkComponents"><a href="#checkComponents" class="headerlink" title="checkComponents"></a><code>checkComponents</code></h3><p>分析函数调用时的参数后，接下来看下<code>mergeOptions</code>函数的代码，在<code>core/util/options.js</code>文件中</p><p>函数代码比较长，先看前面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    checkComponents(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先查看函数的参数，参数分别是<code>parent</code>、<code>child</code>和<code>vm</code>。在实例初始化调用函数的，<code>parent</code>就是默认选项配置，<code>child</code>是用户输入的选项配置，<code>vm</code>是实例对象。</p><p>再看函数体代码，在非生产环境中，会调用<code>checkComponents</code>函数检查一下<code>child</code>选项，这里主要校验选项的<code>components</code>属性中的各个组件名。</p><p>我们在组件中引入另外一个组件时，都需要注册引入的这个组件，注册是把组件放入到<code>components</code>选项中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CompA <span class="keyword">from</span> <span class="string">'../components/CompA'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; CompA &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下<code>checkComponents</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkComponents</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options.components) &#123;</span><br><span class="line">    validateComponentName(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中遍历<code>components</code>选项中的元素，再使用<code>validateComponentName</code>函数检查下选项中的<code>name</code>是否符合要求。<code>name</code>就是<code>components</code>对象中<code>key</code>的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateComponentName</span>(<span class="params">name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^[a-zA-Z][\\-\\.0-9_<span class="subst">$&#123;unicodeRegExp.source&#125;</span>]*$`</span>).test(name)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Invalid component name: "'</span> +</span><br><span class="line">        name +</span><br><span class="line">        <span class="string">'". Component names '</span> +</span><br><span class="line">        <span class="string">'should conform to valid custom element name in html5 specification.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isBuiltInTag(name) || config.isReservedTag(name)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Do not use built-in or reserved HTML elements as component '</span> +</span><br><span class="line">        <span class="string">'id: '</span> +</span><br><span class="line">        name</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了两个<code>if</code>来判断<code>name</code>的值是否符合要求，也就是需要同时符合这两个条件才不会报错。</p><ol><li><p>满足正则表达式<code>new RegExp(<code>^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$</code>)</code></p></li><li><p>满足条件<code>isBuiltInTag(name) || config.isReservedTag(name)</code></p></li></ol><p>对于第一条，<code>name</code>的值的开头必须由字符组成，后面可以是<code>-</code>符或者<code>.</code>符或者数字以及特殊字符。</p><p>对于第二条，<code>name</code>的值不能是 Vue 内置的组件名比如<code>slot</code>、<code>componnet</code>或者是保留的 HTML 标签名。</p><p><code>isBuiltInTag</code>函数的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>isReservedTag</code>函数的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isReservedTag = (tag: string): ?<span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="functional-options"><a href="#functional-options" class="headerlink" title="functional options"></a><code>functional options</code></h3><p>继续看<code>mergeOptions</code>函数下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 当 child 是函数时（Vue.extend 创造的子类），获取其静态属性 options</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'function'</span>) &#123;</span><br><span class="line">  child = child.options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户的选项是函数类型的，就获取它的<code>options</code>属性。</p><p>什么时候选项是一个函数呢？另外，什么函数会有属性<code>options</code>呢？</p><p>Vue 的构造函数就有这个<code>options</code>属性，另外通过<code>Vue.extend</code>创建的子类也可能会有<code>optinons</code>属性。</p><p>也就是说对于<code>child</code>这个参数可以传入一个 Vue 的构造函数，也可以传入通过<code>Vue.extend</code>的创建的子类。</p><h3 id="normalizeFn"><a href="#normalizeFn" class="headerlink" title="normalizeFn"></a><code>normalizeFn</code></h3><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 有些类型的选项比较灵活多变，需要先规范化后，再合并</span></span><br><span class="line">normalizeProps(child, vm) <span class="comment">// ! 规范化 props 类型</span></span><br><span class="line">normalizeInject(child, vm) <span class="comment">// ! 规范化 inject 类型</span></span><br><span class="line">normalizeDirectives(child) <span class="comment">// ! 规范化 指令</span></span><br></pre></td></tr></table></figure><p>这里使用了三个函数去规范化选项，分别规范<code>props</code>、<code>inject</code>和<code>directive</code>选项。</p><p>为什么要去规范化这些选项呢？以<code>props</code>选项为例，它的值非常灵活，即可以是数组，也可以是对象。另外，对象里面的值可以是一个表示数据类型的值，也可以是一个普通对象。</p><p>示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">props: [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: <span class="built_in">String</span>, <span class="comment">// 默认值为类型</span></span><br><span class="line">  age: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 为使用者提供这些灵活的接口，对于我们来说是好事，但对于 Vue 来说却不是，因为需要把不同类型或者格式的数据规范成统一的数据类型和格式，这样后面才能更好的合并选项。</p><p>下面分别查看每个规范函数的代码，这些函数都是在<code>core/util/options.js</code>文件中。</p><h4 id="normalizeProps"><a href="#normalizeProps" class="headerlink" title="normalizeProps"></a><code>normalizeProps</code></h4><p>查看<code>normalizeProps</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.props</span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> i, val, name</span><br><span class="line">  <span class="comment">// ! 规范数组类型的 props</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    i = props.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">        name = camelize(val)</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125; <span class="comment">// !不清除类型统一设置为 null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="string">'props must be strings when using array syntax.'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 规范对象类型的 props</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key]</span><br><span class="line">      name = camelize(key)</span><br><span class="line">      res[name] = isPlainObject(val) ? val : &#123; <span class="attr">type</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "props": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(props)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res <span class="comment">// ! 最终都转换成对象类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeProps</code>函数是用来规范<code>props</code>选项的，代码逻辑并不难。因为选项<code>props</code>的值只能有两种类型，使用 <code>if</code>语句分别判断这两种类型即可，如果它的值都不是这两种类型，在非生产环境中会报错。</p><p>先声明一个变量<code>res</code>存储规范后的值，它的初始值是一个对象，然后再进行规范。</p><p>当<code>props</code>的值是数组类型时，遍历数组，然后以数组的每个元素作为<code>key</code>，<code>{type: null}</code>作为值，组成键值对的形式存储在前面声明的变量<code>res</code>中。另外还需要判断数组里面的元素的值必须是字符串类型，否则在非生产环境中会报错。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">props: [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的数组类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>props</code>的值是对象时，遍历对象，使用变量<code>val</code>存储对象中原有的值，如果值是一个普通的对象时，直接赋值为原来的值；如果不是，就把这个值转换成类型的值<code>{type: val}</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的处理过程中使用了<code>camelize</code>函数把每个连字符<code>-</code>形式的<code>key</code>转换成驼峰的形式。</p><p><strong>小结</strong>，不管<code>props</code>选项的值是数组类型还是对象类型，最后都会转换成对象类型，然后对象里的值也是一个对象。</p><h4 id="normalizeInject"><a href="#normalizeInject" class="headerlink" title="normalizeInject"></a><code>normalizeInject</code></h4><p>查看<code>normalizeInject</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeInject</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inject = options.inject</span><br><span class="line">  <span class="keyword">if</span> (!inject) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> normalized = (options.inject = &#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inject.length; i++) &#123;</span><br><span class="line">      normalized[inject[i]] = &#123; <span class="attr">from</span>: inject[i] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> inject) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = inject[key]</span><br><span class="line">      normalized[key] = isPlainObject(val)</span><br><span class="line">        ? extend(&#123; <span class="attr">from</span>: key &#125;, val)</span><br><span class="line">        : &#123; <span class="attr">from</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "inject": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(inject)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">s</span><br></pre></td></tr></table></figure><p><code>normalizeInject</code>函数是用来规范<code>inject</code>选项的，代码逻辑也不难。选项<code>inject</code>的用法和<code>props</code>有点相似，它的值可以是数组类型也可以是对象类型。如果不是这两种类型，在非生产环境中会报错。</p><p>当<code>inject</code>的值是数组类型时，遍历数组，然后转换成键值对的对象类型，其中键和值都是原来的数组元素。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">inject: [<span class="string">'data1'</span>, <span class="string">'data2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的数组类型</span></span><br><span class="line">injecrt: &#123;</span><br><span class="line">  data1: &#123; <span class="attr">from</span>: <span class="string">'data1'</span>&#125;,</span><br><span class="line">data2: &#123; <span class="attr">from</span>: <span class="string">'data2'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>inject</code>的值为对象类型时，遍历对象。如果对象里的值是普通对象时，在对象里面设置 <code>from</code> 的值为原来 <code>key</code> 的值，然后和原来的对象进行合并；如果对象里的值是字符串时，把它变成一个对象，在设置对象里面的<code>from</code>的值为原来的字符串类型的值，原来对象的 <code>key</code>不会改变。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  data1, <span class="comment">// 相当于 data1: data1</span></span><br><span class="line">  d2: <span class="string">'data2'</span>,</span><br><span class="line">  data3: &#123; <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的对象类型</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  data1: &#123; <span class="attr">from</span>: <span class="string">'data1'</span> &#125;,</span><br><span class="line">  d2: &#123; <span class="attr">from</span>: <span class="string">'data2'</span>&#125;,</span><br><span class="line">  data3: &#123; <span class="attr">from</span>: <span class="string">'data3'</span>, <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>，不管<code>inject</code>选项的值是数组类型还是对象类型，最后都会转换成对象类型，然后对象里的值也是一个对象。</p><h4 id="normalizeDirectives"><a href="#normalizeDirectives" class="headerlink" title="normalizeDirectives"></a><code>normalizeDirectives</code></h4><p>查看<code>normalizeDirectives</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeDirectives</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dirs = options.directives</span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dirs) &#123;</span><br><span class="line">      <span class="keyword">const</span> def = dirs[key]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">'function'</span>) &#123;</span><br><span class="line">        dirs[key] = &#123; <span class="attr">bind</span>: def, <span class="attr">update</span>: def &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeDirectives</code>函数是用来规范<code>directives</code>选项的。<code>directives</code>的值只能是对象类型，但是对象里面的值可以是函数类型，也可以是对象类型。如果它的值是一个函数，就把它转换成对象，并赋值成为对象的<code>bind</code>和<code>update</code>属性，如果它的值是一个对象，则不用转换。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  test1: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  test2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  test1: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  test2: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规范化extends-和mixins"><a href="#规范化extends-和mixins" class="headerlink" title="规范化extends 和mixins"></a>规范化<code>extends</code> 和<code>mixins</code></h3><p>继续看<code>mergeOptions</code>函数后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.extends, vm) <span class="comment">// ! 合并 extends</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.mixins[i], vm) <span class="comment">// ! 合并 mixins</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是处理<code>options</code>中的<code>extends</code>选项和<code>mixins</code>选项的，这两个选项都和组件的代码复用有关。</p><p>对于这两个选项，都是递归调用<code>mergeOptions</code>来处理，并且把默认的<code>parent</code>选项 、用户输入的<code>extends</code>或者<code>mixins</code>选项进行合并，生成一个全新的选项作为默认选项<code>parent</code>。</p><p><code>extends</code>选项的值是不管是对象类型还是函数类型，都可以直接和<code>parent</code>选项进行合并，因为前面已经对函数类型的值进行了处理。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">extends: &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型，使用 Vue.extend 生成子类</span></span><br><span class="line"><span class="keyword">const</span> Ctor = Vue.extend(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">extends: Ctor</span><br></pre></td></tr></table></figure><p>而<code>mixins</code>选项的值必须是数组类型，所以需要遍历数组，而数组中的元素<code>mixin</code>必须是对象类型，所以可以按照顺序一个个和<code>parent</code>进行合并。这里注意一下优先级，数组中排序靠后的<code>mixin</code>中的配置会覆盖前面的<code>mixin</code>的配置。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">userMixin: &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">playMixin: &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixins: [userMixin, playMixin]</span><br></pre></td></tr></table></figure><p>另外，创建每一个组件时，在<code>script</code>中也会导出一个对象，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 省略模板代码 --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这个对象也是用户输入的<code>options</code>，项目入口文件有<code>options</code>，组件也有<code>options</code>，再加上 Vue 本身也自带<code>options</code>，这么多的<code>options</code>看起来非常乱，所以需要合并选项。</p><p>在初始化实例的方法<code>_init</code>中，使用了<code>mergeOptions</code>方法合并选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">  <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">  <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">  initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ! 合并配置</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor), <span class="comment">// ! Vue 初始化时的默认选项,比如默认的指令和组件等等</span></span><br><span class="line">    options || &#123;&#125;, <span class="comment">// ! 用户传入的配置</span></span><br><span class="line">    vm <span class="comment">// !  Vue 实例对象本身</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>mergeOptions</code>方法传入了三个参数，分别是默认选项、用户选项以及实例对象本身。</p><p>第一个参数是默认选项，通过调用<code>resolveConstructorOptions</code>函数时传入<code>vm.constructor</code>参数来获取的。</p><h2 id="resolveConstructorOptions-1"><a href="#resolveConstructorOptions-1" class="headerlink" title="resolveConstructorOptions"></a><code>resolveConstructorOptions</code></h2><p>先看下<code>resolveConstructorOptions</code>函数的代码，从函数名可以看出这个函数的作用应该是解析构造函数的选项的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数传入的参数是<code>vm.constructor</code>，即实例对象的构造函数，也就是<code>Vue</code>。</p><p>先声明变量<code>options</code>存储构造函数的<code>options</code>，然后下面是一个条件语言，如果存在<code>Ctor.super</code>属性，就会执行后面的代码。这个<code>super</code>的属性到底是什么呢？</p><p>如果我们使用了 Vue 的全局方法<code>extend</code>创建一个子类，再通过这个子类创建一个实例对象，那么这个实例对象的<code>constructor</code>就是这个子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = Vue.extend() <span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Sub() <span class="comment">// 子类生成的实例对象</span></span><br></pre></td></tr></table></figure><p>通过<code>extend</code>创建的子类会有一个特性的属性<code>super</code>，它的值一般就是 Vue 的构造函数。</p><p>因为这里是 Vue 的实例初始化的过程，所以传入的参数<code>Ctor</code>就是 Vue 的构造函数，而不是子类，也不可能有<code>super</code>属性，所以函数的<code>if</code>的代码块是不会执行的。</p><p>在实例对象创建的过程中，这个函数就可以简化为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数最后返回<code>Ctor.options</code>，即<code>Vue</code>的默认选项<code>options</code>。它现在应该是下面这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">KeepAlive</span><br><span class="line">Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">&#125;,</span><br><span class="line">directives:&#123;</span><br><span class="line">    model,</span><br><span class="line">        show</span><br><span class="line">&#125;,</span><br><span class="line">filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">_base: Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些选项都是在扩展 Vue 的构造函数和平台化包装时添加到 Vue 的构造函数的<code>options</code>属性中的。</p><p><code>mergeOptions</code>函数传入的第二个参数<code>options</code>是用户输入的，在 Vue 项目的入口文件中，使用<code>new</code>创建 Vue 的实例并传入选项配置，传入的选项可能是下面这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mergeOptions</code>函数传入的最后一个参数<code>vm</code>，这是实例对象本身。</p><h2 id="mergeOptions-1"><a href="#mergeOptions-1" class="headerlink" title="mergeOptions"></a><code>mergeOptions</code></h2><h3 id="checkComponents-1"><a href="#checkComponents-1" class="headerlink" title="checkComponents"></a><code>checkComponents</code></h3><p>分析函数调用时的参数后，接下来看下<code>mergeOptions</code>函数的代码，在<code>core/util/options.js</code>文件中</p><p>函数代码比较长，先看前面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    checkComponents(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先查看函数的参数，参数分别是<code>parent</code>、<code>child</code>和<code>vm</code>。在实例初始化调用函数的，<code>parent</code>就是默认选项配置，<code>child</code>是用户输入的选项配置，<code>vm</code>是实例对象。</p><p>再看函数体代码，在开发环境中，会调用<code>checkComponents</code>函数检查一下<code>child</code>选项，这里主要校验选项的<code>components</code>属性中的各个组件名。</p><p>我们在组件中引入另外一个组件时，都需要注册引入的这个组件，注册是把组件放入到<code>components</code>选项中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CompA <span class="keyword">from</span> <span class="string">'../components/CompA'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; CompA &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下<code>checkComponents</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkComponents</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options.components) &#123;</span><br><span class="line">    validateComponentName(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中遍历<code>components</code>选项中的元素，再使用<code>validateComponentName</code>函数检查下选项中的<code>name</code>是否符合要求。<code>name</code>就是<code>components</code>对象中<code>key</code>的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateComponentName</span>(<span class="params">name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^[a-zA-Z][\\-\\.0-9_<span class="subst">$&#123;unicodeRegExp.source&#125;</span>]*$`</span>).test(name)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Invalid component name: "'</span> +</span><br><span class="line">        name +</span><br><span class="line">        <span class="string">'". Component names '</span> +</span><br><span class="line">        <span class="string">'should conform to valid custom element name in html5 specification.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isBuiltInTag(name) || config.isReservedTag(name)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Do not use built-in or reserved HTML elements as component '</span> +</span><br><span class="line">        <span class="string">'id: '</span> +</span><br><span class="line">        name</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了两个<code>if</code>来判断<code>name</code>的值是否符合要求，也就是需要同时符合这两个条件才不会报错。</p><ol><li><p>满足正则表达式<code>new RegExp(<code>^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$</code>)</code></p></li><li><p>满足条件<code>isBuiltInTag(name) || config.isReservedTag(name)</code></p></li></ol><p>对于第一条，<code>name</code>的值的开头必须由字符组成，后面可以是<code>-</code>符或者<code>.</code>符或者数字以及特殊字符。</p><p>对于第二条，<code>name</code>的值不能是 Vue 内置的组件名比如<code>slot</code>、<code>componnet</code>或者是保留的 HTML 标签名。</p><p><code>isBuiltInTag</code>函数的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>isReservedTag</code>函数的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isReservedTag = (tag: string): ?<span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="functional-options-1"><a href="#functional-options-1" class="headerlink" title="functional options"></a><code>functional options</code></h3><p>继续看<code>mergeOptions</code>函数下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 当 child 是函数时（Vue.extend 创造的子类），获取其静态属性 options</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'function'</span>) &#123;</span><br><span class="line">  child = child.options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户的选项是函数类型的，就获取它的<code>options</code>属性。</p><p>什么时候选项是一个函数呢？另外，什么函数会有属性<code>options</code>呢？</p><p>Vue 的构造函数就有这个<code>options</code>属性，另外通过<code>Vue.extend</code>创建的子类也可能会有<code>optinons</code>属性。</p><p>也就是说对于<code>child</code>这个参数可以传入一个 Vue 的构造函数，也可以传入通过<code>Vue.extend</code>的创建的子类。</p><h3 id="normalizeFn-1"><a href="#normalizeFn-1" class="headerlink" title="normalizeFn"></a><code>normalizeFn</code></h3><p>接下来继续看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 有些类型的选项比较灵活多变，需要先规范化后，再合并</span></span><br><span class="line">normalizeProps(child, vm) <span class="comment">// ! 规范化 props 类型</span></span><br><span class="line">normalizeInject(child, vm) <span class="comment">// ! 规范化 inject 类型</span></span><br><span class="line">normalizeDirectives(child) <span class="comment">// ! 规范化 指令</span></span><br></pre></td></tr></table></figure><p>这里使用了三个函数去规范化选项，分别规范<code>props</code>、<code>inject</code>和<code>directive</code>选项。</p><p>为什么要去规范化这些选项呢？以<code>props</code>选项为例，它的值非常灵活，即可以是数组，也可以是对象。另外，对象里面的值可以是一个表示数据类型的值，也可以是一个普通对象。</p><p>示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">props: [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: <span class="built_in">String</span>, <span class="comment">// 默认值为类型</span></span><br><span class="line">  age: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 为使用者提供这些灵活的接口，对于我们来说是好事，但对于 Vue 来说却不是，因为需要把不同类型或者格式的数据规范成统一的数据类型和格式，这样后面才能更好的合并选项。</p><p>下面分别查看每个规范函数的代码，这些函数都是在<code>core/util/options.js</code>文件中。</p><h4 id="normalizeProps-1"><a href="#normalizeProps-1" class="headerlink" title="normalizeProps"></a><code>normalizeProps</code></h4><p>查看<code>normalizeProps</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.props</span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> i, val, name</span><br><span class="line">  <span class="comment">// ! 规范数组类型的 props</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    i = props.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">        name = camelize(val)</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125; <span class="comment">// !不清除类型统一设置为 null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="string">'props must be strings when using array syntax.'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 规范对象类型的 props</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key]</span><br><span class="line">      name = camelize(key)</span><br><span class="line">      res[name] = isPlainObject(val) ? val : &#123; <span class="attr">type</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "props": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(props)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res <span class="comment">// ! 最终都转换成对象类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeProps</code>函数是用来规范<code>props</code>选项的，代码逻辑并不难。因为选项<code>props</code>的值只能有两种类型，使用 <code>if</code>语句分别判断这两种类型即可，如果它的值都不是这两种类型，在开发环境中会报错。</p><p>先声明一个变量<code>res</code>存储规范后的值，它的初始值是一个对象，然后再进行规范。</p><p>当<code>props</code>的值是数组类型时，遍历数组，然后以数组的每个元素作为<code>key</code>，<code>{type: null}</code>作为值，组成键值对的形式存储在前面声明的变量<code>res</code>中。另外还需要判断数组里面的元素的值必须是字符串类型，否则在开发环境中会报错。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">props: [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的数组类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>props</code>的值是对象时，遍历对象，使用变量<code>val</code>存储对象中原有的值，如果值是一个普通的对象时，直接赋值为原来的值；如果不是，就把这个值转换成类型的值<code>{type: val}</code>。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的对象类型</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  age: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的处理过程中使用了<code>camelize</code>函数把每个连字符<code>-</code>形式的<code>key</code>转换成驼峰的形式。</p><p><strong>小结</strong>，不管<code>props</code>选项的值是数组类型还是对象类型，最后都会转换成对象类型，然后对象里的值也是一个对象。</p><h4 id="normalizeInject-1"><a href="#normalizeInject-1" class="headerlink" title="normalizeInject"></a><code>normalizeInject</code></h4><p>查看<code>normalizeInject</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeInject</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inject = options.inject</span><br><span class="line">  <span class="keyword">if</span> (!inject) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> normalized = (options.inject = &#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inject.length; i++) &#123;</span><br><span class="line">      normalized[inject[i]] = &#123; <span class="attr">from</span>: inject[i] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> inject) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = inject[key]</span><br><span class="line">      normalized[key] = isPlainObject(val)</span><br><span class="line">        ? extend(&#123; <span class="attr">from</span>: key &#125;, val)</span><br><span class="line">        : &#123; <span class="attr">from</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "inject": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(inject)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">s</span><br></pre></td></tr></table></figure><p><code>normalizeInject</code>函数是用来规范<code>inject</code>选项的，代码逻辑也不难。选项<code>inject</code>的用法和<code>props</code>有点相似，它的值可以是数组类型也可以是对象类型。如果不是这两种类型，在开发环境中会报错。</p><p>当<code>inject</code>的值是数组类型时，遍历数组，然后转换成键值对的对象类型，其中键和值都是原来的数组元素。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">inject: [<span class="string">'data1'</span>, <span class="string">'data2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的数组类型</span></span><br><span class="line">injecrt: &#123;</span><br><span class="line">  data1: &#123; <span class="attr">from</span>: <span class="string">'data1'</span>&#125;,</span><br><span class="line">data2: &#123; <span class="attr">from</span>: <span class="string">'data2'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>inject</code>的值为对象类型时，遍历对象。如果对象里的值是普通对象时，在对象里面设置 <code>from</code> 的值为原来 <code>key</code> 的值，然后和原来的对象进行合并；如果对象里的值是字符串时，把它变成一个对象，在设置对象里面的<code>from</code>的值为原来的字符串类型的值，原来对象的 <code>key</code>不会改变。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  data1, <span class="comment">// 相当于 data1: data1</span></span><br><span class="line">  d2: <span class="string">'data2'</span>,</span><br><span class="line">  data3: &#123; <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后的对象类型</span></span><br><span class="line">inject: &#123;</span><br><span class="line">  data1: &#123; <span class="attr">from</span>: <span class="string">'data1'</span> &#125;,</span><br><span class="line">  d2: &#123; <span class="attr">from</span>: <span class="string">'data2'</span>&#125;,</span><br><span class="line">  data3: &#123; <span class="attr">from</span>: <span class="string">'data3'</span>, <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>，不管<code>inject</code>选项的值是数组类型还是对象类型，最后都会转换成对象类型，然后对象里的值也是一个对象。</p><h4 id="normalizeDirectives-1"><a href="#normalizeDirectives-1" class="headerlink" title="normalizeDirectives"></a><code>normalizeDirectives</code></h4><p>查看<code>normalizeDirectives</code>函数的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeDirectives</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dirs = options.directives</span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dirs) &#123;</span><br><span class="line">      <span class="keyword">const</span> def = dirs[key]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">'function'</span>) &#123;</span><br><span class="line">        dirs[key] = &#123; <span class="attr">bind</span>: def, <span class="attr">update</span>: def &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeDirectives</code>函数是用来规范<code>directives</code>选项的。<code>directives</code>的值只能是对象类型，但是对象里面的值可以是函数类型，也可以是对象类型。如果它的值是一个函数，就把它转换成对象，并赋值成为对象的<code>bind</code>和<code>update</code>属性，如果它的值是一个对象，则不用转换。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  test1: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  test2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范后</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  test1: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v-test1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  test2: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'v-test2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规范化extends-和mixins-1"><a href="#规范化extends-和mixins-1" class="headerlink" title="规范化extends 和mixins"></a>规范化<code>extends</code> 和<code>mixins</code></h3><p>继续看<code>mergeOptions</code>函数后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.extends, vm) <span class="comment">// ! 合并 extends</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.mixins[i], vm) <span class="comment">// ! 合并 mixins</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是处理<code>options</code>中的<code>extends</code>选项和<code>mixins</code>选项的，这两个选项都和组件的代码复用有关。</p><p>对于这两个选项，都是递归调用<code>mergeOptions</code>来处理，并且把默认的<code>parent</code>选项 、用户输入的<code>extends</code>或者<code>mixins</code>选项进行合并，生成一个全新的选项作为默认选项<code>parent</code>。</p><p><code>extends</code>选项的值是不管是对象类型还是函数类型，都可以直接和<code>parent</code>选项进行合并，因为前面已经对函数类型的值进行了处理。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">extends: &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型，使用 Vue.extend 生成子类</span></span><br><span class="line"><span class="keyword">const</span> Ctor = Vue.extend(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">extends: Ctor</span><br></pre></td></tr></table></figure><p>而<code>mixins</code>选项的值必须是数组类型，所以需要遍历数组，而数组中的元素<code>mixin</code>必须是对象类型，所以可以按照顺序一个个和<code>parent</code>进行合并。这里注意一下优先级，数组中排序靠后的<code>mixin</code>中的配置会覆盖前面的<code>mixin</code>的配置。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">userMixin: &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">playMixin: &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixins: [userMixin, playMixin]</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用&lt;code&gt;new&lt;/code&gt;创建 Vue 的实例对象时，必定传入一个参数对象&lt;code&gt;options&lt;/code&gt;进去，这个参数对象其实就是 Vue 的选项&lt;code&gt;options&lt;/code&gt;。比如在 Vue 项目的入口文件中&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; vm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  el: &lt;span class=&quot;string&quot;&gt;&#39;#app&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  router,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  store,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;h&lt;/span&gt; =&amp;gt;&lt;/span&gt; h(App)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之初始化开篇</title>
    <link href="https://haledeng.com/blog/20190828-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E7%AF%87/"/>
    <id>https://haledeng.com/blog/20190828-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E7%AF%87/</id>
    <published>2019-08-28T12:00:00.000Z</published>
    <updated>2020-05-07T08:56:21.481Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 的基本的结构我们已经弄清楚了，下面正式学习 Vue 的实例对象初始化过程。</p><p>现在我们回到出生地文件<code>core/instance/index.js</code>，查看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在使用<code>new</code>的创建实例对象的过程中，会执行构造函数中的<code>this._init()</code>方法，并且把选项参数<code>options</code>传入，这就是 Vue 的初始化方法。</p><a id="more"></a><h2 id="init-初始化方法"><a href="#init-初始化方法" class="headerlink" title="_init 初始化方法"></a><code>_init</code> 初始化方法</h2><p>这个方法是通过<code>initMixin(Vue)</code>函数添加到 Vue 的构造函数的原型对象中的，现在打开<code>core/instance/init.js</code>文件，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 初始化的方法</span></span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++ <span class="comment">// ! 唯一标示</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>_init</code>方法中首先使用常量<code>vm</code>来缓存<code>this</code>，但是这个<code>this</code>到底指向哪里呢？</p><p>我们知道在构造函数中，是使用<code>this._init()</code>调用的这个方法的，而且是在使用<code>new</code>创建实例的时候调用的，那么这个<code>this</code>很明显应该指向的是创建的<strong>实例对象</strong>。</p><p>然后往实例对象中添加唯一标识<code>_uid</code>，它是一个常量，初始值是<code>0</code>，它的值是递增的 ，所以每一个实例对象的<code>_uid</code>值都是<strong>不一样</strong>的。</p><p>继续看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTag, endTag</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="comment">// ! 性能追踪相关</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">  endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">  mark(startTag) <span class="comment">// ! 性能追踪前标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">  mark(endTag) <span class="comment">// ! 性能追踪后标记</span></span><br><span class="line">  measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的省略了中间的主要逻辑代码，只保留了两处代码。这两处代码是非生产环境时使用的，用来测试中间代码的性能。</p><p>接下来查看省略的中间部分的代码，这才是<code>_init</code>主要的逻辑代码。</p><p>先看代码的前面部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">vm._isVue = <span class="literal">true</span></span><br><span class="line"><span class="comment">// merge options</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">  <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">  <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">  initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ! 合并配置</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor), <span class="comment">// ! Vue 初始化时的默认配置,比如默认的指令和组件等等</span></span><br><span class="line">    options || &#123;&#125;, <span class="comment">// ! 用户传入的配置</span></span><br><span class="line">    vm <span class="comment">// !  Vue 实例对象本身</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了<code>_isVue</code>属性，这个属性是一个布尔值，用来标识当前的对象是 Vue 的实例对象。然后通过选项的<code>_isComponent</code>属性判断这是不是一个组件，如果是组件就调用<code>initInternalComponent</code>函数初始化这个组件。</p><p>在创建实例对象的过程中，根本就没有<code>_isComponent</code>这个属性，所以现在应该执行<code>else</code>块中的代码，调用<code>mergeOptions</code>函数<strong>合并选项（配置）</strong>，把 Vue 的默认选项和用户输入的选项进行合并，这里需要把实例对象也传入进去。</p><p>关于 Vue 的默认选项，还记得在 core 增加静态属性和方法时，遍历<code>ASSET_TYPES</code>数组时初始化了<code>Vue.options</code>中的几个空对象吗？它们分别是<code>components</code>、<code>directives</code>、<code>filters</code>，然后把内置组件<code>&lt;keep-alive /&gt;</code>组件放入到<code>components</code>中。</p><p>后面在 Runtime 入口文件对构造函数进行包装时，也设置了 Web 平台的<code>config</code>属性，还增加两个指令到<code>directives</code>, 增加了两个过渡动画组件到<code>components</code>中，其实这些就是 Vue 的<strong>默认选项</strong>。</p><p>这里通过<code>resolveConstructorOptions</code>函数来获取这些默认选项。</p><p>用户选项就是我们创建 Vue 实例时输入的选项，比如在项目入口文件时使用<code>new</code>创建根组件时传入的对象就是根实例的选项配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外，我们在 Vue 组件中的<code>script</code>标签导出的对象也是实例组件的选项配置。</p><p>现在 Vue2 的 API 其实就是选项（options） API，所以合并选项是 Vue 源码中非常重要的内容，后面会单独分析。</p><p>继续查看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="comment">// ! 初始化代理</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  initProxy(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm._renderProxy = vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非生产环境中会调用<code>initProxy</code>方法并传入 Vue 的实例对象，而在生产环境中是直接给实例赋值属性<code>_renderProxy</code>为 <code>vm</code>。现在虽然不知道<code>initProxy</code>方法的内容，但是我们可以判断它的功能应该也是为实例属性<code>_renderProxy</code>赋值，因为生产环境和开发环境的代码实现的结果应该是一致的。</p><p>继续查看后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expose real self</span></span><br><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm) <span class="comment">// ! 初始化生命周期相关配置 存储本身实例到父节点 新增属性 $parent $root $children $refs 等</span></span><br><span class="line">initEvents(vm) <span class="comment">// ! 初始化事件相关配置 更新 listeners</span></span><br><span class="line">initRender(vm) <span class="comment">// ! 初始化渲染, 创建VNode 另新增属性 $attrs 和 $listeners</span></span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// ! 调用 beforeCreate 钩子函数</span></span><br><span class="line">initInjections(vm) <span class="comment">// ! 初始化 Injections resolve injections before data/props</span></span><br><span class="line">initState(vm) <span class="comment">// ! 初始化状态 按顺序 props =&gt; methods =&gt; data =&gt; computed  =&gt; watch</span></span><br><span class="line">initProvide(vm) <span class="comment">// ! 初始化 Provide resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>) <span class="comment">// ! 调用 created 钩子函数</span></span><br></pre></td></tr></table></figure><p>上面函数中的函数名很多是以<code>init</code>开头的，因为这些函数才是真正初始化实例的函数。</p><p>大概查看了一下这些函数，发现它们也是为实例对象<code>vm</code>添加或者更新各种属性或者方法的，但是和前面为构造函数的原型对象添加属性和方法时不同。</p><p>这些函数都有一个<strong>共同点</strong>：那就是需要传入实例对象<code>vm</code>，并且会用到<code>vm.$options</code>这个属性。这个属性是合并后的选项，借助这个属性为实例对象<code>vm</code>再次添加或者更新属性或者方法。比如我们在<code>options</code>设置了<code>data: { name: &#39;Hale&#39;}</code>，那么在初始化后会把这个属性放入到实例的<code>_data</code>属性中，并且还会把它变成响应式数据。</p><p>这里还有两个是调用了<code>callHook</code>方法，这是去执行生命周期钩子函数，它们是<code>beforeCreate</code>和<code>created</code>这两个生命周期钩子函数。在 <code>options</code> 选项中，如果我们设置了这两个生命周期钩子函数，那么就会在这里，按照上面函数的执行顺序来执行。</p><h3 id="关于组件中请求数据的时机"><a href="#关于组件中请求数据的时机" class="headerlink" title="关于组件中请求数据的时机"></a>关于组件中请求数据的时机</h3><p>这里简单分析一下请求数据的时机，在实际开发中，我们可能需要在实例组件向后端请求接口数据，然后保存到<code>data</code>属性中，让他们变成响应式数据。</p><p>从上面的代码中，我们发现<code>beforeCreate</code>生命周期函数钩子执行的时机，是在<code>initState</code>之前执行，而在这个时候 Vue 实例组件中还没有初始化<code>state</code>，所以不适合在这个钩子函数里面去请求数据并赋值给<code>data</code>属性。</p><p>而<code>created</code>生命周期函数钩子是在最后面的时候执行的，也就是在实例初始化完成之后执行。这个时候就可以去请求数据的，因为这是<code>state</code>应该初始化完成了，在这个钩子函数里面请求后的数据赋值给<code>data</code>后也会变成响应式的数据。</p><p>另外也还可以在<code>mounted</code>生命周期函数钩子中请求数据，这个钩子在挂载组件后执行，但是它没有在<code>created</code>钩子中请求的时机那么快。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 的基本的结构我们已经弄清楚了，下面正式学习 Vue 的实例对象初始化过程。&lt;/p&gt;
&lt;p&gt;现在我们回到出生地文件&lt;code&gt;core/instance/index.js&lt;/code&gt;，查看下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; initMixin &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./init&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;options&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt; &amp;amp;&amp;amp; !(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Vue)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    warn(&lt;span class=&quot;string&quot;&gt;&#39;Vue is a constructor and should be called with the `new` keyword&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._init(options)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;initMixin(Vue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在使用&lt;code&gt;new&lt;/code&gt;的创建实例对象的过程中，会执行构造函数中的&lt;code&gt;this._init()&lt;/code&gt;方法，并且把选项参数&lt;code&gt;options&lt;/code&gt;传入，这就是 Vue 的初始化方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2源码学习笔记之平台化包装</title>
    <link href="https://haledeng.com/blog/20190826-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%8C%85%E8%A3%85/"/>
    <id>https://haledeng.com/blog/20190826-Vue2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%8C%85%E8%A3%85/</id>
    <published>2019-08-26T12:00:00.000Z</published>
    <updated>2020-05-07T08:56:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>在 core 文件夹下面的代码是 Vue 的核心代码，它并不涉及任何与平台相关的内容。</p><p>Vue 的平台目前主要有两个， 分别是 Web 平台和 Weex 平台。 Web 平台是和浏览器相关，它里面的代码运行在浏览器中。而 Weex 平台的代码却是和移动端相关的，这里不作介绍。</p><p>下面主要还是学习 Web 平台相关的代码。平台化包装也有两个版本，分别是 Runtime （运行时）版本和 Runtime + Compiler （完整）版本。其中，运行时版本是完整版本的组成部分，完整版本还包含了编译器。</p><a id="more"></a><h2 id="运行时版本"><a href="#运行时版本" class="headerlink" title="运行时版本"></a>运行时版本</h2><p>运行时的版本比较简单，因为没有涉及到编译器，它的编译入口是<code>platforms/webpack/entry-runtime.js</code>，下面查看它的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>这个文件只是单独的引用了<code>platforms/web/runtime/index.js</code>文件中的<code>Vue</code>，然后再把它导出。</p><p>现在打开这个引用的文件，查看它的代码。先看前面的部分代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'core/index'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'core/config'</span></span><br><span class="line"><span class="keyword">import</span> &#123; extend, noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mountComponent &#125; <span class="keyword">from</span> <span class="string">'core/instance/lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; devtools, inBrowser &#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  query,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  isReservedAttr,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  isUnknownElement</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'web/util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; patch &#125; <span class="keyword">from</span> <span class="string">'./patch'</span></span><br><span class="line"><span class="keyword">import</span> platformDirectives <span class="keyword">from</span> <span class="string">'./directives/index'</span></span><br><span class="line"><span class="keyword">import</span> platformComponents <span class="keyword">from</span> <span class="string">'./components/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform specific utils</span></span><br><span class="line"><span class="comment">// ! 设置 web 平台配置选项</span></span><br><span class="line">Vue.config.mustUseProp = mustUseProp</span><br><span class="line">Vue.config.isReservedTag = isReservedTag</span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>先不管导入的模块部分。看上面代码的最后几行，这里再次设置了 Vue 的构造函数的<code>config</code>属性。</p><p>还记得我们在核心代码 core 中也设置<code>config</code>属性，不过那里的设置的都是些初始值或者空值。</p><p>现在配置的值，都是和 Web 平台相关的。给构造函数<code>Vue</code>的<code>config</code>设置了五个属性，分别是：<code>mustUseProp</code>、<code>isReservedTag</code>、<code>isReservedAttr</code>、<code>getTagNamespace</code>和<code>isUnknownElement</code>，先不去管这些属性。</p><p>继续查看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 安装 web 平台运行时的指令 v-model v-show 和组件 &lt;transition/&gt; &lt;transition-group/&gt;</span></span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)s</span><br></pre></td></tr></table></figure><p>使用<code>extend</code>方法，给<code>Vue</code>选项中的<code>directives</code> 和<code>components</code>扩展内容。这些是和平台相关的组件和指令。</p><p>那么到底扩展了什么内容呢？查看<code>runtime/directives/index.js</code>文件的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></span><br><span class="line"><span class="keyword">import</span> show <span class="keyword">from</span> <span class="string">'./show'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model,</span><br><span class="line">  show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给指令集<code>directives</code>扩展了两个新指令<code>model</code>和<code>show</code> ，即<code>v-model</code>和 <code>v-show</code>，这两个指令应该都非常熟悉吧，这里就不多介绍了。</p><p>然后再查看<code>runtime/components/index.js</code>文件的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Transition <span class="keyword">from</span> <span class="string">'./transition'</span></span><br><span class="line"><span class="keyword">import</span> TransitionGroup <span class="keyword">from</span> <span class="string">'./transition-group'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Transition,</span><br><span class="line">  TransitionGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给组件数组<code>components</code>扩展了两个新组件<code>Transition</code>和<code>TransitionGroup</code>，这两个组件是设置过渡动画的组件。</p><p>接下来继续看<code>runtime/index.js</code>上的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platform patch functionll</span></span><br><span class="line"><span class="comment">// ! 安装 web 平台的 __patch__ 方法</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="comment">// ! 安装 web 平台的挂载方法 $mount （这里是 runtime 版本）</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 Vue 构造函数的原型对象上添加了两个方法<code>__patch__</code>和<code>$mount</code>。</p><p><code>__patch__</code>是把虚拟 DOM 转换成真实 DOM 的补丁方法。这里还判断了是否是浏览器环境，如果不是则为<code>noop</code>，<code>noop</code>是一个空函数。</p><p><code>$mount</code>是组件的挂载方法，不过因为这里的是 Runtime 版本，在完整版本中还会对这个方法进行扩展，增加编译器相关的代码。</p><p>再看最后的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inBrowser) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.devtools) &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>在浏览器环境中安装<code>vue-devtool</code>的全局钩子，用于在浏览器中进行开发调试。</p><p>最后是导出 Vue 的构造函数<code>Vue</code>，这样运行时版本的 Vue 的平台化包装（扩展）就完成了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>Runtime</strong> 版本的入口文件主要给 Vue 的构造函数添加了 Web 平台专用的属性和方法。</p><ul><li><p>在<code>Vue.config</code>配置了五个 Web 平台专用属性，分别是：<code>mustUseProp</code>、<code>isReservedTag</code>、<code>isReservedAttr</code>、<code>getTagNamespace</code>和<code>isUnknownElement</code>。</p></li><li><p>在<code>Vue.options</code>的<code>fileters</code> 属性添加两个指令<code>v-model</code>和<code>v-show</code>。</p></li><li><p>在<code>Vue.options</code>的<code>components</code>属性添加两个过渡动画组件<code>Transition</code>和<code>TransitionGroup</code>。</p></li><li><p>在<code>Vue</code>的原型对象上增加两个方法<code>__patch__</code> 和 <code>$mount</code>。</p></li><li><p>安装<code>vue-devtool</code>的全局钩子</p></li></ul><h2 id="带编译版本"><a href="#带编译版本" class="headerlink" title="带编译版本"></a>带编译版本</h2><p>下面再查看完整版本编译器的入口文件<code>platforms/webpack/entry-runtime-with-compiler.js</code>，对比运行时版本的入口文件，主要是增加了编译器相关的代码。</p><p>打开这个文件，先看前面的部分代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'core/config'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn, cached &#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mark, measure &#125; <span class="keyword">from</span> <span class="string">'core/util/perf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span> <span class="comment">// ! 导入 runtime 版本的 Vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; query &#125; <span class="keyword">from</span> <span class="string">'./util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; compileToFunctions &#125; <span class="keyword">from</span> <span class="string">'./compiler/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  shouldDecodeNewlines,</span><br><span class="line">  shouldDecodeNewlinesForHref</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./util/compat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 通过 id 获取元素的 innerHTML</span></span><br><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id)</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先还是引入模块文件，其中包括引入 Runtime 版本的 Vue 的构造函数<code>Vue</code>。</p><p>然后定义一个通过 id 获取元素的 <code>innerHTML</code> 的方法<code>idToTemplate</code>，在下面重写<code>$mount</code>方法中会用到。</p><p>继续往下看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount <span class="comment">// ! 缓存 runtime 版本的 $mount 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 重写 $mount 方法 with compiler</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先缓存了运行时版本的<code>$mount</code>方法，然后又重写了这个方法，主要是加入了编译器相关的代码。</p><p>先不管重写的<code>$mount</code>方法，继续查看最后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Get outerHTML of elements, taking care</span><br><span class="line"> * of SVG elements in IE as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getOuterHTML(el: Element): string &#123;</span><br><span class="line">  if (el.outerHTML) &#123;</span><br><span class="line">    return el.outerHTML</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const container &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    container.appendChild(el.cloneNode(true))</span><br><span class="line">    return container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.compile &#x3D; compileToFunctions &#x2F;&#x2F; ! 新增方法 compile</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure><p>定义了一个<code>getOuterHTML</code>方法，这个方法在上面重写<code>$mount</code>方法中会用到。</p><p>然后给<code>Vue</code>新增了一个静态方法<code>compile</code>，赋值为<code>compileToFunctions</code>方法，从方法的名字可以看出这应该是一个编译的方法，把模板字符串编译成渲染函数。</p><p>但是，这个方法从哪里来的呢？是从<code>platforms/web/compiler/index.js</code>文件中引入进来的，暂时先不管它。</p><p>最后还是导出 Vue 的构造函数<code>Vue</code>，这样包含编译器的 Vue 的平台化包装（扩展）也完成了。</p><p><strong>总结</strong>，这个带编译器的入口文件代码结构其实也很简单，就是重写运行时版本中 Vue 构造函数的原型对象的<code>$mount</code>方法，在重写的过程中添加编译相关的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到了这一步，Vue 的构造函数的扩展就已经初步完成。</p><p>现在再次回顾下 Vue 的构造函数<code>Vue</code>最初的样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数非常简单，如果把警告的代码再去掉，代码会更少，内容就只有一行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，就是这么一个简单的构造函数，在经过一系列的扩展和包装后，就成为了一个非常复杂的前端框架。</p><p>实在是有点不可思议，这也说明 Vue 的结构设计非常清晰明了！</p><p>回顾下它是怎么扩展的</p><ul><li><code>core/instance/index.js</code>：扩展构造函数的原型对象的属性和方法</li><li><code>core/index.js</code>：扩展构造函数静态的属性和方法</li><li><code>platforms/webpack/entry-runtime.js</code>：扩展 Web 平台专用的属性和方法</li><li><code>platforms/webpack/entry-runtime-with-compiler.js</code>：重写运行时的<code>$mount</code>方法，添加编译相关的代码。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">Vue 技术内幕</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">Vue 技术揭秘</a></p></li><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue 文档</a></p></li><li><p><a href="https://github.com/haledc/vue/tree/learn-vue" target="_blank" rel="noopener">Vue 源码学习分支</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 core 文件夹下面的代码是 Vue 的核心代码，它并不涉及任何与平台相关的内容。&lt;/p&gt;
&lt;p&gt;Vue 的平台目前主要有两个， 分别是 Web 平台和 Weex 平台。 Web 平台是和浏览器相关，它里面的代码运行在浏览器中。而 Weex 平台的代码却是和移动端相关的，这里不作介绍。&lt;/p&gt;
&lt;p&gt;下面主要还是学习 Web 平台相关的代码。平台化包装也有两个版本，分别是 Runtime （运行时）版本和 Runtime + Compiler （完整）版本。其中，运行时版本是完整版本的组成部分，完整版本还包含了编译器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://haledeng.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://haledeng.com/tags/Vue/"/>
    
      <category term="源码学习" scheme="https://haledeng.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
